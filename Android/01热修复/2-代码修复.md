# 1. 类加载方案

## 原理

JVM虚拟机要运行一个Class时首先需要将class文件加载到内存中，这个过程包含加载、链接(验证、准备、解析)、初始化，在Java中，这些工作都是由`ClassLoader`完成的。通过下面自定义ClassLoader我们能大概明白这是一个什么过程：

```Java
public class MyClassLoader extends ClassLoader {
    //class文件所在路径
    private String path;
    public MyClassLoader(String path) {
        this.path = path;
    }
    //自定义ClassLoader只需要重写findClass()方法
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            //1. 通过流将class文件转化为流
            name = path + name + ".class";
            InputStream is = null;
            ByteArrayOutputStream outputStream = null;
            try {
                is = new FileInputStream(new File(name));
                outputStream = new ByteArrayOutputStream();
                int i = 0;
                while ((i = is.read()) != -1)
                    outputStream.write(i);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (outputStream != null)
                    outputStream.close();
                if (is != null)
                    is.close();
            }
            //2. 得到class文件的字节数组
            byte[] b = outputStream.toByteArray();
            //3. 调用definClass方法将字节数组转换为class的实例，这个方法会完成加载、链接(验证、准备、解析)、初始化的操作
            return defineClass(name, b, 0, b.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

Android中也不例外，它提供了`PathClassLoader`和`DexClassLoader`两个类加载器，我们可以通过[Android社区](https://www.androidos.net.cn/sourcecode)在线查看源码，这两个加载器是专门用于加载Android平台特定的dex格式类文件的，dex可以看作是很多class文件的一个压缩包，而通过上面两个类加载器可以从压缩包中加载出单个的class。下面我们简单看下这几个类的描述

```Java
#### libcore/dalvik/src/main/java/dalvik/system

/**用于加载dex包的class文件的ClassLoader实现*/
public class BaseDexClassLoader extends ClassLoader {
  private final DexPathList pathList; //dex文件集合
  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
      //调用DexPathList的findClass方法来获取dex包中的class文件
      Class c = pathList.findClass(name, suppressedExceptions);
      //...
      return c;
  }
}
/**Android将这个类用于其系统类加载器和应用程序类加载器*/
public class PathClassLoader extends BaseDexClassLoader {
}
/**
  * 一个类装入器，从包含classes.dex的.jar、.zip、.apk文件中加载类
  * 可用于执行未作为应用程序一部分安装的代码
  * 注意：需要为构造方法指定一个data/data/包名/files/optimize_dex解压路径（保护应用程序免受代码注入攻击）
  */
public class DexClassLoader extends BaseDexClassLoader {
}
```

`PathClassLoader`是Android程序默认的类加载器，它只能加载打包进apk并安装在系统中(/data/app目录)的classes.dex包，而`DexClassLoader`是google为了便于我们扩展而提供的dex加载器，它可以加载任意目录下的.dex的.jar和.apk文件中的类。他们都继承自`BaseDexClassLoader`，父类中维护了一个`DexPathList`类型的对象，`findClass()`方法正是通过它来加载类的。下面我们看看`DexPathList`：

```Java
final class DexPathList {
    //每一个dex文件都被封装成Element，放入该数组中
    private Element[] dexElements;

    public Class<?> findClass(String name, List<Throwable> suppressed) {
        for (Element element : dexElements) {
           //遍历dexElements数组（也就是所有dex包），从dex包中获取class对象，如果dexElements中有多个相同名称的class，则总是加载排在前面的
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
        //...
        return null;
    }
    //内部类
    static class Element {
        //dex路径
        private final File path;
        //真正的dex文件封装，DexFile可以加载dex中单个class文件
        private final DexFile dexFile;
        //真正加载class的方法
        public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
            return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                    : null;
        }
      }
}
```

`DexPathList`中维护了一个`Element`数组，我们知道Android应用将class文件都打包进了一个classes.dex的文件中（分包的情况下有多个.dex文件），而`Element`就是对一个dex文件的封装，它维护了dex文件的路径及文件对象，真正实现类加载的是`DexFile`对象，它最终调用了底层native方法。所以说起来上面两个类加载器仅仅是用来加载dex文件，将其封装成Element并放入一个数组中，真正加载class文件的是`Element`对象中的`dexFile`，`loadClassBinaryName()`方法就相当于自定义ClassLoader中的`defineClass()`方法。

一个应用程序可能有多个dex文件(为了解决65536限制)，它们被加载后都被存放在`dexElements`数组中，如果程序要使用一个class类，则会遍历Element数组，这就使得排在数组前面的dex中的类会被加载到，排在面的就被忽略了。我们可以让`DexClassLoader`帮我们加载补丁dex文件，然后插到`PathClassLoader`的`dexElements`数组前面，这样系统默认类加载器加载类时就会先加载到修复过的class了。其实我们并不是修改了类的加载，只是修改了类加载的目录顺序从而实现修复类覆盖bug类。

## 实现

```Java
public class DexFixUtil {

    /**
     * 加载补丁
     * @param context       上下文
     * @param patchFilesDir 补丁所在目录
     */
    public static void loadFixedDex(Context context, File patchFilesDir) {
        HashSet<File> loadedDex = new HashSet<>();
        File[] listFiles = patchFilesDir.listFiles();
        if(listFiles==null)
            return;
        for (File file : listFiles) {
            if (file.getName().endsWith(".dex")
                    || file.getName().endsWith(".apk")
                    || file.getName().endsWith(".jar")
                    || file.getName().endsWith(".zip")) {
                loadedDex.add(file);
            }
        }
        if(loadedDex.size()>0)
            doDexInject(context, loadedDex);
    }

    @TargetApi(Build.VERSION_CODES.CUPCAKE)
    private static void doDexInject(Context appContext, HashSet<File> loadedDex) {
        //创建补丁包解压目录 data/data/包名/files/optimize_dex
        String optimizeDir = appContext.getFilesDir().getAbsolutePath() +
                File.separator + "optimize_dex";
        File fopt = new File(optimizeDir);
        if (!fopt.exists())
            fopt.mkdirs();
        try {
            // 1. 获取程序默认的ClassLoader
            PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();
            for (File dex : loadedDex) {
                Log.w(DexFixUtil.class.getSimpleName(), "-----------加载补丁包："+dex.getAbsolutePath());
                // 2. 创建一个DexClassLoader对象加载补丁包dex
                DexClassLoader dexLoader = new DexClassLoader(
                        dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                        fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                        null,// 加载dex时需要的库
                        pathLoader// 父类加载器
                );
                // 3. 将补丁dex加载器对象中的Element数组元素插到系统默认加载器的Element数组的前面
                //3.1 获取BaseDexClassLoader中的pathList
                Object pathPathList = getPathList(pathLoader);
                Object dexPathList = getPathList(dexLoader);
                //3.2 获取pathList的dexElements数组
                Object rightDexElements = getDexElements(pathPathList);
                Object leftDexElements = getDexElements(dexPathList);
                //3.3 合并两个dex数组
                Object dexElements = combineArray(leftDexElements, rightDexElements);
                // 重写给PathList里面的Element[] dexElements赋值
                Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错
                setField(pathList, pathList.getClass(), "dexElements", dexElements);
            }
            Log.w(DexFixUtil.class.getSimpleName(), "-----------修复完成");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**反射得到类加载器中的pathList对象*/
    private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        return getField(baseDexClassLoader, Class.forName("dalvik.system.BaseDexClassLoader"), "pathList");
    }
    /**反射得到pathList中的dexElements*/
    private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException {
        return getField(pathList, pathList.getClass(), "dexElements");
    }
    /**反射得到对象中的属性值*/
    private static Object getField(Object obj, Class<?> cl, String field) throws NoSuchFieldException, IllegalAccessException {
        Field localField = cl.getDeclaredField(field);
        localField.setAccessible(true);
        return localField.get(obj);
    }
    /**反射给对象中的属性重新赋值*/
    private static void setField(Object obj, Class<?> cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field declaredField = cl.getDeclaredField(field);
        declaredField.setAccessible(true);
        declaredField.set(obj, value);
    }
    /**数组合并*/
    private static Object combineArray(Object arrayLhs, Object arrayRhs) {
        Class<?> c lazz = arrayLhs.getClass().getComponentType();
        int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组）
        int j = Array.getLength(arrayRhs);// 得到原dex数组长度
        int k = i + j;// 得到总数组长度（补丁数组+原dex数组）
        Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组
        System.arraycopy(arrayLhs, 0, result, 0, i);
        System.arraycopy(arrayRhs, 0, result, i, j);
        return result;
    }
}
```

## 使用

-  调用

在SplashActivity中调用修复代码，然后运行错误代码。这里需要申请存储权限。由于Class对象只会创建一次，所以需要重启应用实现修复。

```Java
PermissionUtil.requestPermission(this, new PermissionCallBack() {
            @Override
            public void onGranted() {
                //sd卡权限通过后执行修复
                File patchPath = new File(Environment.getExternalStorageDirectory(), "patch");
                FixDexUtil.loadFixedDex(MainActivity.this, patchPath);
            }
            @Override
            public void onDenied() {
                finish();
            }
        }, new String[]{Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE});
```

- 得到修复的class文件

修复代码，然后Rebuild Project，在
`\app\build\intermediates\classes\debug\包名\`目录下就可以找到被修复的类的.class文件，将所有修复的类文件从**包名完整**拷贝到一个文件夹下，比如patch文件夹。

- 生成dex

cmd命令行进入sdk/build-tools/version/目录下找到dx.bat，执行命令`dx --dex --output=G:\openXu\openXuHome\workspace\HookFix\patch\patch.dex G:\openXu\openXuHome\workspace\HookFix\patch`，`--output`后面跟着dex输出目标和class文件目录。

- 下载dex

生成的补丁包应该上传到服务器，客户端根据版本判断是否需要下载补丁包，如果需要就下载补丁包到本地sd卡。这里我们省略这个步骤，直接将补丁拷贝到sd卡下某个目录中，比如patch目录，最后重起应用完成修复

# Native Hook(andfix sophix)

https://zhuanlan.zhihu.com/p/75465215
https://blog.csdn.net/itachi85/article/details/79522200


即时修复 不重启APP

https://bthvi-leiqi.blog.csdn.net/article/details/96644721

程序崩溃的根源是程序中某个方法抛出了异常，所以修复的原理就是使用补丁包中的类的方法替换掉抛异常的方法。我们怎样找到这个方法呢？

Java层不能实现方法的替换，那么我们另辟蹊径，通过Native层操控虚拟机内存。方法在虚拟机中叫ArtMethod结构体，它是Native层的。方法表其实就是一个List集合。方法最终是转换为ArtMethod结构体被执行。一个方法被压栈多次这个方法就是递归调用。

我们实现修复，也就是之前说的替换虚拟机中内存中的方法表里的方法，那么怎么替换呢？一个APK中有成千上万个方法，就某一个有异常，我们怎么区分呢？那就是用注解来区分。

- 首先我们要拿到对应的已经修复的dex文件，项目中我们肯定是从网络和获取，这里我们之还是定义在本地文件夹下。
- 其次我们加载这个Dex文件，拿到它的所有的类，遍历类中的方法，根据注解得到哪些方法时候需要修复的。
- 再根据注解中的类名方法名通过反射得到已经加载的有bug的方法。
- 调用Native方法替换有bug的方法。


[NDK使用入门](https://developer.android.google.cn/ndk/guides/index.html)

# 3. InstantRun

目前市面上很多资源热修复方案基本上都是参考Android Studio2.0推出的Instant Run的实现。实际上Instant Run的推出正是热修复浪潮的主要原因，各热修复方案在代码、资源等方面的实现很大程度上参考了Instant Run的代码，这里也简单的介绍一下它。

Instant Run的目的是减少再次运行项目时构建和部署的时间，其原理是只构建修改的部分，将修改的dex和资源推到手机，然后判断是需要热部署、温部署还是冷部署。具体实现要点如下：

- 第一次编译使用asm(字节码操纵框架)在每个类中添加change字段，在每个方法前添加逻辑；将源代码编译的dex压缩进instant-run.zip中；替换清单文件中注册的application为`BootstrapApplication`，使其作为宿主程序；
- `BootstrapApplication.attachBaseContext()`中获取资源路径、设置类加载器、代理调用真实的Application
- 在`PathClassLoader`和`BootClassLoader`中间插入一级`IncrementalClassLoader`，由于类加载器的双亲委托机制，使得`IncrementalClassLoader`成为真是项目的类加载器去加载`instant-run.zip`中的dex；
- 通过反射创建真实的`realApplication`并调用其`attachBaseContext()`方法；
- `BootstrapApplication.onCreate()`中首先替换所有当前app的application为realApplication，然后替换所有当前app的mAssets为newAssetManager，最后启动一个Server通过Socket接受工程修改内容，通过判断修改的内容决定使用哪一种部署方式

AS3.5推出了Apply Changes代替了Instant Run，它是通过利用Android8.0(API26)或更高版本中支持的Android JVMTI技术实现的，详细介绍请看[Apply Changes](https://developer.android.google.cn/studio/run/index.html?authuser=19#apply-changes)，如果后面有机会再进行研究。现在还是回到正题，实现资源热修复之前，我们应该搞清楚资源文件是怎么被打包到apk中的，以及Resource是怎样根据资源ID找到对应的资源的。


[class插桩](https://blog.csdn.net/xx326664162/article/details/95993522?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-95993522.nonecase&utm_term=android%20%E5%A2%9E%E5%8A%A0%E6%97%A5%E5%BF%97%20%E6%8F%92%E6%A1%A9)

http://w4lle.com/2017/03/31/robust-0/index.html
https://blog.csdn.net/maiduoudo/article/details/53783016

代码插桩的实现方式在实现起来相对麻烦一点，主要分为4个步骤：

- 打出apk安装包，该过程会通过自定义gradle插件为每个类添加一个静态成员变量，在每个方法第一行添加补丁代理逻辑
- 修复代码
- 打补丁包，robust在这个过程定义了gradle插件，自动帮我们生成补丁包类文件
- 将补丁包推到手机，让应用加载补丁包完成修复

## robust原理

robust的接入请参考[robust文档](https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md)，感兴趣的同学可以按照步骤体验一下。

下面是我们的待修复的类：

```Java
public class RobustActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        //需要修复的地方
       ((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
    }
}
```

robust在打安装包apk时通过自定义的gradle插件为我们的代码插桩，通过dex2jar反编译查看内容如下，关于插件内容可参考robust源码中的`gradle-plugin`：

```Java
public class RobustActivity extends Activity {
    //插入静态成员变量，这个变量就是RobustActivity对应补丁类的对象
    public static ChangeQuickRedirect changeQuickRedirect;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //在每个方法前插入代理逻辑，如果changeQuickRedirect不为空则执行它的方法，从而跳过了错误的方法体
        if(changeQuickRedirect != null) {
            if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) {
                PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false);
                return;
            }
        }
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
       ((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
    }
}
```

打补丁包之前，我们需要按照下面的方式修复代码：

```Java

public class RobustActivity extends Activity {
    @Modify   //修改方法
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        //((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
        settext();
    }
    @Add   //新增方法
    private void settext() {
       ((TextView) findViewById(R.id.tv_result)).setText("我是修复页面");
    }
}
````

执行补丁包命令打出补丁包patch.jar，这个过程是由`auto-patch-plugin`插件完成的，核心流程使用Gradle Tranform在编译打包从.class到.dex的过程中去修改或生成.class文件（上面插桩也是一样），首先读取被`@Add`，`@Modify`标记的类或方法，然后根据一些信息生成补丁class文件打成jar包，编译成dex，反编译为smali，修改smali文件以处理super方法和混淆，最后重新打包为dex。这个过程涉及的内容还是挺多的，不过思路还是很清晰，如果感兴趣可参考[Robust自动化补丁原理解析](http://w4lle.com/2018/05/28/robust-1/)这篇文章。

下面我们根据robust原理，手动实现一个简单的补丁修复。

## 手动实现

**相关类准备（模拟robust的sdk）**

```Java

/**
 * 补丁类接口，每个需要修复的类需要生成一个对应的补丁类，补丁类需要实现该接口
 */
public interface ChangeQuickRedirect {
    Object accessDispatch(Object obj, String methodName, Object[] paramArrayOfObject);
    boolean isSupport(String methodName, Object[] paramArrayOfObject);
}

/**
 * Author: openXu
 * Time: 2020/9/14 14:57
 * class: PatchExecutor
 * Description: 修复工具，为每个被修复类的静态成员变量changeQuickRedirect初始化对应补丁类对象
 */
public class PatchExecutor {

    /**
     * 加载补丁类，为修复类初始化补丁对象
     * @param context
     * @param patchFile
     */
    public static void patch(Context context, File patchFile){
        try {
            String optimizeDir = context.getFilesDir().getAbsolutePath() +
                    File.separator + "optimize_dex";
            File fopt = new File(optimizeDir);
            if (!fopt.exists())
                fopt.mkdirs();
            //创建一个dex类加载器，加载指定的补丁包
            DexClassLoader dexLoader = new DexClassLoader(
                    patchFile.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                    fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                    null,// 加载dex时需要的库
                    PatchExecutor.class.getClassLoader() );// 父类加载器
            //通过类加载器加载补丁包中的补丁类对应信息
            Class patchInfoClass = dexLoader.loadClass("com.openxu.fix.robust.RobustPatchInfo");
            RobustPatchInfo patchInfo = (RobustPatchInfo)patchInfoClass.newInstance();
            //得到被<修复类, 补丁类>的map
            Map<String, String> map = patchInfo.getPatchedClassesInfo();
            //遍历map，为所有被修复类创建一个补丁类对象，并赋值给静态成员变量
            Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
            while (iterator.hasNext()){
                Map.Entry<String, String> entry = iterator.next();
                ChangeQuickRedirect redirect = (ChangeQuickRedirect)dexLoader.loadClass(entry.getValue()).newInstance();
                Log.w("PatchExecutor", "创建补丁静态成员变量："+redirect);
                Class fixClass = dexLoader.loadClass(entry.getKey());
                Log.w("PatchExecutor", "获得待修复类类型："+fixClass);
                Field field = fixClass.getDeclaredField("changeQuickRedirect");
                field.set(null, redirect);
                Log.w("PatchExecutor", "为待修复类设置静态变量："+RobustActivity.changeQuickRedirect);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**修复框架接入(robust接入)**

```Java
/**实现修复功能*/
findViewById(R.id.btn_robustfix).setOnClickListener(v->{
        PermissionUtil.requestPermission(this, new PermissionCallBack() {
            @Override
            public void onGranted() {
               // new PatchExecutor(getApplicationContext(), new PatchManipulateImp(), new RobustCallBackSample()).start();
                //sd卡权限通过后执行修复
                File patchPath = new File(Environment.getExternalStorageDirectory(), "robust");
                File patchFile = new File(patchPath.getAbsolutePath(), "patch.dex");
                PatchExecutor.patch(MainActivity.this, patchFile);
            }
            @Override
            public void onDenied() {
                finish();
            }
        }, new String[]{Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE});
    });
findViewById(R.id.btn_robust).setOnClickListener(v->{
    //点击按钮跳转到被修复页面查看修复结果
    startActivity(new Intent(MainActivity.this, RobustActivity.class));
});

/**
 * 被修复类，需要就该onCreate()方法
 */
public class RobustActivity extends Activity {

    /**
     * 为每个类手动添加一个静态成员变量，以及下面每个方法中添加代理逻辑
     * robust这个过程是打包过程中通过gradle插件操作class文件自动插入的
     * 这里我们手动实现
     */
    public static ChangeQuickRedirect changeQuickRedirect;

//    @Modify
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        /**插入代理逻辑*/
        if(changeQuickRedirect != null) {
            //PatchProxy中封装了获取当前className和methodName的逻辑，并在其内部最终调用了changeQuickRedirect的对应函数
            if(changeQuickRedirect.isSupport("onCreate", new Object[]{savedInstanceState})) {
                changeQuickRedirect.accessDispatch(this,
                        "onCreate", new Object[]{savedInstanceState});
                return;
            }
        }
        //下面为原始方法体
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
       ((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
//       settext();
    }

//   @Add
//   private void settext() {
//        ((TextView) findViewById(R.id.tv_result)).setText("我是修复页面");
//    }

}
```

**打补丁包**

robust是通过gradle插件分析代码中的注解自动生成补丁class文件，然后打成补丁包，这里我们手动创建这些类，并通过原始命令打补丁包

```Java
/**
 * 注册需要修复的类和补丁类的对应关系
 */
public class RobustPatchInfo {
    public Map<String, String> getPatchedClassesInfo() {
        Map<String, String> map = new HashMap<>();
        map.put("com.openxu.fix.robust.RobustActivity", "com.openxu.fix.robust.RobustActivityPatch");
        return map;
    }
}


/**
 * SecondActivity的真正补丁类
 */
public class RobustActivityPatch implements ChangeQuickRedirect {

    @Override
    public boolean isSupport(String methodName, Object[] paramArrayOfObject) {
        Log.w("RobustActivityPatch", "判断方法是否需要热修复："+methodName+"  "+paramArrayOfObject[0]);
        if(methodName.equals("onCreate") && paramArrayOfObject!=null
                &&paramArrayOfObject.length==1&&(paramArrayOfObject[0]==null||
                paramArrayOfObject[0].getClass()==Bundle.class)){
            return true;
        }
        return false;
    }

    @Override
    public Object accessDispatch(Object obj, String methodName, Object[] paramArrayOfObject) {
        if(methodName.equals("onCreate") && paramArrayOfObject!=null
                &&paramArrayOfObject.length==1&&(paramArrayOfObject[0]==null||
                paramArrayOfObject[0].getClass()==Bundle.class)){
            //如果需要修复的方法是onCreate()方法，则调用补丁类的onCreate()
            onCreate((RobustActivity)obj, (Bundle)paramArrayOfObject[0]);
        }
        return null;
    }

    //重写需要修改的onCreate方法内容
    protected void onCreate(RobustActivity realObj, Bundle paramBundle) {
        Log.w(getClass().getSimpleName(), "调用补丁类的onCreate方法");
        //★调用super.onCreate()，需要通过修改smali文件实现
        realObj.onCreate(paramBundle);
        //调用setContentView()
        realObj.setContentView(R.layout.activity_second);
        //调用新增方法
        settext(realObj);
    }
    private void settext(RobustActivity realObj) {
        ((TextView) realObj.findViewById(R.id.tv_result)).setText("我是修复页面");
    }
}
```

上面主要创建了两个类，一个类为对应的补丁类，另一个类为他们的对应关系注册类，在补丁类中，主要实现了`isSupport()`方法和`accessDispatch()`方法，他们分别对应被修复类中调用的两个方法，然后我们需要在补丁类中重写需要修复的方法。

在补丁类中实现修复方法时有很多细节问题需要注意，因为原始方法在被修复类中，方法中使用的this、super等都需要被翻译为正确的代码，比如`onCreate()`第一句调用了`super.onCreate()`，而在补丁类中我们没办法调用被补丁类的super方法，所以有一个细节就是通过修改编译后的smali文件，.dex里记录的是Dalvik实现的虚拟机指令，而smali代码其实是Dalvik的汇编语言，smali其实可以看作是java文件，直接用文本编辑器打开即可修改，关于smali语法可以上网搜一下，比如[Smali简介和实现类外调用父类方法](https://blog.csdn.net/xingzhong128/article/details/80916069)。下面我们打补丁包：

```xml

## 1. 编译资源

使用aapt2的compile命令传递一个资源文件作为输入，会解析该文件并生成一个扩展名为.flat的中间二进制文件放入指定目录。可以使用--dir参数标记多个资源文件的资源目录。

```xml
//进入项目根目录下，在app下创建robust目录，该目录下存放所有中转文件

//创建all.txt文件，记录所有需要编译的java源文件路径
G:\openXu\openXuHome\workspace\HookFix\app\robust\java\com\openxu\fix\robust\ChangeQuickRedirect.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\java\com\openxu\fix\robust\PatchExecutor.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\java\com\openxu\fix\robust\RobustActivity.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\java\com\openxu\fix\robust\RobustActivityPatch.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\java\com\openxu\fix\robust\RobustPatchInfo.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\java\com\openxu\fix\robust\RobustPatchInfoImpl.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\java\com\openxu\fix\R.java

//编译java文件为class文件(我们真正需要的只有补丁类、补丁注册信息类，但是为了编译不报错，需要将相关引用类一起编译)
> javac  -encoding utf-8 -target 1.8 -bootclasspath F:\IDE\sdk\platforms\android-29\android.jar -d app\robust @app\robust\all.txt

> javac  -encoding utf-8 -target 1.8 -bootclasspath /Users/openXu/Library/Android/sdk/platforms/android-28/android.jar -d app/robust  @app/robust/all.txt

//编译class文件为dex
> d8 app\robust\com\openxu\fix\robust\*.class --output app\robust

>d8 app/robust/com/openxu/fix/robust/*.class --output app/robust

//将得到的classes.dex反编译为.smali
//需要用到两个jar包，去https://bitbucket.org/JesusFreke/smali/downloads/下载
> cd app
> cd robust
> java -jar baksmali-2.4.0.jar d classes.dex

//修改RobustActivityPatchAssist.smali中对应onCreate方法中的内容
 invoke-virtual {p0, p2}, Lcom/openxu/fix/robust/RobustActivityPatch;->onCreate(Landroid/os/Bundle;)V

修改为
invoke-super {p1, p2}, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V

//编译修改后的smali为dex，输出为classes.dex
> java -jar smali-2.4.0.jar a out -o classes.dex



//将得到的classes.dex（即补丁包）推送到手机sd卡
adb push G:\openXu\openXuHome\workspace\HookFix\app\robust\classes.dex \sdcard\classes.dex

adb push classes.dex /sdcard/classes.dex

```





相关类准备：


- 打出补丁包patch.jar

- 将patch.jar后缀改为.zip，解压得到classes.dex，然后使用dex2jar将dex反编译为jar，最后使用jd-gui打开jar文件查看反编译源码

```xml 
//mac dex反编译为jar
sh d2j-dex2jar.sh classes.dex

```


怎样调用在补丁类中调用原始类的super方法？


Smali语言其实就是Davlik的寄存器语言；Smali语言就是android的应用程序.apk通过apktool反编译出来的都有一个smali文件夹，里面都是以.smali结尾的文件，文件的展示语言。



```xml


```




./gradlew clean  assembleRelease --stacktrace --no-daemon

adb push ~/Desktop/code/robust/app/build/outputs/robust/patch.jar /sdcard/robust/patch.jar


https://blog.csdn.net/xingzhong128/article/details/80916069





# 4. 主流热修复框架对比



三种代码修复方式优缺点：

**dex类加载方案**

优点：实现简单，不需要太多适配
缺点：
- 因为补丁加载之前已经load的类不能重新加载，需要重启应用生效
- class校验问题(https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a)

**instantrun**
优点：

使用 java 实现，开发方便
兼容性好
补丁实时生效
缺点：

代码是侵入比较高，需要在原有代码中新增逻辑，而且需要对方法进行插桩，将这里逻辑自动化处理
增大包体积
七、资源热修复方案

native hook
Andfix
dex 插桩
Qzone
Nuwa
InstantRun Robust
Aceso
全量替换 dex
Tinker
混合方案
Sophix


























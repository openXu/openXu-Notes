
[数据结构一 (简介)](https://blog.csdn.net/xmxkf/article/details/81019110)

[数据结构一线性表 (顺序表、单链表、双链表)](https://blog.csdn.net/xmxkf/article/details/81084010)

[数据结构 -- 栈和队列的实现及应用](https://blog.csdn.net/xmxkf/article/details/82465726)

https://blog.csdn.net/sinat_33921105/article/details/103295070

[力扣，算法](https://leetcode.com/)
[算法可视化](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
[算法分析网站](https://www.bigocheatsheet.com/)

常见的数据结构有：数组、链表、栈、队列、哈希表、数、图

# 哈希表

哈希表又叫散列表，内部使用数组来实现的，哈希函数/散列函数的作用是根据key计算得到一个散列值，这个值就是将数据保存在数组中的索引index。数组中存储的是Entry健值对，当数组剩余的空位不太足就会出发数组扩容。

**哈希函数/散列函数**：用于根据key计算出一个值，作为数组存储索引index。既然内部使用数组实现，数组总会有被填满的时候，这时候就需要扩容

**扩容**：扩容不是简单的把数组扩大，而是新创建一个数组是原来的2倍，然后把原数组的所有Entry都重新Hash（hash函数也会变化）一遍放到新的数组对应位置

**负载因子**：哈希表中数组已经被占用位置与总位置的一个百分比，如果是0.75，则表示如果已占用75%的位置则会触发扩容机制。之所以存在负载因子，有一个重要原因就是数组被占用位置比较多后出现哈希冲突的概率也就变高了

**哈希冲突/哈希碰撞**：哈希函数是通过一个特殊的算法根据key计算得到一个整数，由于整数数量有限，肯定有不同的key计算得到的index是一样的，这就叫哈希冲突，当出现哈希冲突，则表示数组对应位置已经存储了entry，新的entry就没地方存储了。一般有**开放寻址法**和**拉链法**解决哈希冲突，其实就是找一个新的位置存储数据

**开放寻址法**：当对应index已经被占用，则看下一个位置index+1是否还空着，如果空着就放这里，如果也被占用就继续index+2，直到找到一个空位置存储（一定会找到，因为占用位置达到负载因子就会触发扩容，数组总会有空位）。ThreadLocal就是使用的这种方法。

**拉链法**：HashMap使用拉链法解决哈希冲突，index位置被entry1占用了，那就将新的数据entry2保存在数组外另一个位置，然后entry1中有一个next指针指向entry2的地址，下次来了entry3就让entry2的next指向entry3，形成一个单链表。HashMap的查询、插入、删除效率是很高的，因为直接根据key能得到数据储存在数组中的index，但是这里由于哈希冲突引来了单链表，这对查询性能是有影响的，因为找到index后还需遍历单链表，所以不能使单链表太长。Java中HashMap链表长度大于等于8就会换成树结构（红黑树），如果长度小于等于6则换回单链表，以此解决性能问题。为什么中间隔着7？避免频繁的进行树和链表的转换。

**哈希表查询数据**：哈希函数根据key获得数据在数组中的索引，然后比较该位置存储的entry.key和参数key是否相等，如果相等则返回entry.value，如果不相等就是哈希冲突导致的，这时候就要分情况。如果使用开放寻址则一直往后找，找到就返回；如果使用拉链法，则遍历对应位置的单链表

**哈希表的核心**：核心就是哈希函数，一个好的哈希函数会减少哈希冲突的概率，从而提高哈希表相关算法的效率。常用的方法有直接定址法、数字分析法、折叠法、随机数法、除留余数法等

**Java中的哈希表**

# 树结构

树结构跟线性结构最大的区别就是存在一对多的关系，常见的数结构

https://blog.csdn.net/sinat_33921105/article/details/105062230

## AVL树（平衡二叉树）
https://blog.csdn.net/qq_25343557/article/details/89110319
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树.某结点的左子树与右子树的高度(深度)差即为该结点的平衡因子（BF,Balance Factor）。平衡二叉树上所有结点的平衡因子只可能是 -1，0 或 1。如果某一结点的平衡因子绝对值大于1则说明此树不是平衡二叉树。为了方便计算每一结点的平衡因子我们可以为每个节点赋予height这一属性，表示此节点的高度。

















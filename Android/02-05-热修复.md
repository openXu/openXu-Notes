
热修复技术在当前Android开发中使用非常广泛，市面上关于热修复的框架非常多，其中很多都是大厂开源的。我们可以根据自己的需求挑选一个合适自己的框架使用，在使用之前我们应该简单的了解一下其实现原理才能更好的选择。

# 1. 类修复

应用程序上线时难免会有一些方法抛出异常但没有测试出来，导致上线后大面积崩溃，这时候我们应该打一个补丁包让用户无感知下载实现修复，而不是告诉用户为了修复这个bug要升级重新安装。怎样修复类及方法层面的bug，有下面两种实现方式。

## 1.1 Java Hook(Tinker robust)

### 原理

JVM虚拟机在运行一个Class文件时首先要通过`ClassLoader`将类文件加载进内存，Android中也不例外，它提供了`PathClassLoader`和`DexClassLoader`两个类加载器，我们可以通过[Android社区](https://www.androidos.net.cn/sourcecode)在线查看源码。下面我们简单看下这几个类的描述

```Java
#### libcore/dalvik/src/main/java/dalvik/system

/**用于加载dex包的class文件的ClassLoader实现*/
public class BaseDexClassLoader extends ClassLoader {
	private final DexPathList pathList; //dex文件集合
  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
      //调用DexPathList的findClass方法来获取dex包中的class文件
      Class c = pathList.findClass(name, suppressedExceptions);
      //...
      return c;
  }
}
/**Android将这个类用于其系统类加载器和应用程序类加载器*/
public class PathClassLoader extends BaseDexClassLoader {
}
/**
  * 一个类装入器，从包含classes.dex的.jar、.zip、.apk文件中加载类
  * 可用于执行未作为应用程序一部分安装的代码
  * 注意的是需要为构造方法指定一个data/data/包名/files/optimize_dex解压路径（保护应用程序免受代码注入攻击）
  */
public class DexClassLoader extends BaseDexClassLoader {
}

```

`PathClassLoader`是Android程序默认的类加载器，它只能加载打包进apk并安装在系统中(/data/app目录)的classes.dex包，而`DexClassLoader`是google为了便于我们扩展而提供的dex加载器，它可以加载任意目录下的.dex的.jar和.apk文件中的类。真正实现类加载功能的是其父类`BaseDexClassLoader`，它的`DexPathList`类型的成员变量维护了一个`Element`数组，而`Element`就是对dex文件的封装。下面我们看看`DexPathList`

```Java
final class DexPathList {
    //每一个dex文件都被封装成Element，放入该数组中
    private Element[] dexElements;

    public Class<?> findClass(String name, List<Throwable> suppressed) {
        for (Element element : dexElements) {
           //遍历dexElements数组（也就是所有dex包），从dex包中获取class对象，如果dexElements中有多个相同名称的class，则总是加载排在前面的
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
        //...
        return null;
    }
    //内部类
    static class Element {
        //dex路径
        private final File path;
        //真正的dex文件封装，DexFile可以加载dex中单个class文件
        private final DexFile dexFile;
        //真正加载class的方法
        public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
            return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                    : null;
        }
      }
}
```

一个应用程序可能有多个dex文件，它们被加载后都被存放在`dexElements`数组中，如果程序要使用一个class类，则会遍历Element数组，这就使得排在数组前面的dex中的类会被加载到，排在面的就被忽略了。我们可以让`DexClassLoader`帮我们加载补丁dex文件，然后插到`PathClassLoader`的`dexElements`数组前面，这样系统默认类加载器加载类时就会先加载到修复过的class了。


### 实现

```Java
public class FixDexUtil {
    private static final String DEX_SUFFIX = ".dex";
    private static final String APK_SUFFIX = ".apk";
    private static final String JAR_SUFFIX = ".jar";
    private static final String ZIP_SUFFIX = ".zip";
    public static final String DEX_DIR = "odex";
    private static final String OPTIMIZE_DEX_DIR = "optimize_dex";
    private static HashSet<File> loadedDex = new HashSet<>();

    static {
        loadedDex.clear();
    }

    /**加载补丁，使用默认目录：data/data/包名/files/odex*/
    public static void loadFixedDex(Context context) {
        loadFixedDex(context, null);
    }

    /**
     * 加载补丁
     * @param context       上下文
     * @param patchFilesDir 补丁所在目录
     */
    public static void loadFixedDex(Context context, File patchFilesDir) {
        // 遍历所有的修复dex , 因为可能是多个dex修复包
        File fileDir = patchFilesDir != null ? patchFilesDir:
                new File(context.getFilesDir(), DEX_DIR);//默认目录 data/data/包名/files/odex
        File[] listFiles = fileDir.listFiles();
        if (listFiles != null){
            for (File file : listFiles) {
                if (file.getName().startsWith("classes") &&
                        (file.getName().endsWith(DEX_SUFFIX)
                                || file.getName().endsWith(APK_SUFFIX)
                                || file.getName().endsWith(JAR_SUFFIX)
                                || file.getName().endsWith(ZIP_SUFFIX))) {

                    loadedDex.add(file);
                }
            }
        }
        if(loadedDex.size()>0)
            doDexInject(context, loadedDex);
    }

    @TargetApi(Build.VERSION_CODES.CUPCAKE)
    private static void doDexInject(Context appContext, HashSet<File> loadedDex) {
        //创建补丁包解压目录 data/data/包名/files/optimize_dex
        String optimizeDir = appContext.getFilesDir().getAbsolutePath() +
                File.separator + OPTIMIZE_DEX_DIR;
        File fopt = new File(optimizeDir);
        if (!fopt.exists())
            fopt.mkdirs();
        try {
            // 1. 获取程序默认的ClassLoader
            PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();
            for (File dex : loadedDex) {
                // 2. 创建一个DexClassLoader对象加载补丁包dex
                DexClassLoader dexLoader = new DexClassLoader(
                        dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                        fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                        null,// 加载dex时需要的库
                        pathLoader// 父类加载器
                );
                // 3. 将补丁dex加载器对象中的Element数组元素插到系统默认加载器的Element数组的前面
                //3.1 获取pathList
                Object pathPathList = getPathList(pathLoader);
                Object dexPathList = getPathList(dexLoader);
                //3.2 获取pathList的element数组
                Object rightDexElements = getDexElements(pathPathList);
                Object leftDexElements = getDexElements(dexPathList);
                //3.3 合并两个dex数组
                Object dexElements = combineArray(leftDexElements, rightDexElements);
                // 重写给PathList里面的Element[] dexElements赋值
                Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错
                setField(pathList, pathList.getClass(), "dexElements", dexElements);
            }
            Toast.makeText(appContext, "修复完成", Toast.LENGTH_SHORT).show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**反射得到类加载器中的pathList对象*/
    private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        return getField(baseDexClassLoader, Class.forName("dalvik.system.BaseDexClassLoader"), "pathList");
    }
    /**反射得到pathList中的dexElements*/
    private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException {
        return getField(pathList, pathList.getClass(), "dexElements");
    }
    /**反射得到对象中的属性值*/
    private static Object getField(Object obj, Class<?> cl, String field) throws NoSuchFieldException, IllegalAccessException {
        Field localField = cl.getDeclaredField(field);
        localField.setAccessible(true);
        return localField.get(obj);
    }
    /**反射给对象中的属性重新赋值*/
    private static void setField(Object obj, Class<?> cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field declaredField = cl.getDeclaredField(field);
        declaredField.setAccessible(true);
        declaredField.set(obj, value);
    }
    /**数组合并*/
    private static Object combineArray(Object arrayLhs, Object arrayRhs) {
        Class<?> clazz = arrayLhs.getClass().getComponentType();
        int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组）
        int j = Array.getLength(arrayRhs);// 得到原dex数组长度
        int k = i + j;// 得到总数组长度（补丁数组+原dex数组）
        Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组
        System.arraycopy(arrayLhs, 0, result, 0, i);
        System.arraycopy(arrayRhs, 0, result, i, j);
        return result;
    }
}
```

### 使用

上面的修复工具仅仅实现了修复逻辑，但是怎样打补丁包(sdk/build-tools/version/bx.bat程序执行`dx --dex --output=...\classes2.dex(dex包输出目录) xxx\dex(class文件所在目录)`)，以及服务器怎样管理补丁包版本，客户端下载补丁包到本地目录，这些工作还需要自己实现，这就是为什么大厂提供了框架，还有一个原因就是不同厂商和android版本的兼容问题。下面我们假设已经从服务器下载了补丁包到本地目录，工具使用如下：

```Java
//SplashActivity中调用，完成修复，由于类只加载一次，所以需要重起应用完成修复
FixDexUtil.loadFixedDex(this, new File(补丁包下载目录));
```

# Native Hook(andfix sophix)

即时修复 不重启APP

https://bthvi-leiqi.blog.csdn.net/article/details/96644721

程序崩溃的根源是程序中某个方法抛出了异常，所以修复的原理就是使用补丁包中的类的方法替换掉抛异常的方法。我们怎样找到这个方法呢？

Java层不能实现方法的替换，那么我们另辟蹊径，通过Native层操控虚拟机内存。方法在虚拟机中叫ArtMethod结构体，它是Native层的。方法表其实就是一个List集合。方法最终是转换为ArtMethod结构体被执行。一个方法被压栈多次这个方法就是递归调用。

我们实现修复，也就是之前说的替换虚拟机中内存中的方法表里的方法，那么怎么替换呢？一个APK中有成千上万个方法，就某一个有异常，我们怎么区分呢？那就是用注解来区分。

- 首先我们要拿到对应的已经修复的dex文件，项目中我们肯定是从网络和获取，这里我们之还是定义在本地文件夹下。
- 其次我们加载这个Dex文件，拿到它的所有的类，遍历类中的方法，根据注解得到哪些方法时候需要修复的。
- 再根据注解中的类名方法名通过反射得到已经加载的有bug的方法。
- 调用Native方法替换有bug的方法。


[NDK使用入门](https://developer.android.google.cn/ndk/guides/index.html)



























# 资源修复


关于资源的修复方案，没有像代码修复一样方法繁多，基本上集中在对 AssetManager 的修改上

7.1 替换 AssetManager
这个是 InstantRun 采用的方案，就是构造一个新的 AssetManager，反射调用其 addAssetPath 函数，把新的补丁资源包添加到 AssetManager 中，从而得到含有完整补丁资源的 AssetManager，然后找到所有引用 AssetManager 的地方，通过反射将其替换为新的 AssetManager。

7.2 添加修改的资源到 AssetManager 中，并重新初始化
这个是 Sophix 采用的方案，原理是构造一个 package id 为 0x66 的资源包，只含有改变的资源，将其直接添加到原有的 AssetManager 中，这样不会与原来的 package id 0x7f 冲突。然后将原来的 AssetManager 重新进行初始化即可，就不需要进行繁琐的反射替换操作了。


## 资源打包

在sdk/build.tools目录下有一个aapt.exe工具，它的作用就是在打包apk的过程中帮我们处理资源文件(res、assets、manifest)并打进一个名为`resources.ap_`的压缩包，可在build/intermediates/res路径下找到它，将其解压，可以得到res文件夹、assets文件夹、AndroidManifest.xml、resources.arsc。

resources.arsc是一张资源索引表，代码中使用R.xx.xx都会通过arsc索引表找对应的资源，可使用`AssetManager.addAssetPath()`加载它。

https://github.com/Tencent/tinker

https://blog.csdn.net/l2show/article/details/53454933

记一次苦逼的资源逆向分析 http://zjutkz.net/2016/05/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8B%A6%E9%80%BC%E7%9A%84%E8%B5%84%E6%BA%90%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/


https://my.oschina.net/bugly/blog/727850


https://blog.csdn.net/luoshengyang/article/details/8791064



单纯更新 Java 代码的 patch 框架，实用性会受到很大的局限。开发同学需要仔细验证提交内容，确保提交中不包含资源文件的变更以及 native so 的改动，会导致本就复杂的开发流程变得更加繁琐。所以我们在支持更新 Java 代码的基础之上，也支持更新资源和 native so 文件。

App 加载资源是依赖 Context#getResources 函数返回的 Resources 对象。Resources 内部包装了 AssetManager，最终由 AssetManager 从 apk 文件中加载资源。所以我们反射了替换系统默认的 Resources，让 AssetManager 从我们更新后的 apk 中加载资源。现阶段的实现支持比如 string/anim/drawable/color/layout 等资源文件的变更。由于 Android 系统在安装 apk 时候已经把 AndroidManifest.xml 文件解析并写入到系统中，目前还不支持修改四大组件，比如增加 Activity。后续会继续研究如何做到无缝修改四大组件。

# 怎么更新 so 文件？

在 Android 项目中使用 native 函数前需要先调用 System.loadLibrary(libName)。

当 lib 文件需要更新或者有 bug 时候怎么办？首先想到的是在代码中把加载 so 文件的代码改成System.load(libFilePath)，让系统加载自己指定的 libFilePath 文件。然而这样的改动需要

在源代码中修改或者使用工具在编译期把 loadLibrary 接口改为 load
patch 库把 so 文件从 patch 文件中复制到特定目录
这样在运行期才有可能加载更新后的 so 文件。

通过分析系统加载 so 文件的方式后，我们使用了更简单的处理方法。查找 lib 文件是通过调用 PathClassLoader 的 findLibrary，最终调用到 DexPathList 的 findLibrary。DexPathList 会在自己维护的列表目录中查找对应的 lib 文件是否存在。所以我们在发现 patch 文件中有 so 文件变更的时候，会在 PathClassLoader 的 nativeLibraryDirectories（Android6.0以下）或者nativeLibraryPathElements （Android 6.0及以上）的最前面插入自定义的lib文件目录。这样 ClassLoader 在 findLibrary 的时候会先在自定义的 lib 目录中查找，优先加载变更过的 so 文件。




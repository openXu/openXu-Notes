# 1. 类加载方案

## 原理

JVM虚拟机要运行一个Class时首先需要将class文件加载到内存中，这个过程包含加载、链接(验证、准备、解析)、初始化，在Java中，这些工作都是由`ClassLoader`完成的。通过下面自定义ClassLoader我们能大概明白这是一个什么过程：

```Java
public class MyClassLoader extends ClassLoader {
    //class文件所在路径
    private String path;
    public MyClassLoader(String path) {
        this.path = path;
    }
    //自定义ClassLoader只需要重写findClass()方法
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            //1. 通过流将class文件转化为流
            name = path + name + ".class";
            InputStream is = null;
            ByteArrayOutputStream outputStream = null;
            try {
                is = new FileInputStream(new File(name));
                outputStream = new ByteArrayOutputStream();
                int i = 0;
                while ((i = is.read()) != -1)
                    outputStream.write(i);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (outputStream != null)
                    outputStream.close();
                if (is != null)
                    is.close();
            }
            //2. 得到class文件的字节数组
            byte[] b = outputStream.toByteArray();
            //3. 调用definClass方法将字节数组转换为class的实例，这个方法会完成加载、链接(验证、准备、解析)、初始化的操作
            return defineClass(name, b, 0, b.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

Android中也不例外，它提供了`PathClassLoader`和`DexClassLoader`两个类加载器，我们可以通过[Android社区](https://www.androidos.net.cn/sourcecode)在线查看源码，这两个加载器是专门用于加载Android平台特定的dex格式类文件的，dex可以看作是很多class文件的一个压缩包，而通过上面两个类加载器可以从压缩包中加载出单个的class。下面我们简单看下这几个类的描述

```Java
#### libcore/dalvik/src/main/java/dalvik/system

/**用于加载dex包的class文件的ClassLoader实现*/
public class BaseDexClassLoader extends ClassLoader {
  private final DexPathList pathList; //dex文件集合
  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
      //调用DexPathList的findClass方法来获取dex包中的class文件
      Class c = pathList.findClass(name, suppressedExceptions);
      //...
      return c;
  }
}
/**Android将这个类用于其系统类加载器和应用程序类加载器*/
public class PathClassLoader extends BaseDexClassLoader {
}
/**
  * 一个类装入器，从包含classes.dex的.jar、.zip、.apk文件中加载类
  * 可用于执行未作为应用程序一部分安装的代码
  * 注意：需要为构造方法指定一个data/data/包名/files/optimize_dex解压路径（保护应用程序免受代码注入攻击）
  */
public class DexClassLoader extends BaseDexClassLoader {
}
```

`PathClassLoader`是Android程序默认的类加载器，它只能加载打包进apk并安装在系统中(/data/app目录)的classes.dex包，而`DexClassLoader`是google为了便于我们扩展而提供的dex加载器，它可以加载任意目录下的.dex的.jar和.apk文件中的类。他们都继承自`BaseDexClassLoader`，父类中维护了一个`DexPathList`类型的对象，`findClass()`方法正是通过它来加载类的。下面我们看看`DexPathList`：

```Java
final class DexPathList {
    //每一个dex文件都被封装成Element，放入该数组中
    private Element[] dexElements;

    public Class<?> findClass(String name, List<Throwable> suppressed) {
        for (Element element : dexElements) {
           //遍历dexElements数组（也就是所有dex包），从dex包中获取class对象，如果dexElements中有多个相同名称的class，则总是加载排在前面的
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
        //...
        return null;
    }
    //内部类
    static class Element {
        //dex路径
        private final File path;
        //真正的dex文件封装，DexFile可以加载dex中单个class文件
        private final DexFile dexFile;
        //真正加载class的方法
        public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
            return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                    : null;
        }
      }
}
```

`DexPathList`中维护了一个`Element`数组，我们知道Android应用将class文件都打包进了一个classes.dex的文件中（分包的情况下有多个.dex文件），而`Element`就是对一个dex文件的封装，它维护了dex文件的路径及文件对象，真正实现类加载的是`DexFile`对象，它最终调用了底层native方法。所以说起来上面两个类加载器仅仅是用来加载dex文件，将其封装成Element并放入一个数组中，真正加载class文件的是`Element`对象中的`dexFile`，`loadClassBinaryName()`方法就相当于自定义ClassLoader中的`defineClass()`方法。

一个应用程序可能有多个dex文件(为了解决65536限制)，它们被加载后都被存放在`dexElements`数组中，如果程序要使用一个class类，则会遍历Element数组，这就使得排在数组前面的dex中的类会被加载到，排在面的就被忽略了。我们可以让`DexClassLoader`帮我们加载补丁dex文件，然后插到`PathClassLoader`的`dexElements`数组前面，这样系统默认类加载器加载类时就会先加载到修复过的class了。其实我们并不是修改了类的加载，只是修改了类加载的目录顺序从而实现修复类覆盖bug类。

## 实现

```Java
public class DexFixUtil {

    /**
     * 加载补丁
     * @param context       上下文
     * @param patchFilesDir 补丁所在目录
     */
    public static void loadFixedDex(Context context, File patchFilesDir) {
        HashSet<File> loadedDex = new HashSet<>();
        File[] listFiles = patchFilesDir.listFiles();
        if(listFiles==null)
            return;
        for (File file : listFiles) {
            if (file.getName().endsWith(".dex")
                    || file.getName().endsWith(".apk")
                    || file.getName().endsWith(".jar")
                    || file.getName().endsWith(".zip")) {
                loadedDex.add(file);
            }
        }
        if(loadedDex.size()>0)
            doDexInject(context, loadedDex);
    }

    @TargetApi(Build.VERSION_CODES.CUPCAKE)
    private static void doDexInject(Context appContext, HashSet<File> loadedDex) {
        //创建补丁包解压目录 data/data/包名/files/optimize_dex
        String optimizeDir = appContext.getFilesDir().getAbsolutePath() +
                File.separator + "optimize_dex";
        File fopt = new File(optimizeDir);
        if (!fopt.exists())
            fopt.mkdirs();
        try {
            // 1. 获取程序默认的ClassLoader
            PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();
            for (File dex : loadedDex) {
                Log.w(DexFixUtil.class.getSimpleName(), "-----------加载补丁包："+dex.getAbsolutePath());
                // 2. 创建一个DexClassLoader对象加载补丁包dex
                DexClassLoader dexLoader = new DexClassLoader(
                        dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                        fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                        null,// 加载dex时需要的库
                        pathLoader// 父类加载器
                );
                // 3. 将补丁dex加载器对象中的Element数组元素插到系统默认加载器的Element数组的前面
                //3.1 获取BaseDexClassLoader中的pathList
                Object pathPathList = getPathList(pathLoader);
                Object dexPathList = getPathList(dexLoader);
                //3.2 获取pathList的dexElements数组
                Object rightDexElements = getDexElements(pathPathList);
                Object leftDexElements = getDexElements(dexPathList);
                //3.3 合并两个dex数组
                Object dexElements = combineArray(leftDexElements, rightDexElements);
                // 重写给PathList里面的Element[] dexElements赋值
                Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错
                setField(pathList, pathList.getClass(), "dexElements", dexElements);
            }
            Log.w(DexFixUtil.class.getSimpleName(), "-----------修复完成");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**反射得到类加载器中的pathList对象*/
    private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        return getField(baseDexClassLoader, Class.forName("dalvik.system.BaseDexClassLoader"), "pathList");
    }
    /**反射得到pathList中的dexElements*/
    private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException {
        return getField(pathList, pathList.getClass(), "dexElements");
    }
    /**反射得到对象中的属性值*/
    private static Object getField(Object obj, Class<?> cl, String field) throws NoSuchFieldException, IllegalAccessException {
        Field localField = cl.getDeclaredField(field);
        localField.setAccessible(true);
        return localField.get(obj);
    }
    /**反射给对象中的属性重新赋值*/
    private static void setField(Object obj, Class<?> cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field declaredField = cl.getDeclaredField(field);
        declaredField.setAccessible(true);
        declaredField.set(obj, value);
    }
    /**数组合并*/
    private static Object combineArray(Object arrayLhs, Object arrayRhs) {
        Class<?> c lazz = arrayLhs.getClass().getComponentType();
        int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组）
        int j = Array.getLength(arrayRhs);// 得到原dex数组长度
        int k = i + j;// 得到总数组长度（补丁数组+原dex数组）
        Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组
        System.arraycopy(arrayLhs, 0, result, 0, i);
        System.arraycopy(arrayRhs, 0, result, i, j);
        return result;
    }
}
```

## 使用

-  调用

在SplashActivity中调用修复代码，然后运行错误代码。这里需要申请存储权限。由于Class对象只会创建一次，所以需要重启应用实现修复。

```Java
PermissionUtil.requestPermission(this, new PermissionCallBack() {
            @Override
            public void onGranted() {
                //sd卡权限通过后执行修复
                File patchPath = new File(Environment.getExternalStorageDirectory(), "patch");
                FixDexUtil.loadFixedDex(MainActivity.this, patchPath);
            }
            @Override
            public void onDenied() {
                finish();
            }
        }, new String[]{Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE});
```

- 得到修复的class文件

修复代码，然后Rebuild Project，在
`\app\build\intermediates\classes\debug\包名\`目录下就可以找到被修复的类的.class文件，将所有修复的类文件从**包名完整**拷贝到一个文件夹下，比如patch文件夹。

- 生成dex

cmd命令行进入sdk/build-tools/version/目录下找到dx.bat，执行命令`dx --dex --output=G:\openXu\openXuHome\workspace\HookFix\patch\patch.dex G:\openXu\openXuHome\workspace\HookFix\patch`，`--output`后面跟着dex输出目标和class文件目录。

- 下载dex

生成的补丁包应该上传到服务器，客户端根据版本判断是否需要下载补丁包，如果需要就下载补丁包到本地sd卡。这里我们省略这个步骤，直接将补丁拷贝到sd卡下某个目录中，比如patch目录，最后重起应用完成修复

# Native Hook(andfix sophix)

https://zhuanlan.zhihu.com/p/75465215
https://blog.csdn.net/itachi85/article/details/79522200


即时修复 不重启APP

https://bthvi-leiqi.blog.csdn.net/article/details/96644721

程序崩溃的根源是程序中某个方法抛出了异常，所以修复的原理就是使用补丁包中的类的方法替换掉抛异常的方法。我们怎样找到这个方法呢？

Java层不能实现方法的替换，那么我们另辟蹊径，通过Native层操控虚拟机内存。方法在虚拟机中叫ArtMethod结构体，它是Native层的。方法表其实就是一个List集合。方法最终是转换为ArtMethod结构体被执行。一个方法被压栈多次这个方法就是递归调用。

我们实现修复，也就是之前说的替换虚拟机中内存中的方法表里的方法，那么怎么替换呢？一个APK中有成千上万个方法，就某一个有异常，我们怎么区分呢？那就是用注解来区分。

- 首先我们要拿到对应的已经修复的dex文件，项目中我们肯定是从网络和获取，这里我们之还是定义在本地文件夹下。
- 其次我们加载这个Dex文件，拿到它的所有的类，遍历类中的方法，根据注解得到哪些方法时候需要修复的。
- 再根据注解中的类名方法名通过反射得到已经加载的有bug的方法。
- 调用Native方法替换有bug的方法。


[NDK使用入门](https://developer.android.google.cn/ndk/guides/index.html)

# 3. InstantRun

目前市面上很多资源热修复方案基本上都是参考Android Studio2.0推出的Instant Run的实现。实际上Instant Run的推出正是热修复浪潮的主要原因，各热修复方案在代码、资源等方面的实现很大程度上参考了Instant Run的代码，这里也简单的介绍一下它。

Instant Run的目的是减少再次运行项目时构建和部署的时间，其原理是只构建修改的部分，将修改的dex和资源推到手机，然后判断是需要热部署、温部署还是冷部署。具体实现要点如下：

- 第一次编译使用asm(字节码操纵框架)在每个类中添加change字段，在每个方法前添加逻辑；将源代码编译的dex压缩进instant-run.zip中；替换清单文件中注册的application为`BootstrapApplication`，使其作为宿主程序；
- `BootstrapApplication.attachBaseContext()`中获取资源路径、设置类加载器、代理调用真实的Application
- 在`PathClassLoader`和`BootClassLoader`中间插入一级`IncrementalClassLoader`，由于类加载器的双亲委托机制，使得`IncrementalClassLoader`成为真是项目的类加载器去加载`instant-run.zip`中的dex；
- 通过反射创建真实的`realApplication`并调用其`attachBaseContext()`方法；
- `BootstrapApplication.onCreate()`中首先替换所有当前app的application为realApplication，然后替换所有当前app的mAssets为newAssetManager，最后启动一个Server通过Socket接受工程修改内容，通过判断修改的内容决定使用哪一种部署方式

AS3.5推出了Apply Changes代替了Instant Run，它是通过利用Android8.0(API26)或更高版本中支持的Android JVMTI技术实现的，详细介绍请看[Apply Changes](https://developer.android.google.cn/studio/run/index.html?authuser=19#apply-changes)，如果后面有机会再进行研究。现在还是回到正题，实现资源热修复之前，我们应该搞清楚资源文件是怎么被打包到apk中的，以及Resource是怎样根据资源ID找到对应的资源的。


[class插桩](https://blog.csdn.net/xx326664162/article/details/95993522?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-95993522.nonecase&utm_term=android%20%E5%A2%9E%E5%8A%A0%E6%97%A5%E5%BF%97%20%E6%8F%92%E6%A1%A9)



# 4. 主流热修复框架对比



三种代码修复方式优缺点：

**dex类加载方案**

优点：实现简单，不需要太多适配
缺点：
- 因为补丁加载之前已经load的类不能重新加载，需要重启应用生效
- class校验问题(https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a)

**instantrun**
优点：

使用 java 实现，开发方便
兼容性好
补丁实时生效
缺点：

代码是侵入比较高，需要在原有代码中新增逻辑，而且需要对方法进行插桩，将这里逻辑自动化处理
增大包体积
七、资源热修复方案

native hook
Andfix
dex 插桩
Qzone
Nuwa
InstantRun Robust
Aceso
全量替换 dex
Tinker
混合方案
Sophix


























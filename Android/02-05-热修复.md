
热修复技术在当前Android开发中使用非常广泛，市面上关于热修复的框架非常多，其中很多都是大厂开源的。由于Android平台版本和厂商的差异性，自己实现热修复可能存在兼容性和稳定性的挑战，所以更现实的做法是根据自己的需求挑选一个合适自己的框架使用，但是在使用之前我们应该简单的了解一下其实现原理才能更好的选择。

# 1. 热修复框架现状

最先开始的阿里手淘的Dexposed针对Android Dalvik虚拟机运行时的Java Method Hook技术，对底层Dalvik结构过于依赖，最终无法兼容Android 5.0以后ART虚拟机。

后来支付宝提出新的热修复方案Andfix，它也是一种底层结构替换的方案，能实现实时生效及时修复，做到了Dalvik、ART全版本兼容。

阿里百川结合手淘使用Andfix的经验，推出了Hotfix方案。由于作为基石的Andfix稳定性不好，需要改造代码，且只能提供代码层面的修复，对资源和so的修复未能实现。

除了阿里系之外，比较著名的热修复还有：腾讯QQ空间超级补丁技术、微信的Tinker、饿了么Amigo、美团Robust等。不过各有各的局限性，或者不够稳定，或者补丁过大，或者效率低下，或者使用繁琐，大部分技术上看起来可行，但实际体验并不好。

2017年6月阿里巴巴手机淘宝技术团队联合阿里云发布了新一代非侵入式热修复方案Sophix，支持代码、资源、so修复，但是不支持增加四大组件，安全性和易用性非常高，接入成本低但是商业收费。

不管使用什么框架，我们需要考虑的无非是3种情况，需不需要修复代码、是否需要修复资源文件、是否替换so文件。而这三种情况中，代码修复是一个热修复框架不可或缺的部分，下面简单介绍3中情况的实现原理。

# 2. 代码修复

应用程序上线时难免会有一些方法抛出异常但没有测试出来，导致上线后大面积崩溃，这时候我们应该打一个补丁包让用户无感知下载实现修复，而不是告诉用户为了修复这个bug要升级重新安装。怎样修复类及方法层面的bug，主要有两大方案：

- 腾讯系的类加载方案（Qzone超级补丁、QFix、Tinker、Robust）

> 该方案原理是在app重新启动后让ClassLoader加载新的类，由于app运行过程中，需要修复的类可能已经被记载过了，所以需要在重启时，在还没有走到bug类业务逻辑之前抢先加载补丁中的新类，这样后续访问这个类时就会加载修复过的类。具体实现是重新编排包中dex顺序，是基于dex文件级别的类插桩方案，使得系统可以自然的识别这个顺序以实现类覆盖的目的。特点是**冷启动修复，修复范围广限制少**。

- 阿里系的底层替换方案（Andfix、HotFix）

> 该方案原理是在已经加载了的类中直接替换掉原有方法，是在原来类的基础上进行修改，因此无法实现对原有类进行方法和字段的增加。因为这会导致内存中方法和字段的索引变化，这是这个方案的固有限制。由于依赖修改虚拟机方法实体的具体字段，比如修改Dalvik方法的jni函数指针、改类或方法的访问权限等，但由于手机厂商可以对底层源码进行改造，虚拟机中方法对应的ArtMethod结构体和开源代码里的结构可能不一致，这便是**不稳定**的根源。该方案特点是**实时修复，加载轻快，立即见效**

阿里系最后推出的**Sophix混合了上面两种方案**，实现优势互补，可以灵活的根据实际情况自动切换。

## 2.1 类加载方案

### 原理

JVM虚拟机要运行一个Class时首先需要将class文件加载到内存中，这个过程包含加载、链接(验证、准备、解析)、初始化，在Java中，这些工作都是由`ClassLoader`完成的。通过下面自定义ClassLoader我们能大概明白这是一个什么过程：

```Java
public class MyClassLoader extends ClassLoader {
    //class文件所在路径
    private String path;
    public MyClassLoader(String path) {
        this.path = path;
    }
    //自定义ClassLoader只需要重写findClass()方法
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            //1. 通过流将class文件转化为流
            name = path + name + ".class";
            InputStream is = null;
            ByteArrayOutputStream outputStream = null;
            try {
                is = new FileInputStream(new File(name));
                outputStream = new ByteArrayOutputStream();
                int i = 0;
                while ((i = is.read()) != -1)
                    outputStream.write(i);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (outputStream != null)
                    outputStream.close();
                if (is != null)
                    is.close();
            }
            //2. 得到class文件的字节数组
            byte[] b = outputStream.toByteArray();
            //3. 调用definClass方法将字节数组转换为class的实例，这个方法会完成加载、链接(验证、准备、解析)、初始化的操作
            return defineClass(name, b, 0, b.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

Android中也不例外，它提供了`PathClassLoader`和`DexClassLoader`两个类加载器，我们可以通过[Android社区](https://www.androidos.net.cn/sourcecode)在线查看源码，这两个加载器是专门用于加载Android平台特定的dex格式类文件的，dex可以看作是很多class文件的一个压缩包，而通过上面两个类加载器可以从压缩包中加载出单个的class。下面我们简单看下这几个类的描述

```Java
#### libcore/dalvik/src/main/java/dalvik/system

/**用于加载dex包的class文件的ClassLoader实现*/
public class BaseDexClassLoader extends ClassLoader {
	private final DexPathList pathList; //dex文件集合
  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
      //调用DexPathList的findClass方法来获取dex包中的class文件
      Class c = pathList.findClass(name, suppressedExceptions);
      //...
      return c;
  }
}
/**Android将这个类用于其系统类加载器和应用程序类加载器*/
public class PathClassLoader extends BaseDexClassLoader {
}
/**
  * 一个类装入器，从包含classes.dex的.jar、.zip、.apk文件中加载类
  * 可用于执行未作为应用程序一部分安装的代码
  * 注意：需要为构造方法指定一个data/data/包名/files/optimize_dex解压路径（保护应用程序免受代码注入攻击）
  */
public class DexClassLoader extends BaseDexClassLoader {
}
```

`PathClassLoader`是Android程序默认的类加载器，它只能加载打包进apk并安装在系统中(/data/app目录)的classes.dex包，而`DexClassLoader`是google为了便于我们扩展而提供的dex加载器，它可以加载任意目录下的.dex的.jar和.apk文件中的类。他们都继承自`BaseDexClassLoader`，父类中维护了一个`DexPathList`类型的对象，`findClass()`方法正是通过它来加载类的。下面我们看看`DexPathList`：

```Java
final class DexPathList {
    //每一个dex文件都被封装成Element，放入该数组中
    private Element[] dexElements;

    public Class<?> findClass(String name, List<Throwable> suppressed) {
        for (Element element : dexElements) {
           //遍历dexElements数组（也就是所有dex包），从dex包中获取class对象，如果dexElements中有多个相同名称的class，则总是加载排在前面的
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
        //...
        return null;
    }
    //内部类
    static class Element {
        //dex路径
        private final File path;
        //真正的dex文件封装，DexFile可以加载dex中单个class文件
        private final DexFile dexFile;
        //真正加载class的方法
        public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
            return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                    : null;
        }
      }
}
```

`DexPathList`中维护了一个`Element`数组，我们知道Android应用将class文件都打包进了一个classes.dex的文件中（分包的情况下有多个.dex文件），而`Element`就是对一个dex文件的封装，它维护了dex文件的路径及文件对象，真正实现类加载的是`DexFile`对象，它最终调用了底层native方法。所以说起来上面两个类加载器仅仅是用来加载dex文件，将其封装成Element并放入一个数组中，真正加载class文件的是`Element`对象中的`dexFile`，`loadClassBinaryName()`方法就相当于自定义ClassLoader中的`defineClass()`方法。

一个应用程序可能有多个dex文件，它们被加载后都被存放在`dexElements`数组中，如果程序要使用一个class类，则会遍历Element数组，这就使得排在数组前面的dex中的类会被加载到，排在面的就被忽略了。我们可以让`DexClassLoader`帮我们加载补丁dex文件，然后插到`PathClassLoader`的`dexElements`数组前面，这样系统默认类加载器加载类时就会先加载到修复过的class了。其实我们并不是修改了类的加载，只是修改了类加载的目录顺序从而实现修复类覆盖bug类。

### 实现

```Java
public class DexFixUtil {

    /**
     * 加载补丁
     * @param context       上下文
     * @param patchFilesDir 补丁所在目录
     */
    public static void loadFixedDex(Context context, File patchFilesDir) {
        HashSet<File> loadedDex = new HashSet<>();
        File[] listFiles = patchFilesDir.listFiles();
        if(listFiles==null)
            return;
        for (File file : listFiles) {
            if (file.getName().endsWith(".dex")
                    || file.getName().endsWith(".apk")
                    || file.getName().endsWith(".jar")
                    || file.getName().endsWith(".zip")) {
                loadedDex.add(file);
            }
        }
        if(loadedDex.size()>0)
            doDexInject(context, loadedDex);
    }

    @TargetApi(Build.VERSION_CODES.CUPCAKE)
    private static void doDexInject(Context appContext, HashSet<File> loadedDex) {
        //创建补丁包解压目录 data/data/包名/files/optimize_dex
        String optimizeDir = appContext.getFilesDir().getAbsolutePath() +
                File.separator + "optimize_dex";
        File fopt = new File(optimizeDir);
        if (!fopt.exists())
            fopt.mkdirs();
        try {
            // 1. 获取程序默认的ClassLoader
            PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();
            for (File dex : loadedDex) {
                Log.w(DexFixUtil.class.getSimpleName(), "-----------加载补丁包："+dex.getAbsolutePath());
                // 2. 创建一个DexClassLoader对象加载补丁包dex
                DexClassLoader dexLoader = new DexClassLoader(
                        dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                        fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                        null,// 加载dex时需要的库
                        pathLoader// 父类加载器
                );
                // 3. 将补丁dex加载器对象中的Element数组元素插到系统默认加载器的Element数组的前面
                //3.1 获取BaseDexClassLoader中的pathList
                Object pathPathList = getPathList(pathLoader);
                Object dexPathList = getPathList(dexLoader);
                //3.2 获取pathList的dexElements数组
                Object rightDexElements = getDexElements(pathPathList);
                Object leftDexElements = getDexElements(dexPathList);
                //3.3 合并两个dex数组
                Object dexElements = combineArray(leftDexElements, rightDexElements);
                // 重写给PathList里面的Element[] dexElements赋值
                Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错
                setField(pathList, pathList.getClass(), "dexElements", dexElements);
            }
            Log.w(DexFixUtil.class.getSimpleName(), "-----------修复完成");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**反射得到类加载器中的pathList对象*/
    private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        return getField(baseDexClassLoader, Class.forName("dalvik.system.BaseDexClassLoader"), "pathList");
    }
    /**反射得到pathList中的dexElements*/
    private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException {
        return getField(pathList, pathList.getClass(), "dexElements");
    }
    /**反射得到对象中的属性值*/
    private static Object getField(Object obj, Class<?> cl, String field) throws NoSuchFieldException, IllegalAccessException {
        Field localField = cl.getDeclaredField(field);
        localField.setAccessible(true);
        return localField.get(obj);
    }
    /**反射给对象中的属性重新赋值*/
    private static void setField(Object obj, Class<?> cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field declaredField = cl.getDeclaredField(field);
        declaredField.setAccessible(true);
        declaredField.set(obj, value);
    }
    /**数组合并*/
    private static Object combineArray(Object arrayLhs, Object arrayRhs) {
        Class<?> c lazz = arrayLhs.getClass().getComponentType();
        int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组）
        int j = Array.getLength(arrayRhs);// 得到原dex数组长度
        int k = i + j;// 得到总数组长度（补丁数组+原dex数组）
        Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组
        System.arraycopy(arrayLhs, 0, result, 0, i);
        System.arraycopy(arrayRhs, 0, result, i, j);
        return result;
    }
}
```

### 使用

-  调用

在SplashActivity中调用修复代码，然后运行错误代码。这里需要申请存储权限。由于Class对象只会创建一次，所以需要重启应用实现修复。

```Java
PermissionUtil.requestPermission(this, new PermissionCallBack() {
            @Override
            public void onGranted() {
                //sd卡权限通过后执行修复
                File patchPath = new File(Environment.getExternalStorageDirectory(), "patch");
                FixDexUtil.loadFixedDex(MainActivity.this, patchPath);
            }
            @Override
            public void onDenied() {
                finish();
            }
        }, new String[]{Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE});
```

- 得到修复的class文件

修复代码，然后Rebuild Project，在
`\app\build\intermediates\classes\debug\包名\`目录下就可以找到被修复的类的.class文件，将所有修复的类文件从**包名完整**拷贝到一个文件夹下，比如patch文件夹。

- 生成dex

cmd命令行进入sdk/build-tools/version/目录下找到dx.bat，执行命令`dx --dex --output=G:\openXu\openXuHome\workspace\HookFix\patch\patch.dex G:\openXu\openXuHome\workspace\HookFix\patch`，`--output`后面跟着dex输出目标和class文件目录。

- 下载dex

生成的补丁包应该上传到服务器，客户端根据版本判断是否需要下载补丁包，如果需要就下载补丁包到本地sd卡。这里我们省略这个步骤，直接将补丁拷贝到sd卡下某个目录中，比如patch目录，最后重起应用完成修复



https://zhuanlan.zhihu.com/p/75465215

# Native Hook(andfix sophix)





即时修复 不重启APP

https://bthvi-leiqi.blog.csdn.net/article/details/96644721

程序崩溃的根源是程序中某个方法抛出了异常，所以修复的原理就是使用补丁包中的类的方法替换掉抛异常的方法。我们怎样找到这个方法呢？

Java层不能实现方法的替换，那么我们另辟蹊径，通过Native层操控虚拟机内存。方法在虚拟机中叫ArtMethod结构体，它是Native层的。方法表其实就是一个List集合。方法最终是转换为ArtMethod结构体被执行。一个方法被压栈多次这个方法就是递归调用。

我们实现修复，也就是之前说的替换虚拟机中内存中的方法表里的方法，那么怎么替换呢？一个APK中有成千上万个方法，就某一个有异常，我们怎么区分呢？那就是用注解来区分。

- 首先我们要拿到对应的已经修复的dex文件，项目中我们肯定是从网络和获取，这里我们之还是定义在本地文件夹下。
- 其次我们加载这个Dex文件，拿到它的所有的类，遍历类中的方法，根据注解得到哪些方法时候需要修复的。
- 再根据注解中的类名方法名通过反射得到已经加载的有bug的方法。
- 调用Native方法替换有bug的方法。


[NDK使用入门](https://developer.android.google.cn/ndk/guides/index.html)


# 资源修复

目前市面上很多资源热修复方案基本上都是参考Android Studio2.0推出的Instant Run的实现。实际上Instant Run的推出正是热修复浪潮的主要原因，各热修复方案在代码、资源等方面的实现很大程度上参考了Instant Run的代码，这里也简单的介绍一下它。

Instant Run的目的是减少再次运行项目时构建和部署的时间，其原理是只构建修改的部分，将修改的dex和资源推到手机，然后判断是需要热部署、温部署还是冷部署。具体实现要点如下：

- 第一次编译使用asm(字节码操纵框架)在每个类中添加change字段，在每个方法前添加逻辑；将源代码编译的dex压缩进instant-run.zip中；替换清单文件中注册的application为`BootstrapApplication`，使其作为宿主程序；
- `BootstrapApplication.attachBaseContext()`中获取资源路径、设置类加载器、代理调用真实的Application
- 在`PathClassLoader`和`BootClassLoader`中间插入一级`IncrementalClassLoader`，由于类加载器的双亲委托机制，使得`IncrementalClassLoader`成为真是项目的类加载器去加载`instant-run.zip`中的dex；
- 通过反射创建真实的`realApplication`并调用其`attachBaseContext()`方法；
- `BootstrapApplication.onCreate()`中首先替换所有当前app的application为realApplication，然后替换所有当前app的mAssets为newAssetManager，最后启动一个Server通过Socket接受工程修改内容，通过判断修改的内容决定使用哪一种部署方式

AS3.5推出了Apply Changes代替了Instant Run，它是通过利用Android8.0(API26)或更高版本中支持的Android JVMTI技术实现的，详细介绍请看[Apply Changes](https://developer.android.google.cn/studio/run/index.html?authuser=19#apply-changes)，如果后面有机会再进行研究。现在还是回到正题，实现资源热修复之前，我们应该搞清楚资源文件是怎么被打包到apk中的，以及Resource是怎样根据资源ID找到对应的资源的。


## 资源打包

在sdk/build.tools目录下有一个aapt.exe工具，它的作用就是在打包apk的过程中帮我们处理资源文件(res、assets、manifest)并打进一个名为`resources.ap_`的压缩包，可在build/intermediates/res路径下找到它，将其解压，可以得到res文件夹、assets文件夹、AndroidManifest.xml、resources.arsc。

resources.arsc是一张资源索引表，代码中使用R.xx.xx都会通过arsc索引表找对应的资源，可使用`AssetManager.addAssetPath()`加载它。

https://github.com/Tencent/tinker

https://blog.csdn.net/l2show/article/details/53454933

记一次苦逼的资源逆向分析 http://zjutkz.net/2016/05/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8B%A6%E9%80%BC%E7%9A%84%E8%B5%84%E6%BA%90%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/


https://my.oschina.net/bugly/blog/727850


https://blog.csdn.net/luoshengyang/article/details/8791064



单纯更新 Java 代码的 patch 框架，实用性会受到很大的局限。开发同学需要仔细验证提交内容，确保提交中不包含资源文件的变更以及 native so 的改动，会导致本就复杂的开发流程变得更加繁琐。所以我们在支持更新 Java 代码的基础之上，也支持更新资源和 native so 文件。

App 加载资源是依赖 Context#getResources 函数返回的 Resources 对象。Resources 内部包装了 AssetManager，最终由 AssetManager 从 apk 文件中加载资源。所以我们反射了替换系统默认的 Resources，让 AssetManager 从我们更新后的 apk 中加载资源。现阶段的实现支持比如 string/anim/drawable/color/layout 等资源文件的变更。由于 Android 系统在安装 apk 时候已经把 AndroidManifest.xml 文件解析并写入到系统中，目前还不支持修改四大组件，比如增加 Activity。后续会继续研究如何做到无缝修改四大组件。

# 怎么更新 so 文件？

在 Android 项目中使用 native 函数前需要先调用 System.loadLibrary(libName)。

当 lib 文件需要更新或者有 bug 时候怎么办？首先想到的是在代码中把加载 so 文件的代码改成System.load(libFilePath)，让系统加载自己指定的 libFilePath 文件。然而这样的改动需要

在源代码中修改或者使用工具在编译期把 loadLibrary 接口改为 load
patch 库把 so 文件从 patch 文件中复制到特定目录
这样在运行期才有可能加载更新后的 so 文件。

通过分析系统加载 so 文件的方式后，我们使用了更简单的处理方法。查找 lib 文件是通过调用 PathClassLoader 的 findLibrary，最终调用到 DexPathList 的 findLibrary。DexPathList 会在自己维护的列表目录中查找对应的 lib 文件是否存在。所以我们在发现 patch 文件中有 so 文件变更的时候，会在 PathClassLoader 的 nativeLibraryDirectories（Android6.0以下）或者nativeLibraryPathElements （Android 6.0及以上）的最前面插入自定义的lib文件目录。这样 ClassLoader 在 findLibrary 的时候会先在自定义的 lib 目录中查找，优先加载变更过的 so 文件。

































热修复技术在当前Android开发中使用非常广泛，市面上关于热修复的框架非常多，其中很多都是大厂开源的。我们可以根据自己的需求挑选一个合适自己的框架使用，在使用之前我们应该简单的了解一下其实现原理才能更好的选择。

# 1. 类修复

应用程序上线时难免会有一些方法抛出异常但没有测试出来，导致上线后大面积崩溃，这时候我们应该打一个补丁包让用户无感知下载实现修复，而不是告诉用户为了修复这个bug要升级重新安装。怎样修复类及方法层面的bug，有下面两种实现方式。

## 1.1 Java Hook(Tinker robust)

### 原理

JVM虚拟机要运行一个Class时首先需要将class文件加载到内存中，这个过程包含加载、链接(验证、准备、解析)、初始化，在Java中，这些工作都是由`ClassLoader`完成的。通过下面自定义ClassLoader我们能大概明白这是一个什么过程：

```Java
public class MyClassLoader extends ClassLoader {
    //class文件所在路径
    private String path;
    public MyClassLoader(String path) {
        this.path = path;
    }
    //自定义ClassLoader只需要重写findClass()方法
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            //1. 通过流将class文件转化为流
            name = path + name + ".class";
            InputStream is = null;
            ByteArrayOutputStream outputStream = null;
            try {
                is = new FileInputStream(new File(name));
                outputStream = new ByteArrayOutputStream();
                int i = 0;
                while ((i = is.read()) != -1)
                    outputStream.write(i);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (outputStream != null)
                    outputStream.close();
                if (is != null)
                    is.close();
            }
            //2. 得到class文件的字节数组
            byte[] b = outputStream.toByteArray();
            //3. 调用definClass方法将字节数组转换为class的实例，这个方法会完成加载、链接(验证、准备、解析)、初始化的操作
            return defineClass(name, b, 0, b.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

Android中也不例外，它提供了`PathClassLoader`和`DexClassLoader`两个类加载器，我们可以通过[Android社区](https://www.androidos.net.cn/sourcecode)在线查看源码。下面我们简单看下这几个类的描述

```Java
#### libcore/dalvik/src/main/java/dalvik/system

/**用于加载dex包的class文件的ClassLoader实现*/
public class BaseDexClassLoader extends ClassLoader {
	private final DexPathList pathList; //dex文件集合
  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
      //调用DexPathList的findClass方法来获取dex包中的class文件
      Class c = pathList.findClass(name, suppressedExceptions);
      //...
      return c;
  }
}
/**Android将这个类用于其系统类加载器和应用程序类加载器*/
public class PathClassLoader extends BaseDexClassLoader {
}
/**
  * 一个类装入器，从包含classes.dex的.jar、.zip、.apk文件中加载类
  * 可用于执行未作为应用程序一部分安装的代码
  * 注意：需要为构造方法指定一个data/data/包名/files/optimize_dex解压路径（保护应用程序免受代码注入攻击）
  */
public class DexClassLoader extends BaseDexClassLoader {
}
```

`PathClassLoader`是Android程序默认的类加载器，它只能加载打包进apk并安装在系统中(/data/app目录)的classes.dex包，而`DexClassLoader`是google为了便于我们扩展而提供的dex加载器，它可以加载任意目录下的.dex的.jar和.apk文件中的类。他们都继承自`BaseDexClassLoader`，父类中维护了一个`DexPathList`类型的对象，`findClass()`方法正是通过它来加载类的。下面我们看看`DexPathList`：

```Java
final class DexPathList {
    //每一个dex文件都被封装成Element，放入该数组中
    private Element[] dexElements;

    public Class<?> findClass(String name, List<Throwable> suppressed) {
        for (Element element : dexElements) {
           //遍历dexElements数组（也就是所有dex包），从dex包中获取class对象，如果dexElements中有多个相同名称的class，则总是加载排在前面的
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
        //...
        return null;
    }
    //内部类
    static class Element {
        //dex路径
        private final File path;
        //真正的dex文件封装，DexFile可以加载dex中单个class文件
        private final DexFile dexFile;
        //真正加载class的方法
        public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
            return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                    : null;
        }
      }
}
```


`DexPathList`中维护了一个`Element`数组，我们知道Android应用将class文件都打包进了一个classes.dex的文件中（分包的情况下有多个.dex文件），而`Element`就是对一个dex文件的封装，它维护了dex文件的路径及文件对象，真正实现类加载的是`DexFile`对象，它最终调用了底层native方法。所以说起来上面两个类加载器仅仅是用来加载dex文件，将其封装成Element并放入一个数组中，真正加载class文件的是`Element`对象中的`dexFile`，`loadClassBinaryName()`方法就相当于自定义ClassLoader中的`defineClass()`方法。

一个应用程序可能有多个dex文件，它们被加载后都被存放在`dexElements`数组中，如果程序要使用一个class类，则会遍历Element数组，这就使得排在数组前面的dex中的类会被加载到，排在面的就被忽略了。我们可以让`DexClassLoader`帮我们加载补丁dex文件，然后插到`PathClassLoader`的`dexElements`数组前面，这样系统默认类加载器加载类时就会先加载到修复过的class了。其实我们并不是修改了类的加载，而是修改了类加载的目录顺序。

### 实现

```Java
public class DexFixUtil {

    /**
     * 加载补丁
     * @param context       上下文
     * @param patchFilesDir 补丁所在目录
     */
    public static void loadFixedDex(Context context, File patchFilesDir) {
        HashSet<File> loadedDex = new HashSet<>();
        File[] listFiles = patchFilesDir.listFiles();
        if(listFiles==null)
            return;
        for (File file : listFiles) {
            if (file.getName().endsWith(".dex")
                    || file.getName().endsWith(".apk")
                    || file.getName().endsWith(".jar")
                    || file.getName().endsWith(".zip")) {
                loadedDex.add(file);
            }
        }
        if(loadedDex.size()>0)
            doDexInject(context, loadedDex);
    }

    @TargetApi(Build.VERSION_CODES.CUPCAKE)
    private static void doDexInject(Context appContext, HashSet<File> loadedDex) {
        //创建补丁包解压目录 data/data/包名/files/optimize_dex
        String optimizeDir = appContext.getFilesDir().getAbsolutePath() +
                File.separator + "optimize_dex";
        File fopt = new File(optimizeDir);
        if (!fopt.exists())
            fopt.mkdirs();
        try {
            // 1. 获取程序默认的ClassLoader
            PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();
            for (File dex : loadedDex) {
                Log.w(DexFixUtil.class.getSimpleName(), "-----------加载补丁包："+dex.getAbsolutePath());
                // 2. 创建一个DexClassLoader对象加载补丁包dex
                DexClassLoader dexLoader = new DexClassLoader(
                        dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                        fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                        null,// 加载dex时需要的库
                        pathLoader// 父类加载器
                );
                // 3. 将补丁dex加载器对象中的Element数组元素插到系统默认加载器的Element数组的前面
                //3.1 获取BaseDexClassLoader中的pathList
                Object pathPathList = getPathList(pathLoader);
                Object dexPathList = getPathList(dexLoader);
                //3.2 获取pathList的dexElements数组
                Object rightDexElements = getDexElements(pathPathList);
                Object leftDexElements = getDexElements(dexPathList);
                //3.3 合并两个dex数组
                Object dexElements = combineArray(leftDexElements, rightDexElements);
                // 重写给PathList里面的Element[] dexElements赋值
                Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错
                setField(pathList, pathList.getClass(), "dexElements", dexElements);
            }
            Log.w(DexFixUtil.class.getSimpleName(), "-----------修复完成");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**反射得到类加载器中的pathList对象*/
    private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        return getField(baseDexClassLoader, Class.forName("dalvik.system.BaseDexClassLoader"), "pathList");
    }
    /**反射得到pathList中的dexElements*/
    private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException {
        return getField(pathList, pathList.getClass(), "dexElements");
    }
    /**反射得到对象中的属性值*/
    private static Object getField(Object obj, Class<?> cl, String field) throws NoSuchFieldException, IllegalAccessException {
        Field localField = cl.getDeclaredField(field);
        localField.setAccessible(true);
        return localField.get(obj);
    }
    /**反射给对象中的属性重新赋值*/
    private static void setField(Object obj, Class<?> cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field declaredField = cl.getDeclaredField(field);
        declaredField.setAccessible(true);
        declaredField.set(obj, value);
    }
    /**数组合并*/
    private static Object combineArray(Object arrayLhs, Object arrayRhs) {
        Class<?> clazz = arrayLhs.getClass().getComponentType();
        int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组）
        int j = Array.getLength(arrayRhs);// 得到原dex数组长度
        int k = i + j;// 得到总数组长度（补丁数组+原dex数组）
        Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组
        System.arraycopy(arrayLhs, 0, result, 0, i);
        System.arraycopy(arrayRhs, 0, result, i, j);
        return result;
    }
}
```

### 使用

-  调用

在SplashActivity中调用修复代码，然后运行错误代码。这里需要申请存储权限。由于Class对象只会创建一次，所以需要重启应用实现修复。

```Java
PermissionUtil.requestPermission(this, new PermissionCallBack() {
            @Override
            public void onGranted() {
                //sd卡权限通过后执行修复
                File patchPath = new File(Environment.getExternalStorageDirectory(), "patch");
                FixDexUtil.loadFixedDex(MainActivity.this, patchPath);
            }
            @Override
            public void onDenied() {
                finish();
            }
        }, new String[]{Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE});
```

- 得到修复的class文件

修复代码，然后Rebuild Project，在
`\app\build\intermediates\classes\debug\包名\`目录下就可以找到被修复的类的.class文件，将所有修复的类文件从**包名完整**拷贝到一个文件夹下，比如patch文件夹。

- 生成dex

cmd命令行进入sdk/build-tools/version/目录下，执行命令`dx --dex --output=G:\openXu\openXuHome\workspace\HookFix\patch\patch.dex G:\openXu\openXuHome\workspace\HookFix\patch`，`--output`后面跟着dex输出目标和class文件目录。

- 下载dex

生成的补丁包应该上传到服务器，客户端根据版本判断是否需要下载补丁包，如果需要就下载补丁包到本地sd卡。这里我们省略这个步骤，直接将补丁拷贝到sd卡下patch目录中，最后重起应用完成修复



https://zhuanlan.zhihu.com/p/75465215

# Native Hook(andfix sophix)

即时修复 不重启APP

https://bthvi-leiqi.blog.csdn.net/article/details/96644721

程序崩溃的根源是程序中某个方法抛出了异常，所以修复的原理就是使用补丁包中的类的方法替换掉抛异常的方法。我们怎样找到这个方法呢？

Java层不能实现方法的替换，那么我们另辟蹊径，通过Native层操控虚拟机内存。方法在虚拟机中叫ArtMethod结构体，它是Native层的。方法表其实就是一个List集合。方法最终是转换为ArtMethod结构体被执行。一个方法被压栈多次这个方法就是递归调用。

我们实现修复，也就是之前说的替换虚拟机中内存中的方法表里的方法，那么怎么替换呢？一个APK中有成千上万个方法，就某一个有异常，我们怎么区分呢？那就是用注解来区分。

- 首先我们要拿到对应的已经修复的dex文件，项目中我们肯定是从网络和获取，这里我们之还是定义在本地文件夹下。
- 其次我们加载这个Dex文件，拿到它的所有的类，遍历类中的方法，根据注解得到哪些方法时候需要修复的。
- 再根据注解中的类名方法名通过反射得到已经加载的有bug的方法。
- 调用Native方法替换有bug的方法。


[NDK使用入门](https://developer.android.google.cn/ndk/guides/index.html)


# 怎么更新资源？

https://my.oschina.net/bugly/blog/727850


https://blog.csdn.net/luoshengyang/article/details/8791064



单纯更新 Java 代码的 patch 框架，实用性会受到很大的局限。开发同学需要仔细验证提交内容，确保提交中不包含资源文件的变更以及 native so 的改动，会导致本就复杂的开发流程变得更加繁琐。所以我们在支持更新 Java 代码的基础之上，也支持更新资源和 native so 文件。

App 加载资源是依赖 Context#getResources 函数返回的 Resources 对象。Resources 内部包装了 AssetManager，最终由 AssetManager 从 apk 文件中加载资源。所以我们反射了替换系统默认的 Resources，让 AssetManager 从我们更新后的 apk 中加载资源。现阶段的实现支持比如 string/anim/drawable/color/layout 等资源文件的变更。由于 Android 系统在安装 apk 时候已经把 AndroidManifest.xml 文件解析并写入到系统中，目前还不支持修改四大组件，比如增加 Activity。后续会继续研究如何做到无缝修改四大组件。

# 怎么更新 so 文件？

在 Android 项目中使用 native 函数前需要先调用 System.loadLibrary(libName)。

当 lib 文件需要更新或者有 bug 时候怎么办？首先想到的是在代码中把加载 so 文件的代码改成System.load(libFilePath)，让系统加载自己指定的 libFilePath 文件。然而这样的改动需要

在源代码中修改或者使用工具在编译期把 loadLibrary 接口改为 load
patch 库把 so 文件从 patch 文件中复制到特定目录
这样在运行期才有可能加载更新后的 so 文件。

通过分析系统加载 so 文件的方式后，我们使用了更简单的处理方法。查找 lib 文件是通过调用 PathClassLoader 的 findLibrary，最终调用到 DexPathList 的 findLibrary。DexPathList 会在自己维护的列表目录中查找对应的 lib 文件是否存在。所以我们在发现 patch 文件中有 so 文件变更的时候，会在 PathClassLoader 的 nativeLibraryDirectories（Android6.0以下）或者nativeLibraryPathElements （Android 6.0及以上）的最前面插入自定义的lib文件目录。这样 ClassLoader 在 findLibrary 的时候会先在自定义的 lib 目录中查找，优先加载变更过的 so 文件。























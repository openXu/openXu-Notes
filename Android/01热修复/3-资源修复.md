# 资源修复

关于资源的修复方案，没有像代码修复一样方法繁多，基本上集中在对AssetManager 的修改上

## 1. 原理

Android获取资源是通过AssetManager对象完成的，java层的AssetManager对应着一个C++层的AssetManager对象，实际对资源的操作是由底层对象完成。Context持有一个Resource对象，而Resource中有一个mAssets对象，这个对象就是Java层的AssetManager对象。不同Android版本中mAssets的位置有所差异，具体如下，但是这不影响对资源的操作我们只需要关注AssetManager即可。

> 

### 1.1 资源文件的格式

底层AssetManager的mResource成员是一个ResTable结构体，一个Android进程只包含一个ResTable，ResTable的成员变量`Vector<PackageGroup*> mpackageGroups`就是所有解析过的资源包的集合，resources.arsc记录了所有资源的id分配情况及资源中所有字符串，这些信息以二进制方式存储，底层AssetManager做的事情就是解析这个文件，然后把相关信息存储到mpackageGroups里面。

resources.arsc文件是由一个个ResChunk拼接起来的，从文件头开始，每个chunk的头部都是一个ResChunk_header结构，它指示了这个chunk的大小和数据类型。

```C++
/**
 * Header that appears at the front of every data chunk in a resource.
 */
struct ResChunk_header
{
    // Type identifier for this chunk.
    uint16_t type;
    // Size of the chunk header (in bytes).
    uint16_t headerSize;
    // Total size of this chunk (in bytes). 
    uint32_t size;
};
```

通过ResChunk_header的type成员，可以知道这个chunk是什么类型，从而就知道该如何解析这个chunk了。解析完一个chunk后，从这个chunk+size的位置开始，就可以得到下一个chunk起始位置，这样依次读完整个文件的数据内容。

一般情况下一个resources.arsc里面包含若干个package，不过默认情况下由打包工具aapt打出来的包只有一个package，这个package里面包含app中的所有资源信息。

资源信息主要是每个资源的名称及它对应的编号，编号是一个32位数字，也就是我们常说的资源ID，用十六进制表示就是0xPPTTEEE，其中PP是package id，TT为type id，EEEE为entry id。

- **package id**：每个package对应的是类型为RES_TABLE_PACKAGE_TYPE的ResTable_package结构体，ResTable_package结构体的id成员变量就表示它的package id
- **type id**：每个type对应的是类型为RES_TABLE_TYPE_SPEC_TYPE的ResTable_typeSpec结构体，它的id成员变量就是type id。type id具体对应什么类型，需要到package chunk里的Type String Pool中去解析得到。比如Type String Pool中依次有attr、drawable、mipmap、layout字符串，就表示attr类型的type id为1，drawable类型的type id为2，mipmap的为3，layout为4。每个type id对应了Type String Pool里的字符串顺序所指定的类型
- **entry id**：每个entry表示一个资源项，资源项是按照排列的先后顺序自动被标记编号的。一个type里按位置出现的第一个资源项entry id为0X0000，第二个为0x0001，以此类推。因此我们无法直接指定entry id，只能根据排布顺序决定。资源项之间是紧密排布没有间隙的，但是可以指定资源项为ResTable_type::NO_ENTRY来填入一个空资源

```C++
struct ResTable_package
{
    struct ResChunk_header header;
    uint32_t id;
    uint16_t name[128];
    ...
};

struct ResTable_typeSpec
{
    struct ResChunk_header header;
    uint8_t id;
    uint8_t res0;
    uint16_t res1;
    uint32_t entryCount;
};

struct ResTable_entry
{
    uint16_t size;
    uint16_t flags;
    struct ResStringPool_ref key;
};
```

**示例**

通过aapt解析带资源的apk文件

```xml
> aapt d resources resTest-debug.apk
Package Groups (1)
Package Group 0 id=0x7f packageCount=1 name=com.openxu.restest
  Package 0 id=0x7f name=com.openxu.restest
    type 0 configCount=1 entryCount=24
      spec resource 0x7f010000 com.openxu.restest:anim/abc_fade_in: flags=0x00000000
    ...
    type 9 configCount=7 entryCount=42
    ...
      #activity_main.xml这个资源id=0x7f0a001c，packageid=0x7f，typeid=0x0a，entryid=0x001c
      spec resource 0x7f0a001c com.openxu.restest:layout/activity_main: flags=0x00000000
      spec resource 0x7f0a001d com.openxu.restest:layout/activity_resource: flags=0x00000000
      spec resource 0x7f0a001e com.openxu.restest:layout/activity_test: flags=0x00000000
    ...
```

### 运行时资源解析

Android默认的打包工具是aapt，打出的apk包中资源的package id是0x7f。系统资源包（framework-res.jar）的packageid为0x01。

在使用`context.getResources().getString(R.string.app_name)`通过Resource对象获取资源时，会创建一个AssetManager对象

```Java
//[Android8.0(API 26)]frameworks/base/core/java/android/app/ResourcesManager

protected @Nullable AssetManager createAssetManager(@NonNull final ResourcesKey key) {
    //new一个AssetManager对象，构造方法中调用了init()C++方法
    AssetManager assets = new AssetManager();
    if (key.mResDir != null) {
        //调用addAssetPath()方法添加安装包apk资源路径
        if (assets.addAssetPath(key.mResDir) == 0) {
            return null;
        }
    }
    //...
    return assets;
}
```

AssetManager被创建后就已经包含了系统资源包和apk安装资源包。如果此时直接在原有AssetManager上继续`addAssetPath()`添加完整补丁包的话，由于补丁包里package id也是0x7f，就会使得同一个package id的包被加载两次，这会有什么问题呢？

Android L(5.0 API21)之后，会把补丁包添加到之前的包的同一个PackageGroup下面，解析的时候会与之前包比较同一个type id所对应的类型，如果该类型下的资源项数目和之前添加过的不一致，会打出一条warning log，但仍旧加入到该类型的TypeList中。

get资源的时候，在获取某个Type的资源时，会从前往后遍历，先得到原有安装包的资源，除非后面的资源的config比前面更详细才会发生覆盖。而对于同一个config而言，补丁中的资源就永远无法生效了。所以Android L以上版本在原有AssetManager上加入补丁包是没有任何作用的，补丁包资源无法生效。

Android4.4及一下版本，addAssetPath只是把补丁包的路径添加到mAssetPaths中，真正解析资源包的逻辑实在app第一次执行AssetManager::getResTable的时候。而等到执行加载补丁代码的时候，getResTable已经执行过无数次了，就算我们没有做过任何资源相关的操作（获取资源），Android framework里的代码也会多次调用到那里，所以以后即便调用addAssetPath也不会加载解析补丁包的资源，补丁包完全不生效。

addAssetPath方法源码调用链（不同版本之间存在差异），感兴趣的可以跟踪一下：

> Java源码 android.content.res.AssetManager

- public final int addAssetPath(String path)

> JNI源码 frameworks/base/core/jni/android_util_AssetManager.cpp

- android_content_AssetManager_addAssetPath

> C++源码 frameworks/base/libs/androidfw/AssetManager.cpp

- AssetManager::addAssetPath
- AssetManager::appendPathToResTable
- ResTable::add
- ResTable::addInternal
- ResTable::parcePackage

**一句话概括，如果打的补丁包package id为0x7f，通过旧的AssetManager对象的addAssetPath()方法添加补丁包资源是不可行的，这就是为什么Instant Run方案中构建的一个全新的AssetManager，然后加载完整的新资源包，替换掉原有的AssetManager的引用。**

### 资源修复方案

**添加补丁资源到AssetManager中**

这种方案是阿里的Sophix设计的。在打补丁包时，构造一个package id为0x66的资源包，这个包只包含改变的资源项，然后直接在原有AssetManager对象中addAssetPath()将补丁包添加进去。由于package id与原apk资源包的0x7f不同，Android5.0及以上版本会添加并解析资源，并且使用的是原始AssetManager对象，不需要大量反射修改替换操作。Android4.4及以下版本的addAssetPath不会加载资源，通过调用AssetManager.destroy()销毁原来的C++层AssetManager并释放资源，然后调用init()方法对它重新进行初始化创建一个新的C++层AssetManager对象，这个新的对象中ResTable为空，就会重新触发资源的加载。这个方案的难点在于怎样打补丁包，怎样固定package id值，以及新增、减少和修改资源的情况怎样处理，了解一下有这种方案即可，这里就不深入了。

**替换AssetManager**

这就是InstantRun的方案，构造一个新的AssetManager，反射调用其addAssetPath函数，把新的全量补丁资源包添加到AssetManager中，从而得到含有完整补丁资源的AssetManager，然后找到所有引用AssetManager的地方，通过反射将其替换为新的AssetManager。下面我们简单实现这种方案。

## 实现
 
```Java
package com.openxu.fix.resource;

import android.app.Activity;
import android.content.Context;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.util.ArrayMap;
import android.util.Log;

import java.lang.ref.WeakReference;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static android.os.Build.VERSION.SDK_INT;
import static android.os.Build.VERSION_CODES.KITKAT;

/**
 * Author: openXu
 * Time: 2020/9/16 10:08
 * class: ResourceFixUtil
 * Description:
 */
public class ResourceFixUtil {
    /**加载资源补丁包，完成资源替换*/
    public static void patchResource(Context context, String resFile){
        try{
            //1. 创建一个新的AssetManager对象，通过反射调用addAssetPath加载补丁包中的资源
            AssetManager newAssetManager = AssetManager.class.getConstructor().newInstance();
            Method addAssetPathMethod = AssetManager.class.getDeclaredMethod("addAssetPath", String.class);
            addAssetPathMethod.setAccessible(true);
            int cookie = (Integer) addAssetPathMethod.invoke(newAssetManager, resFile);
            if(cookie == 0) //添加成功时cookie必然大于0
                throw new Exception("加载补丁资源失败");
            Method ensureStringBlocks = AssetManager.class.getDeclaredMethod("ensureStringBlocks");
            ensureStringBlocks.setAccessible(true);
            ensureStringBlocks.invoke(newAssetManager);
            //2. 需要获取所有activity的集合，反射得到Activity中AssetManager的引用，全部换成新的newAssetManager
            for(Activity activity : getAllActivity()){
                Log.i("ResourceFixUtil", "替换"+activity+"的mAssets");
                Resources resources = activity.getResources();
                fixOneResources(resources, newAssetManager);
            }
            //3. 得到Resources的弱引用集合，这个集合是存储的是可能被复用的Resources，把他们的AssetManager成员替换成newAssetManager
            Collection<WeakReference<Resources>> refrences;
            if(SDK_INT >= KITKAT){
                //android4.4(API19)及以上版本通过ResourcesManager获取
                Class resourcesManagerClass = Class.forName("android.app.ResourcesManager");
                Method getInstance = resourcesManagerClass.getDeclaredMethod("getInstance");
                getInstance.setAccessible(true);
                Object resourcesManager = getInstance.invoke(null);
                try{
                    //AndroidN 7.0 API24及以上版本
                    Field mResourceReferencesField = resourcesManagerClass.getDeclaredField("mResourceReferences");
                    mResourceReferencesField.setAccessible(true);
                    refrences = (Collection<WeakReference<Resources>>)mResourceReferencesField.get(resourcesManager);
                }catch (NoSuchFieldError ignore){
                    //AndroidM 6.0 API23及以下版本(API19-API23)
                    Field mActiveResourcesField = resourcesManagerClass.getDeclaredField("mActiveResources");
                    mActiveResourcesField.setAccessible(true);
                    ArrayMap<?, WeakReference<Resources>> arrayMap =
                            (ArrayMap<?, WeakReference<Resources>>)mActiveResourcesField.get(resourcesManager);
                    refrences = arrayMap.values();
                }
            }else{
                //android4.4(API19)以下版本
                Class activityThread = Class.forName("android.app.ActivityThread");
                Field mActivityResourcesField = activityThread.getDeclaredField("mActivityResources");
                mActivityResourcesField.setAccessible(true);
                //从当前context(Activity)中获取ActivityThread mMainThread对象
                Object mMainThread = context.getClass().getDeclaredField("mMainThread").get(context);
                HashMap<?, WeakReference<Resources>> mActiveResources =
                        (HashMap<?, WeakReference<Resources>>)mActivityResourcesField.get(mMainThread);
                refrences = mActiveResources.values();
            }
            for(WeakReference<Resources> wr :refrences){
                Resources resources = wr.get();
                if(resources!=null)
                    fixOneResources(resources, newAssetManager);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    /**替换单个Resources对象中的mAssets，让其指向新的AssetManager对象*/
    private static void fixOneResources(Resources resources, AssetManager newAssetManager){
        try{
            try{
                //Android7.0 API24以下版本，Resources直接持有mAssets
                Field mAssets = Resources.class.getDeclaredField("mAssets");
                mAssets.setAccessible(true);
                mAssets.set(resources, newAssetManager);
            }catch (Throwable ignore){
                //Android7.0 API24及以上版本新增了一个ResourcesImpl，它持有mAssets
                Field mResourcesImpl = Resources.class.getDeclaredField("mResourcesImpl");
                mResourcesImpl.setAccessible(true);
                Object resourcesImpl = mResourcesImpl.get(resources);
                Field mAssets = resourcesImpl.getClass().getDeclaredField("mAssets");
                mAssets.setAccessible(true);
                mAssets.set(resourcesImpl, newAssetManager);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    /**获取所有正在运行的Activity*/
    private static List<Activity> getAllActivity(){
        List<Activity> list=new ArrayList<>();
        try {
            Class<?> activityThread=Class.forName("android.app.ActivityThread");
            //final ArrayMap<IBinder, ActivityClientRecord> mActivities = new ArrayMap<>();
            Method currentActivityThread=activityThread.getDeclaredMethod("currentActivityThread");
            currentActivityThread.setAccessible(true);
            //获取主线程对象
            Object activityThreadObject=currentActivityThread.invoke(null);
            Field mActivitiesField = activityThread.getDeclaredField("mActivities");
            mActivitiesField.setAccessible(true);
            Map<Object,Object> mActivities = (Map<Object,Object>) mActivitiesField.get(activityThreadObject);
            for (Map.Entry<Object,Object> entry:mActivities.entrySet()){
                Object value = entry.getValue();
                Class<?> activityClientRecordClass = value.getClass();
                Field activityField = activityClientRecordClass.getDeclaredField("activity");
                activityField.setAccessible(true);
                Object o = activityField.get(value);
                list.add((Activity) o);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return list;
    }
}
```

```Java
findViewById(R.id.btn_sourcefix).setOnClickListener(v->{
    File patchPath = new File(Environment.getExternalStorageDirectory(), "resourcefix");
    File patchFile = new File(patchPath.getAbsolutePath(), "resources.apk");
    ResourceFixUtil.patchResource(this, patchFile.getAbsolutePath());
});
findViewById(R.id.btn_source).setOnClickListener(v->{
    startActivity(new Intent(MainActivity.this, ResourceActivity.class));
});
```

## 制作资源补丁包

打资源补丁包是一个比较复杂的过程，需要考虑到资源文件的增、删、改等情况，这可能涉及到原始项目中资源id在补丁包中发生变化，导致资源加载错误，开源框架通常自定义gradle插件通过aapt打补丁包。这里为了演示，直接借助Android Studio打完整的apk包作为补丁包，为了顺利，我们只修改资源，不涉及增加和删除。

项目app下创建一个resourcefix文件夹，用于存储资源修复的临时文件。

- 首先将res下的资源修改成补丁资源，运行项目得到补丁包`HookFix\app\build\outputs\apk\debug\app-debug.apk`，将其拷贝到resourcefix目录下重命名为`app-debug-patch.apk`备用
- 将res下的资源置为原始资源，运行项目
- 将`app-debug-patch.apk`push到sd卡，`adb push app\resourcefix\app-debug-patch.apk /sdcard/resourcefix/resources.apk
`
- 点击查看原始资源，然后点击修复资源按钮，在此查看会发现资源是加载的补丁包中的，发现除了图片，其他资源都被替换了，这是因为图片加载一次会被缓存到内存中，需要杀死程序后重启，然后直接点击修复资源按钮

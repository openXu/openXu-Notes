
# JVM类加载机制 

https://www.cnblogs.com/chanshuyi/p/jvm_serial_07_jvm_class_loader_mechanism.html

当 Java 虚拟机将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程，这个过程我们叫：Java 虚拟机的类加载机制。JVM 虚拟机执行class字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。

**加载**

主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在JVM的方法区创建一个对应的Class对象，这个Class对象就是这个类各种数据的访问入口。

**验证(JVM规范校验，代码逻辑校验)**

当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合JVM字节码规范和没有逻辑错误的文件才能被JVM正确执行。

**准备（重点）**

当完成字节码文件的校验之后，JVM便会开始为类变量（类中static变量）分配内存并初始化。但是这里的初始化指的是为变量赋予Java语言中该数据类型的零值，而不是用户代码里初始化的值。

```Java
//类变量,准备阶段会为其分配内存并初始化为0
public static int factor = 3;  
//静态常量，为其分配内存并赋值为3，存在方法区中的常量区
public static final int number = 3;  
//类成员变量，准备阶段不会分配内存
public String website = "www.cnblogs.com/chanshuyi"; 
```

**解析**

当通过准备阶段之后，JVM针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。其实这个阶段对于我们来说也是几乎透明的，了解一下就好。

**初始化（重点）**

到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：

> 首先需要弄清楚一个概念，Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法（static变量、常量、代码块）和 对象初始化方法（成员变量赋值语句、普通代码块、构造函数的代码）。

- 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。

- 使用 java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

- 当使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

**使用**

当 JVM 完成初始化阶段之后，JVM便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。

**卸载**

当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。


## 类加载分析

在分析代码输出时，请参照下面的顺序：

- 类被加载到内存在准备阶段为类变量（类中static变量）分配内存并初始化默认值，（final static会直接赋值）
- 初始化阶段执行类构造器（按顺序执行：static变量、静态代码块），然后执行对象构造器（按顺序执行：成员变量、代码块、构造函数）
- 只有直接定义static字段的类才会被初始化
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
- 子类构造方法调用会触发父类构造方法先调用

类被加载最常见的方式只有3种，main函数所在类、new对象、调用静态变量或者方法（这种情况一定是static成员所在的类，如果是使用子类调用父类的静态成员，则不会加载子类，只会加载父类）

```Java
class Grandpa{
    static {
        System.out.println("爷爷在静态代码块");
    }
}    
class Father extends Grandpa{
    static{
        System.out.println("爸爸在静态代码块");
    }
    public static int factor = 25;
    public Father(){
        System.out.println("我是爸爸~");
    }
}
class Son extends Father{
    static {
        System.out.println("儿子在静态代码块");
    }
    public Son() {
        System.out.println("我是儿子~");
    }
}
public class InitializationDemo{
    public static void main(String[] args){
        System.out.println("爸爸的岁数:" + Son.factor);	//入口
    }
}
```

```xml
爷爷在静态代码块
爸爸在静态代码块
爸爸的岁数:25
```

为什么没有输出「儿子在静态代码块」这个字符串？

这是因为对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）。因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

对面上面的这个例子，我们可以从入口开始分析一路分析下去：

- 首先程序到 main 方法这里，使用标准化输出 Son 类中的factor类成员变量，但是Son类中并没有定义这个类成员变量。于是往父类去找，我们在Father类中找到了对应的类成员变量，于是触发了 Father 的初始化。
- 但根据我们上面说到的初始化的5种情况中的第3种（当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化）。我们需要先初始化Father类的父类，也就是先初始化Grandpa类再初始化Father类。于是我们先初始化Grandpa类输出：「爷爷在静态代码块」，再初始化Father类输出：「爸爸在静态代码块」。
- 最后，所有父类都初始化完成之后，Son类才能调用父类的静态变量，从而输出：「爸爸的岁数：25」。


```Java

public class Book {
	//2. 为main所在类初始化对象，按照顺序执行类构造器
    public static void main(String[] args) {
    	//8.调用静态方法
        staticFunction();
    }
    //1. 准备阶段为book分配内存，初始化为null
    static Book book = new Book();  //3. 类构造器第一个语句是new Book对象，所以继续执行对象构造器

    //6. 继续第3步执行类构造器（静态代码块）
    static{
        System.out.println("书的静态代码块");
    }
    //4. 对象构造器的代码块
    {
        System.out.println("书的普通代码块");
    }
	//5. 构造函数
    Book(){
        System.out.println("书的构造方法");  
        //由于初始化阶段还只执行第一句，所以amount值还是0
        System.out.println("price=" + price +",amount=" + amount);
    }

    public static void staticFunction(){
        System.out.println("书的静态方法");
    }

    int price = 110;   //对象构造器语句
    static int amount = 112;//7. 类构造器赋值
}
```

```xml
书的普通代码块
书的构造方法
price=110,amount=0
书的静态代码块
书的静态方法
```

- 当JVM在准备阶段的时候，便会为类变量分配内存和进行初始化。此时，我们的book实例变量被初始化为null，amount变量被初始化为0。
- 当进入初始化阶段后，因为Book方法是程序的入口，根据我们上面说到的类初始化的五种情况的第四种（当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类）。所以JVM会初始化Book类，即执行类构造器
- JVM对Book类进行初始化首先是执行类构造器（按顺序收集类中所有静态代码块和类变量赋值语句就组成了类构造器 ），后执行对象的构造器（按顺序收集成员变量赋值和普通代码块，最后收集对象构造器，最终组成对象构造器 ）。
- 到这里，类的初始化已经完成，JVM 执行 main 方法的内容。


## 总结

从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：

- **确定类变量的初始值**:在类加载的准备阶段，JVM会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被final修饰的类变量，则直接会被初始成用户想要的值。
- **初始化入口方法**：当进入类加载的初始化阶段后，JVM会寻找整个main方法入口，从而初始化main方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。
- **初始化类构造器**:JVM会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由JVM执行。
- **初始化对象构造器**:JVM会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。
- 如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。






















# 1. 类加载方案

## 原理

JVM虚拟机要运行一个Class时首先需要将class文件加载到内存中，这个过程包含加载、链接(验证、准备、解析)、初始化，在Java中，这些工作都是由`ClassLoader`完成的。通过下面自定义ClassLoader我们能大概明白这是一个什么过程：

```Java
public class MyClassLoader extends ClassLoader {
    //class文件所在路径
    private String path;
    public MyClassLoader(String path) {
        this.path = path;
    }
    //自定义ClassLoader只需要重写findClass()方法
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            //1. 通过流将class文件转化为流
            name = path + name + ".class";
            InputStream is = null;
            ByteArrayOutputStream outputStream = null;
            try {
                is = new FileInputStream(new File(name));
                outputStream = new ByteArrayOutputStream();
                int i = 0;
                while ((i = is.read()) != -1)
                    outputStream.write(i);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (outputStream != null)
                    outputStream.close();
                if (is != null)
                    is.close();
            }
            //2. 得到class文件的字节数组
            byte[] b = outputStream.toByteArray();
            //3. 调用definClass方法将字节数组转换为class的实例，这个方法会完成加载、链接(验证、准备、解析)、初始化的操作
            return defineClass(name, b, 0, b.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

Android的Dalvik也是一个java虚拟机，它也是通过Classloader加载类的，不同的是它是从dex文件中加载class，Android提供了三种类加载器：

- `BootClassLoader`：用于加载Android Framework层中的class字节码文件，类似java的BootstrapClassLoader
- `PathClassLoader`：加载已经安装到系统中的Apk的class字节码文件，类似java的App ClassLoader
- `DexClassLoader`：加载制定目录的class字节码文件，类似java中自定义ClassLoader

我们可以通过[Android社区](https://www.androidos.net.cn/sourcecode)在线查看源码：

```Java
#### libcore/dalvik/src/main/java/dalvik/system

/**用于加载dex包的class文件的ClassLoader实现*/
public class BaseDexClassLoader extends ClassLoader {
  private final DexPathList pathList; //dex文件集合
  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
      //调用DexPathList的findClass方法来获取dex包中的class文件
      Class c = pathList.findClass(name, suppressedExceptions);
      //...
      return c;
  }
}
/**用于加载打进apk包中的dex*/
public class PathClassLoader extends BaseDexClassLoader {
}
/**
  * 这个类加载器可以从指定的路径或者文件(含.dex的.jar、.zip、.apk文件)中加载类
  * 可用于加载未打进apk安装包的代码
  * 注意：需要为构造方法指定一个data/data/包名/files/optimize_dex解压路径（保护应用程序免受代码注入攻击）
  */
public class DexClassLoader extends BaseDexClassLoader {
}
```

`PathClassLoader`是Android程序默认的类加载器，它只能加载打包进apk并安装在系统中(/data/app目录)的classes.dex包，而`DexClassLoader`是google为了便于我们扩展而提供的dex加载器，它可以加载任意目录下的.dex的.jar和.apk文件中的类。他们都继承自`BaseDexClassLoader`，父类中维护了一个`DexPathList`类型的对象，`findClass()`方法正是通过它来加载类的。下面我们看看`DexPathList`：

```Java
final class DexPathList {
    //每一个dex文件都被封装成Element，放入该数组中
    private Element[] dexElements;

    public Class<?> findClass(String name, List<Throwable> suppressed) {
        for (Element element : dexElements) {
           //遍历dexElements数组（也就是所有dex包），从dex包中获取class对象，如果dexElements中有多个相同名称的class，则总是加载排在前面的
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
        //...
        return null;
    }
    //内部类
    static class Element {
        //dex路径
        private final File path;
        //真正的dex文件封装，DexFile可以加载dex中单个class文件
        private final DexFile dexFile;
        //真正加载class的方法
        public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
            return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                    : null;
        }
      }
}
```

`DexPathList`中维护了一个`Element`数组，我们知道Android应用将class文件都打包进了一个classes.dex的文件中（分包的情况下有多个.dex文件），而`Element`就是对一个dex文件的封装，它维护了dex文件的路径及加载进来的dex文件对象，真正实现类加载的是`DexFile`对象，它最终调用了底层native方法。

一个应用程序可能有多个dex文件(为了解决65536限制)，它们被加载后都被存放在`dexElements`数组中，如果程序要使用一个class类，则会遍历Element数组，这就使得排在数组前面的dex中的类会被加载到，排在面的就被忽略了。通过这个规则，我们可以让`DexClassLoader`帮我们加载补丁dex文件，然后插到`PathClassLoader`的`dexElements`数组前面，这样系统默认类加载器加载类时就会先加载到修复过的class了。其实我们并不是修改了类的加载，只是修改了类加载的顺序从而实现修复类覆盖bug类。

## 实现

```Java
public class DexFixUtil {

    /**
     * 加载补丁
     * @param context       上下文
     * @param patchFilesDir 补丁所在目录
     */
    public static void loadFixedDex(Context context, File patchFilesDir) {
        HashSet<File> loadedDex = new HashSet<>();
        File[] listFiles = patchFilesDir.listFiles();
        if(listFiles==null)
            return;
        for (File file : listFiles) {
            if (file.getName().endsWith(".dex")
                    || file.getName().endsWith(".apk")
                    || file.getName().endsWith(".jar")
                    || file.getName().endsWith(".zip")) {
                loadedDex.add(file);
            }
        }
        if(loadedDex.size()>0)
            doDexInject(context, loadedDex);
    }

    @TargetApi(Build.VERSION_CODES.CUPCAKE)
    private static void doDexInject(Context appContext, HashSet<File> loadedDex) {
        //创建补丁包解压目录 data/data/包名/files/optimize_dex
        String optimizeDir = appContext.getFilesDir().getAbsolutePath() +
                File.separator + "optimize_dex";
        File fopt = new File(optimizeDir);
        if (!fopt.exists())
            fopt.mkdirs();
        try {
            // 1. 获取程序默认的ClassLoader
            PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();
            for (File dex : loadedDex) {
                Log.w(DexFixUtil.class.getSimpleName(), "-----------加载补丁包："+dex.getAbsolutePath());
                // 2. 创建一个DexClassLoader对象加载补丁包dex
                DexClassLoader dexLoader = new DexClassLoader(
                        dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                        fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                        null,// 加载dex时需要的库
                        pathLoader// 父类加载器
                );
                // 3. 将补丁dex加载器对象中的Element数组元素插到系统默认加载器的Element数组的前面
                //3.1 获取BaseDexClassLoader中的pathList
                Object pathPathList = getPathList(pathLoader);
                Object dexPathList = getPathList(dexLoader);
                //3.2 获取pathList的dexElements数组
                Object rightDexElements = getDexElements(pathPathList);
                Object leftDexElements = getDexElements(dexPathList);
                //3.3 合并两个dex数组
                Object dexElements = combineArray(leftDexElements, rightDexElements);
                // 重写给PathList里面的Element[] dexElements赋值
                Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错
                setField(pathList, pathList.getClass(), "dexElements", dexElements);
            }
            Log.w(DexFixUtil.class.getSimpleName(), "-----------修复完成");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**反射得到类加载器中的pathList对象*/
    private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        return getField(baseDexClassLoader, Class.forName("dalvik.system.BaseDexClassLoader"), "pathList");
    }
    /**反射得到pathList中的dexElements*/
    private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException {
        return getField(pathList, pathList.getClass(), "dexElements");
    }
    /**反射得到对象中的属性值*/
    private static Object getField(Object obj, Class<?> cl, String field) throws NoSuchFieldException, IllegalAccessException {
        Field localField = cl.getDeclaredField(field);
        localField.setAccessible(true);
        return localField.get(obj);
    }
    /**反射给对象中的属性重新赋值*/
    private static void setField(Object obj, Class<?> cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException {
        Field declaredField = cl.getDeclaredField(field);
        declaredField.setAccessible(true);
        declaredField.set(obj, value);
    }
    /**数组合并*/
    private static Object combineArray(Object arrayLhs, Object arrayRhs) {
        Class<?> c lazz = arrayLhs.getClass().getComponentType();
        int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组）
        int j = Array.getLength(arrayRhs);// 得到原dex数组长度
        int k = i + j;// 得到总数组长度（补丁数组+原dex数组）
        Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组
        System.arraycopy(arrayLhs, 0, result, 0, i);
        System.arraycopy(arrayRhs, 0, result, i, j);
        return result;
    }
}
```

## 使用

-  调用

尽可能在需要修复类加载之前完成修复，比如在SplashActivity中调用修复代码，然后运行错误代码。这里需要申请存储权限。由于Class对象只会创建一次，所以需要重启应用实现修复。

```Java
PermissionUtil.requestPermission(this, new PermissionCallBack() {
    @Override
    public void onGranted() {
        //sd卡权限通过后执行修复
        File patchPath = new File(Environment.getExternalStorageDirectory(), "patch");
        FixDexUtil.loadFixedDex(MainActivity.this, patchPath);
    }
    @Override
    public void onDenied() {
        finish();
    }
}, new String[]{Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE});
```

- 得到修复的class文件

修复代码，然后Rebuild Project，在
`\app\build\intermediates\classes\debug\包名\`目录下就可以找到被修复的类的.class文件，将所有修复的类文件从**包名完整**拷贝到一个文件夹下，比如patch文件夹。

- 生成dex

cmd命令行进入sdk/build-tools/version/目录下找到dx.bat，执行命令`dx --dex --output=G:\openXu\openXuHome\workspace\HookFix\patch\patch.dex G:\openXu\openXuHome\workspace\HookFix\patch`，`--output`后面跟着dex输出目标和class文件目录。

- 下载dex

生成的补丁包应该上传到服务器，客户端根据版本判断是否需要下载补丁包，如果需要就下载补丁包到本地sd卡。这里我们省略这个步骤，直接将补丁拷贝到sd卡下某个目录中，比如patch目录，最后重起应用完成修复

# Native Hook(andfix sophix)

https://zhuanlan.zhihu.com/p/75465215
https://blog.csdn.net/itachi85/article/details/79522200


即时修复 不重启APP

https://bthvi-leiqi.blog.csdn.net/article/details/96644721

程序崩溃的根源是程序中某个方法抛出了异常，所以修复的原理就是使用补丁包中的类的方法替换掉抛异常的方法。我们怎样找到这个方法呢？

Java层不能实现方法的替换，那么我们另辟蹊径，通过Native层操控虚拟机内存。方法在虚拟机中叫ArtMethod结构体，它是Native层的。方法表其实就是一个List集合。方法最终是转换为ArtMethod结构体被执行。一个方法被压栈多次这个方法就是递归调用。

我们实现修复，也就是之前说的替换虚拟机中内存中的方法表里的方法，那么怎么替换呢？一个APK中有成千上万个方法，就某一个有异常，我们怎么区分呢？那就是用注解来区分。

- 首先我们要拿到对应的已经修复的dex文件，项目中我们肯定是从网络和获取，这里我们之还是定义在本地文件夹下。
- 其次我们加载这个Dex文件，拿到它的所有的类，遍历类中的方法，根据注解得到哪些方法时候需要修复的。
- 再根据注解中的类名方法名通过反射得到已经加载的有bug的方法。
- 调用Native方法替换有bug的方法。


[NDK使用入门](https://developer.android.google.cn/ndk/guides/index.html)

# 3. InstantRun

目前主流的热修复方案或多或少都参考了Android Studio2.0推出的Instant Run，实际上Instant Run的推出正是热修复浪潮的主要原因，各热修复方案在代码、资源等方面的实现很大程度上参考了Instant Run的代码，包括上面的dex类加载器。Instant Run的目的是减少再次运行项目时构建和部署的时间，其原理是只构建修改的部分，将修改的dex和资源推到手机，然后判断是需要热部署、温部署还是冷部署。

Robust热修复关键技术点就是采用了InstantRun的热更新机制，在编译期为每个class文件添加一个静态成员变量，每个方法前插入代理逻辑，加载补丁包时为静态成员变量赋值，从而实现方法被补丁类代理执行。

## 3.1 robust原理

robust的实现主要分为4个步骤：

- 接入robust sdk，打出apk安装包，该过程会通过自定义gradle插件为每个类添加一个静态成员变量，在每个方法第一行添加补丁代理逻辑
- 修复代码
- 打补丁包，robust在这个过程定义了gradle插件，自动帮我们生成补丁包类文件
- 将补丁包推到手机，让应用加载补丁包完成修复

robust的接入请参考[robust文档](https://github.com/Meituan-Dianping/Robust/blob/master/README-zh.md)，感兴趣的同学可以按照步骤体验一下。

比如下面是我们的待修复的类：

```Java
public class RobustActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        //需要修复的地方
       ((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
    }
}
```

robust在打安装包apk时通过自定义的gradle插件为我们的代码插桩，通过dex2jar反编译查看内容如下，关于插件内容可参考robust源码中的`gradle-plugin`：

```Java
public class RobustActivity extends Activity {
    //插入静态成员变量，这个变量就是RobustActivity对应补丁类的对象
    public static ChangeQuickRedirect changeQuickRedirect;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //在每个方法前插入代理逻辑，如果changeQuickRedirect不为空则执行它的方法，从而跳过了错误的方法体
        if(changeQuickRedirect != null) {
            if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) {
                PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false);
                return;
            }
        }
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
       ((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
    }
}
```

打补丁包之前，我们需要按照下面的方式修复代码：

```Java

public class RobustActivity extends Activity {
    @Modify   //修改方法
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        //((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
        settext();
    }
    @Add   //新增方法
    private void settext() {
       ((TextView) findViewById(R.id.tv_result)).setText("我是修复页面");
    }
}
````

执行补丁包命令打出补丁包patch.jar，这个过程是由`auto-patch-plugin`插件完成的，核心流程使用Gradle Tranform在编译打包从.class到.dex的过程中去修改或生成.class文件（上面插桩也是一样），首先读取被`@Add`，`@Modify`标记的类或方法，然后根据一些信息生成补丁class文件打成jar包，编译成dex，反编译为smali，修改smali文件以处理super方法和混淆，最后重新打包为dex。原理可参考资料中的《Robust自动化补丁原理解析.html》

下面我们根据robust原理，手动实现一个补丁修复功能：

## 3.2 手动实现

### 编写修复框架sdk(模拟robust的sdk)

```Java
package com.openxu.fix.robust;
/**
 * 插入的静态变量类型，每个需要修复的类需要生成一个对应的补丁类，补丁类需要实现该接口
 */
public interface ChangeQuickRedirect {
    Object accessDispatch(Object obj, String methodName, Object[] paramArrayOfObject);
    boolean isSupport(String methodName, Object[] paramArrayOfObject);
}
```

```Java
package com.openxu.fix.robust;
import android.content.Context;
import android.util.Log;
import java.io.File;
import java.lang.reflect.Field;
import java.util.Iterator;
import java.util.Map;
import dalvik.system.DexClassLoader;
/**
 * Author: openXu
 * Time: 2020/9/14 14:57
 * class: PatchExecutor
 * Description: 修复工具，为每个被修复类的静态成员变量changeQuickRedirect初始化对应补丁类对象
 */
public class PatchExecutor {

    /**
     * 加载补丁类，为修复类初始化补丁对象
     * @param context
     * @param patchFile
     */
    public static void patch(Context context, File patchFile){
        try {
            String optimizeDir = context.getFilesDir().getAbsolutePath() +
                    File.separator + "optimize_dex";
            File fopt = new File(optimizeDir);
            if (!fopt.exists())
                fopt.mkdirs();
            //创建一个dex类加载器，加载指定的补丁包
            DexClassLoader dexLoader = new DexClassLoader(
                    patchFile.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                    fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                    null,// 加载dex时需要的库
                    PatchExecutor.class.getClassLoader() );// 父类加载器
            //★ 通过类加载器加载补丁包中的补丁类对应信息（注意此处应该是RobustPatchInfo接口实现类的类全名，该类在补丁包中）
            Class patchInfoClass = dexLoader.loadClass("com.openxu.fix.robust.RobustPatchInfoImpl");
            RobustPatchInfo patchInfo = (RobustPatchInfo)patchInfoClass.newInstance();
            //得到被<修复类, 补丁类>的map
            Map<String, String> map = patchInfo.getPatchedClassesInfo();
            //遍历map，为所有被修复类创建一个补丁类对象，并赋值给静态成员变量
            Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
            while (iterator.hasNext()){
                Map.Entry<String, String> entry = iterator.next();
                //加载补丁包中的补丁类
                ChangeQuickRedirect redirect = (ChangeQuickRedirect)dexLoader.loadClass(entry.getValue()).newInstance();
                Log.w("PatchExecutor", "创建补丁静态成员变量："+redirect);
                //这里加载的被修复类是安装包apk中的类，由于补丁包中没有这个类，dexLoader会委托给其父类也就是当前PatchExecutor类的加载器加载
                Class fixClass = dexLoader.loadClass(entry.getKey());
                Log.w("PatchExecutor", "获得待修复类类型："+fixClass);
                //为被修复类的静态成员变量changeQuickRedirect赋值
                Field field = fixClass.getDeclaredField("changeQuickRedirect");
                field.set(null, redirect);
                Log.w("PatchExecutor", "为待修复类设置静态变量："+RobustActivity.changeQuickRedirect);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```Java
package com.openxu.fix.robust;
import java.util.Map;
/**
 * Author: openXu
 * Time: 2020/9/14 18:55
 * class: RobustPatchInfo
 * Description: 被修复类和补丁包中补丁类的映射关系，补丁包中应该有一个类实现该接口，以便修复工具知道那些类需要修复
 */
public interface RobustPatchInfo {
    public Map<String, String> getPatchedClassesInfo();
}
```

### 自制修复框架接入(robust接入)

MainActivity中点击按钮后加载补丁包，实现修复功能

```Java
findViewById(R.id.btn_robustfix).setOnClickListener(v->{
    //sd卡权限通过后执行修复
    PermissionUtil.requestPermission(this, new PermissionCallBack() {
        @Override
        public void onGranted() {
            //☆ robust框架修复接入
           // new PatchExecutor(getApplicationContext(), new PatchManipulateImp(), new RobustCallBackSample()).start();
            //自制修复框架接入
            File patchPath = new File(Environment.getExternalStorageDirectory(), "robust");
            File patchFile = new File(patchPath.getAbsolutePath(), "classes.dex");
            PatchExecutor.patch(MainActivity.this, patchFile);
        }
        @Override
        public void onDenied() {
            finish();
        }
    }, new String[]{Permission.READ_EXTERNAL_STORAGE, Permission.WRITE_EXTERNAL_STORAGE});
});
findViewById(R.id.btn_robust).setOnClickListener(v->{
    //点击按钮跳转到被修复页面查看修复结果
    startActivity(new Intent(MainActivity.this, RobustActivity.class));
});
```

创建一个有错误的Activity作为被修复类，需要修改onCreate()方法，并添加一个正确的方法在onCreate()中调用

```Java
package com.openxu.fix.robust;
import android.app.Activity;
import android.os.Bundle;
import android.widget.TextView;
import com.openxu.fix.R;

public class RobustActivity extends Activity {

    /**
     * 为每个类手动添加一个静态成员变量，以及下面每个方法中添加代理逻辑。
     *
     * ☆ robust框架是在打包过程中通过gradle插件操作class文件自动插入的
     * 这里我们手动实现，具体实现可查看Robust源码中的gradle-plugin插件
     */
    public static ChangeQuickRedirect changeQuickRedirect;

//    @Modify   //☆ robust修改方法用@Modify标记
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        /**插入代理逻辑*/
        if(changeQuickRedirect != null) {
            //PatchProxy中封装了获取当前className和methodName的逻辑，并在其内部最终调用了changeQuickRedirect的对应函数
            if(changeQuickRedirect.isSupport("onCreate", new Object[]{savedInstanceState})) {
                changeQuickRedirect.accessDispatch(this,
                        "onCreate", new Object[]{savedInstanceState});
                return;
            }
        }
        //下面为原始方法体
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
       ((TextView)findViewById(R.id.tv_result)).setText("我是错误页面");
//       settext();
    }

//   @Add   //robust添加方法或者类用@Add标记
//   private void settext() {
//        ((TextView) findViewById(R.id.tv_result)).setText("我是修复页面");
//    }

}
```

接入完成之后，我们运行一下项目，将有错误的apk包安装在手机上，可以看到RobustActivity页面显示了一个错误信息，安装的apk已经接入了我们的修复框架，只要sd卡下robust目录中存在补丁包，点击按钮就能加载补丁完成修复，下面我们制作补丁包


### 制作补丁包(robust通过gradle插件自动生成补丁包)

robust是通过gradle插件分析代码中的注解自动生成补丁class文件，然后打成补丁包，这里我们手动创建这些类，并通过原始命令打补丁包。需要注意的是，我们编写补丁包中修复类的代码时可以跟平时写项目代码一样放在src/main/java中，编写补丁代码过程中不要运行项目（或者最后将补丁包代码移出源码路径后卸载应用重新运行）**以确保补丁类来自补丁包而不是项目运行时被打包进了apk**。

有很多同学犯了这个错误，导致后面不管怎么修改补丁包都不生效，而且由于补丁包中调用super.onCreate()方法的地方只是一个占位，导致进入测试页面后不停的调用onCreate()方法报StackOverflowError崩溃，这个问题待会详细讲解，所以一定要细心的按照下面的步骤来，**没让运行项目不要运行**，否则一个问题会导致前面的步骤都得重来一遍。下面我们开始制作补丁包

首先需要编写一个补丁类，它用来修复`RobustActivity`，补丁类都需要实现`ChangeQuickRedirect`接口，重写`isSupport()`方法和`accessDispatch()`方法，他们分别对应被修复类中调用的两个方法，然后还需要在补丁类中编写需要修复的方法的代码或者新增方法：

```Java
package com.openxu.fix.robust;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;
import com.openxu.fix.R;
/**
 * SecondActivity的真正补丁类
 * 补丁类的作用就是代替被修复的类执行的方法，所以在被修复类中修复的方法都应该放到补丁类中编写，但是这样会导致一些问题
 * 1. 怎么在补丁类中调用被修复类的super方法？
 * 2. 被修复类的this在补丁类中应该怎么办？
 * 3. 怎样在补丁类中调用内联方法？
 * ...
 * 下面我们通过修改onCreate()方法去讲解其中一些问题的解决
 */
public class RobustActivityPatch implements ChangeQuickRedirect {

    //被修复的类对象
    private RobustActivity realActivity;

    //判断传入的方法是否支持需要修复
    @Override
    public boolean isSupport(String methodName, Object[] paramArrayOfObject) {
        Log.w("RobustActivityPatch", "判断方法是否需要热修复："+methodName+"  "+paramArrayOfObject[0]);
        //判断如果是onCreate方法，则返回true表示需要修复
        if(methodName.equals("onCreate") && paramArrayOfObject!=null
                &&paramArrayOfObject.length==1&&(paramArrayOfObject[0]==null||
                paramArrayOfObject[0].getClass()==Bundle.class)){
            return true;
        }
        //else if(onDestroy){
        //其他方法判断
        //    return true;
        //}...
        return false;
    }
    //分配修复方法，不同的bug方法调用对应的修复代理方法
    @Override
    public Object accessDispatch(Object obj, String methodName, Object[] paramArrayOfObject) {
        //判断如果是onCreate方法，则调用补丁类中的onCreate()
        if(methodName.equals("onCreate") && paramArrayOfObject!=null
                &&paramArrayOfObject.length==1&&(paramArrayOfObject[0]==null||
                paramArrayOfObject[0].getClass()== Bundle.class)){
            realActivity = (RobustActivity)obj;
            onCreate((Bundle)paramArrayOfObject[0]);
        }
        //else if(onDestroy){
        //其他方法判断
        //    onDestroy()
        //}...
        return null;
    }

    //重写需要修改的onCreate方法内容
    protected void onCreate(Bundle paramBundle) {
        Log.w(getClass().getSimpleName(), "调用补丁类的onCreate方法");
        /**
         * ★调用super.onCreate()
         * realActivity.super.onCreate(paramBundle); ???
         * 在补丁类中没办法调用真实realActivity的super.onCreate()怎么办？
         *
         * 解决办法：
         * 先调用一个方法用于占位，在后面打补丁包的时候需要通过修改smali指令使代码指向realActivity的super.onCreate()
         *
         * 但是这个占位方法的定义是有讲究的，因为要调用super.onCreate()方法属于Activity类，由protected修饰；
         * 这就导致只有在Activity中、其子类、同包下的类才能调用Activity的onCreate()方法。当前补丁类明显不是
         * Activity的子类，并且不在android.app包下，就只有一中可能了，定义一个RobustActivityPatchAssit类
         * 继承Activity，然后在该类中定义一个方法，在此调用该方法
         */
        RobustActivityPatchSuperMethod.accessSuperOnCreate(realActivity, paramBundle);
        /**★ 补丁类中的this调用怎么处理*/
        //这里的this表示的补丁类，而我们需要调用的是被修复类的方法
        //setContentView(R.layout.activity_test);
        //在补丁类中使用真实对象realActivity替换this，从而实现调用被修复RobustActivity对象的方法
        realActivity.setContentView(R.layout.activity_test);
        //调用新增方法
        settext();
    }
    //新增方法
    private void settext() {
        //realActivity替换this
        ((TextView) realActivity.findViewById(R.id.tv_result)).setText("我是修复页面");
    }
}
```

用于处理super.onCreate()的类：

```Java
package com.openxu.fix.robust;
import android.app.Activity;
import android.os.Bundle;
/**
 * Author: openXu
 * Time: 2020/9/15 15:46
 * class: RobustActivityPatchAssit
 * Description: 补丁包中用于调用Activity的super方法
 */
public class RobustActivityPatchSuperMethod extends Activity {
    public static void accessSuperOnCreate(RobustActivity realActivity, Bundle paramBundle){
        realActivity.onCreate(paramBundle);
    }
}
```

还需要一个被修复类和补丁类的映射表，用来告诉`PatchExecutor`补丁执行器哪些类需要被修复，从而为被修复类创建补丁类的对象赋值给ChangeQuickRedirect静态成员变量。

```Java
package com.openxu.fix.robust;
import java.util.HashMap;
import java.util.Map;
/**
 * 注册需要修复的类和补丁类的对应关系
 */
public class RobustPatchInfoImpl implements RobustPatchInfo {
    @Override
    public Map<String, String> getPatchedClassesInfo() {
        Map<String, String> map = new HashMap<>();
        map.put("com.openxu.fix.robust.RobustActivity", "com.openxu.fix.robust.RobustActivityPatch");
        return map;
    }
}
```

到此我们的补丁包编写就完成了，接下来我们要经过一些列的步骤将补丁java文件打包成**正确**的dex补丁包，将其推送到手机上供修复框架加载：

1. java文件准备

> 为了方便的管理编译过程中的各种中间文件，在app下创建robust文件夹，该文件夹是存放所有中间文件的。在robust下创建patchsrc用于存放补丁包java源码文件，将补丁包类带包名(RobustActivityPatch.java、RobustActivityPatchSuperMethod.java、RobustPatchInfoImpl.java)**移动**到patchsrc目录中。这两个类中引用了其他的类，为了编译时避免报找不到类错误，需要将它们引用的类也一起**复制**过来参与编译。然后在robust目录中创建一个all.txt文件，记录所有需要编译的java源文件路径

```xml
> cd app
> mkdir robust //为了方便管理编译过程中的一些临时文件，在app下创建一个robust文件夹
> cd robust
> mkdir patchsrc  

//all.txt文件内容如下

G:\openXu\openXuHome\workspace\HookFix\app\robust\patchsrc\com\openxu\fix\robust\RobustActivityPatch.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\patchsrc\com\openxu\fix\robust\RobustActivityPatchSuperMethod.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\patchsrc\com\openxu\fix\robust\RobustPatchInfoImpl.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\patchsrc\com\openxu\fix\robust\ChangeQuickRedirect.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\patchsrc\com\openxu\fix\robust\RobustActivity.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\patchsrc\com\openxu\fix\robust\RobustPatchInfo.java
G:\openXu\openXuHome\workspace\HookFix\app\robust\patchsrc\com\openxu\fix\R.java
```

2. java->class

```xml
> mkdir patchclass    //存放编译后的class文件

Windows> javac  -encoding utf-8 -target 1.8 -bootclasspath F:\IDE\sdk\platforms\android-29\android.jar -d patchclass @all.txt

Mac> javac  -encoding utf-8 -target 1.8 -bootclasspath /Users/openXu/Library/Android/sdk/platforms/android-28/android.jar -d patchclass  @all.txt
```

3. class->dex

打包dex使用的是d8工具，需要配置环境变量，该工具位于sdk\build-tools\version，环境变量配置不会的自行上网搜索，没有技术障碍。在编译之前可以将没用的class文件删除，只保留补丁包中需要的RobustActivityPatch.class、RobustActivityPatchSuperMethod.class和RobustPatchInfoImpl.class三个文件

d8相关更多信息请参考https://developer.android.google.cn/studio/command-line/d8?authuser=19

```xml
Windows> d8 patchclass\com\openxu\fix\robust\*.class

Mac> d8 patchclass/com/openxu/fix/robust/*.class
```

命令执行后会得到一个classes.dex文件，这个文件就是补丁包，但是这个补丁包是有缺陷的，如果被加载会递归调用被修复类的onCreate()方法导致StackOverflowError。这是编写`RobustActivityPatch.onCreate()`方法时遗留的问题（super.onCreate()占位），需要通过修改smali指令解决。

4. dex->smali

将得到的classes.dex反编译为.smali，需要用到baksmali-2.4.0.jar
，而smali->dex则需要smali-2.4.0.jar，在[bitbucket](https://bitbucket.org/JesusFreke/smali/downloads/)下载两个jar包后放到robust目录下。

```xml
// dex->smali，命令执行后会在robust目录下出现out目录，下面有对应的.smali文件
> java -jar baksmali-2.4.0.jar d classes.dex
```

5. 修改smali以解决在补丁类中调用被修复类的super

在修改之前，我们应该对smali有一定的了解。smali是Dalvik虚拟机指令，它由一些列操作码组成，在android逆向领域通常需要修改smali文件，如果只需要简单的修改，网上随便搜索smali语法（比如[SMALI语法入门教程](https://www.cnblogs.com/bluestorm/p/12272942.html)）就能基本读懂smali文件，如果要深度修改，还需要了解更多的指令，可参考资料文件夹中的《SMALI语法中文.pdf》

> Dalvik VM与JVM的最大的区别之一就是Dalvik VM是基于寄存器的。基于寄存器是什么意思呢？也就是说，在smali里的所有操作都必须经过寄存器来进行：本地寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、...参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2、...特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数一次类推，而在static函数中p0对应第一个参数（Java的static方法中没有this）。

> smali中的成员变量分为static fields（静态成员变量）和instance fields（普通成员变量），如果我们要在某个方法中使用成员变量，需要先获取成员变量将其保存到寄存器中，获取的指令有：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等，操作的指令有：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等。s开头指令表示获取或者操作static变量，i开头则是普通变量；没有“-object”后缀的表示操作的成员变量对象是基本数据类型，带“-object”表示操作的成员变量是对象类型；boolean类型则使用带“-boolean”的指令操作。

请阅读并理解上面两段，再看RobustActivityPatch.smali指令分析实例：

```xml
# RobustActivityPatch.smali中有一个成员变量
.field private realActivity:Lcom/openxu/fix/robust/RobustActivity;
# 指令分析
.method protected onCreate(Landroid/os/Bundle;)V
    .registers 4

    .line 55
    # 调用p0（p0代表当前RobustActivityPatch对象this）的getClass()方法
    invoke-virtual {p0}, Ljava/lang/Object;->getClass()Ljava/lang/Class;
    # 将上面方法返回值保存到v0寄存器中（RobustActivityPatch.class对象）
    move-result-object v0
    # 调用class对象的getSimpleName()方法得到类名 “RobustActivityPatch”
    invoke-virtual {v0}, Ljava/lang/Class;->getSimpleName()Ljava/lang/String;
    # 将类名保存在v0中，上面这几步都是为了得到RobustActivityPatch的类名
    move-result-object v0
    # 将字符串“调用补丁类的onCreate方法”存入v1中
    const-string v1, "\u8c03\u7528\u8865\u4e01\u7c7b\u7684onCreate\u65b9\u6cd5"
    # 调用静态方法Log.w(v0, v1) => Log.w(getClass().getSimpleName(), "调用补丁类的onCreate方法");
    invoke-static {v0, v1}, Landroid/util/Log;->w(Ljava/lang/String;Ljava/lang/String;)I

    .line 69
    # 获取RobustActivityPatch的成员变量realActivity，其类型是RobustActivity，并将成员变量保存在v0中
    iget-object v0, p0, Lcom/openxu/fix/robust/RobustActivityPatch;->realActivity:Lcom/openxu/fix/robust/RobustActivity;
    # ★ 调用RobustActivityPatchSuperMethod的静态方法accessSuperOnCreate(v0, p1)
    # 思考：可不可以在这里调用super.onCreate()呢？
    # 不可以，因为当前类不是Activity的子类，也不跟Activity在同一个包，无法访问Activity类的onCreate()方法，所以我们需要在RobustActivityPatchSuperMethod中修改指令
    invoke-static {v0, p1}, Lcom/openxu/fix/robust/RobustActivityPatchSuperMethod;->accessSuperOnCreate(Lcom/openxu/fix/robust/RobustActivity;Landroid/os/Bundle;)V

    .line 74
    iget-object p1, p0, Lcom/openxu/fix/robust/RobustActivityPatch;->realActivity:Lcom/openxu/fix/robust/RobustActivity;

    const v0, 0x7f0a001d

    invoke-virtual {p1, v0}, Lcom/openxu/fix/robust/RobustActivity;->setContentView(I)V

    .line 76
    invoke-direct {p0}, Lcom/openxu/fix/robust/RobustActivityPatch;->settext()V

    .line 77
    return-void
.end method
```

下面修改RobustActivityPatchSuperMethod.smali中关于onCreate方法的指令：

```xml
# 由于RobustActivityPatchSuperMethod是Activity的子类，所以该类中是可以调用Activity的onCreate()方法的，也就是RobustActivity的super.onCreate()

.method public static accessSuperOnCreate(Lcom/openxu/fix/robust/RobustActivity;Landroid/os/Bundle;)V
    .registers 2
    .line 13
    # ★★★ 原始代码是调用RobustActivity的onCreate()方法，如果不修改，会导致补丁包加载后递归调用onCreate()方法，崩溃
    # invoke-virtual {p0, p1}, Lcom/openxu/fix/robust/RobustActivity;->onCreate(Landroid/os/Bundle;)V
    # 我们的目标是调用RobustActivity的父类Activity的onCreate()方法
    # invoke-super{p0, p1}用于调用p0的super.onCreate(p1)
    # 静态方法中p0表示第一个参数也就是RobustActivity对象，p1是第二个参数Bundle对象
    invoke-super {p0, p1}, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V

    .line 14
    return-void
.end method
```

6. smali->dex

```xml
//编译修改后的smali打包为classes_1.dex
> java -jar smali-2.4.0.jar a out -o classes_1.dex
```

7. 推送补丁包到sd卡，点击修复按钮，查看结果
```xml
adb push classes_1.dex /sdcard/robust/classes.dex
```

## 3.3 总结

通过代码插桩的方式动态替换错误方法的执行对象，可以达到实时修复的效果，这种方式实现起来步骤稍多，但是思路还是比较清晰，而一些复杂的过程比如代码插桩、补丁类生成、打补丁包这些robust都通过插件帮我们实现了。目前robust仅仅支持代码修复，包括修改方法、增加方法、增加类等，资源修复和so修复暂时还没有实现或者公开。如果仅仅对代码修复有要求、而且需要实时修复的可以考虑robust。

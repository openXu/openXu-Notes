> ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºopenXuåŸåˆ›æ–‡ç« [ã€openXuçš„åšå®¢ã€‘](http://blog.csdn.net/xmxkf)ï¼Œæœªç»åšä¸»å…è®¸ä¸å¾—ä»¥ä»»ä½•å½¢å¼è½¬è½½

@[toc]

åœ¨[ã€Škotlinåç¨‹ç¡¬æ ¸è§£è¯»(4. åç¨‹çš„åˆ›å»ºå’Œå¯åŠ¨æµç¨‹åˆ†æ)ã€‹](https://openxu.blog.csdn.net/article/details/117000126)ä¸€æ–‡ä¸­ï¼Œæˆ‘ä»¬åˆ†æäº†åç¨‹è‡ªåˆ›å»ºå™¨åˆ›å»ºåç¨‹å¯¹è±¡åˆ°å¼€å§‹æ‰§è¡Œåç¨‹ä»£ç å—ä¸­ä»£ç çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œæ–‡ç« æœ€åæ€»ç»“äº†åç¨‹æœ‰3å±‚åŒ…è£…ï¼š

- ç¬¬ä¸€å±‚æ˜¯é€šè¿‡åç¨‹æ„å»ºå™¨åˆ›å»ºçš„`AbstractCoroutine`å­ç±»ç±»å‹çš„åç¨‹å¯¹è±¡ï¼Œå®ƒçš„ä½œç”¨æ˜¯ç»´æŠ¤äº†åç¨‹çš„ä¸Šä¸‹æ–‡
- ç¬¬äºŒå±‚æ˜¯ç¼–è¯‘æœŸç”Ÿæˆçš„`SuspendLambda`çš„å­ç±»å¯¹è±¡ï¼Œå°è£…äº†åç¨‹ä»£ç å—ä¸­çš„ä»£ç å’Œæ‰§è¡Œé€»è¾‘
- ç¬¬ä¸‰å±‚æ˜¯`DispatchedContinuation`ï¼Œå°è£…äº†åç¨‹çš„çº¿ç¨‹è°ƒåº¦ï¼Œä¹Ÿå°±æ˜¯å†³å®šåç¨‹ä»£ç å—ä¸­çš„ä»£ç æ˜¯åœ¨é‚£ä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œçš„

åœ¨kotlinåç¨‹ä¸­ï¼Œåç¨‹çš„æ‰§è¡Œæ¶‰åŠåˆ°3æ¬¡çº¿ç¨‹åˆ‡æ¢ï¼Œåˆ†åˆ«æ˜¯ï¼š

- åˆ‡æ¢åˆ°æŒ‡å®šçº¿ç¨‹æ‰§è¡Œåç¨‹ä»£ç å—ä¸­çš„ä»£ç 
- å½“åç¨‹ä»£ç å—è°ƒç”¨åˆ°å¼‚æ­¥æŒ‚èµ·å‡½æ•°æ—¶ï¼Œåˆ‡æ¢åˆ°æŒ‡å®šçº¿ç¨‹æ‰§è¡ŒæŒ‚èµ·å‡½æ•°
- å½“å¼‚æ­¥æŒ‚èµ·å‡½æ•°æ‰§è¡Œå®Œæ¯•ï¼Œå°†å‡½æ•°æ‰§è¡Œç»“æœResultå¯¹è±¡åˆ‡æ¢åˆ°åç¨‹æ‰€åœ¨çš„çº¿ç¨‹ï¼Œç»§ç»­æ‰§è¡Œåç¨‹ä»£ç å—ä¸­å‰©ä¸‹çš„ä»£ç 

è¿™äº›çº¿ç¨‹åˆ‡æ¢çš„åŠ¨ä½œéƒ½æ˜¯é€šè¿‡åç¨‹è°ƒåº¦å™¨æ¥å®ç°çš„ï¼Œæœ¬æ–‡å°†å¯¹åç¨‹è°ƒåº¦å™¨åšè¯¦ç»†è®²è§£ã€‚

# 1. ç›¸å…³ç±»ä»‹ç»

## 1.1 ContinuationInterceptorç»­ä½“æ‹¦æˆªå™¨

åœ¨[ã€Škotlinåç¨‹ç¡¬æ ¸è§£è¯»(3. suspendæŒ‚èµ·å‡½æ•°&æŒ‚èµ·å’Œæ¢å¤çš„å®ç°åŸç†)ã€‹](https://openxu.blog.csdn.net/article/details/117000039)ä¸€æ–‡çš„**2.3 SuspendLambda**èŠ‚æˆ‘ä»¬è®²è¿‡ç»­ä½“`Continuation`ç›¸å…³çš„ç±»ï¼Œå…¶ç¬¬äºŒå±‚å®ç°ç±»`ContinuationImpl`ï¼ˆç¬¬ä¸€å±‚æ˜¯`BaseContinuationImpl`ï¼‰ä¸»è¦å°±æ˜¯å¢åŠ äº†ç»­ä½“æ‹¦æˆªå™¨çš„åŠŸèƒ½å‡½æ•°`intercepted()`ï¼Œä»åç¨‹ä¸Šä¸‹æ–‡ä¸­è·å–`Key`ä¸º`ContinuationInterceptor`çš„ç»­ä½“æ‹¦æˆªå™¨ä¸Šä¸‹æ–‡å¯¹è±¡ã€‚**ç»­ä½“æ‹¦æˆªå™¨çš„ä½œç”¨å°±æ˜¯å°†åŸå§‹ç»­ä½“å¯¹è±¡åŒ…è£…ä¸ºå¦ä¸€ç§ç»­ä½“ç±»å‹çš„å¯¹è±¡ï¼Œä»è€Œå¢å¼ºåŸç»­ä½“çš„åŠŸèƒ½**ã€‚

```kotlin
//ç»­ä½“æ‹¦æˆªå™¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªåç¨‹ä¸Šä¸‹æ–‡å…ƒç´ 
public interface ContinuationInterceptor : CoroutineContext.Element {
    //ç»­ä½“æ‹¦æˆªå™¨çš„é”®
    companion object Key : CoroutineContext.Key<ContinuationInterceptor>
    //æ‹¦æˆªç»­ä½“ï¼Œå°†åŸå§‹ç»­ä½“ï¼ˆæ ¹æ®å‰é¢æ–‡ç« çš„åˆ†æï¼ŒåŸå§‹ç»­ä½“é€šå¸¸å°±æ˜¯SuspendLambdaçš„å­ç±»å¯¹è±¡ï¼‰è½¬æ¢ä¸ºå¦ä¸€ç§ç»­ä½“å­ç±»ç±»å‹
    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>
    ...
}
```

## 1.2 Dispatchersè°ƒåº¦å™¨

kotlinåç¨‹åº“ä¸­æœ‰4ç§è°ƒåº¦å™¨ï¼Œå®ƒä»¬éƒ½æ˜¯`CoroutineDispatcher`çš„å­ç±»å¯¹è±¡ï¼Œè€Œ`CoroutineDispatcher`åˆå®ç°äº†`ContinuationInterceptor`ï¼Œæ‰€ä»¥è°ƒåº¦å™¨æ˜¯é€šè¿‡ç»­ä½“æ‹¦æˆªå™¨å®ç°çš„ï¼Œæ¯ä¸ªè°ƒåº¦å™¨å¯¹è±¡æ˜¯ä¸Šä¸‹æ–‡å…ƒç´ åŒæ—¶åˆæ˜¯ä¸€ä¸ªç»­ä½“æ‹¦æˆªå™¨ï¼š

```kotlin
//Dispatcherså•ä¾‹å¯¹è±¡ï¼Œå®ƒåŒ…å«4ä¸­è°ƒåº¦å™¨å¯¹è±¡
public actual object Dispatchers {
    //4ç§è°ƒåº¦å™¨ï¼Œéƒ½æ˜¯CoroutineDispatcherçš„å­ç±»å¯¹è±¡ï¼ŒCoroutineDispatcheræ˜¯é€šè¿‡ç»­ä½“æ‹¦æˆªå™¨å®ç°çš„ã€‚actualè¡¨ç¤ºä¸å¹³å°ç›¸å…³ï¼Œä¸åŒå¹³å°å®ç°ä¸åŒ
    public actual val Default: CoroutineDispatcher = createDefaultDispatcher()
    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher
    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined
    public val IO: CoroutineDispatcher = DefaultScheduler.IO
}
//åç¨‹è°ƒåº¦å™¨æŠ½è±¡ç±»ï¼Œå®šä¹‰äº†åˆ‡æ¢çº¿ç¨‹çš„ç›¸å…³æ–¹æ³•
public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
    public companion object Key : AbstractCoroutineContextKey<ContinuationInterceptor, CoroutineDispatcher>(
        ContinuationInterceptor,  { it as? CoroutineDispatcher })
    
        //æ³¨æ„æ˜¯finalä¿®é¥°çš„ï¼šæ‰€æœ‰çš„è°ƒåº¦å™¨ï¼ˆç»­ä½“æ‹¦æˆªå™¨ï¼‰éƒ½å°†åŸç»­ä½“åŒ…è£…ä¸ºDispatchedContinuationç±»å‹
    public final override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =
        DispatchedContinuation(this, continuation)
        
    //å››ç§è°ƒåº¦å™¨éƒ½åˆ†åˆ«å®ç°ä¸‹é¢ä¸¤ä¸ªå‡½æ•°ï¼Œç¡®ä¿åœ¨ä¸åŒçš„çº¿ç¨‹è°ƒåº¦
    //åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œé»˜è®¤ä¸ºtrueï¼Œè¡¨ç¤ºéœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œå…·ä½“çš„è°ƒåº¦å™¨éœ€è¦æ ¹ç»æƒ…å†µé‡å†™
    public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
    //è°ƒåº¦ï¼šåˆ‡æ¢çº¿ç¨‹æ‰§è¡Œblock
    public abstract fun dispatch(context: CoroutineContext, block: Runnable)


}

//ç±»å…³ç³»å›¾
CoroutineContext
    .Element        //ä¸Šä¸‹æ–‡å…ƒç´ 
        |-- ContinuationInterceptor //ç»­ä½“æ‹¦æˆªå™¨ï¼šå°†ç»­ä½“åŒ…è£…ä¸ºå¦ä¸€ç§ç»­ä½“ç±»å‹
                |-- CoroutineDispatcher //åç¨‹è°ƒåº¦å™¨æŠ½è±¡ç±»ï¼šå®ç°äº†æ‹¦æˆªå™¨åŠŸèƒ½ï¼Œå°†åŸç»­ä½“å¯¹è±¡åŒ…è£…ä¸ºDispatchedContinuationç±»å‹
                        //å››ç§è°ƒåº¦å™¨ï¼Œå®ç°äº†CoroutineDispatcherï¼Œä¸åŒçš„å¹³å°å®ç°ä¸åŒ
                        |-- Dispatchers.Default   //
                        |-- Dispatchers.Main      //
                        |-- Dispatchers.Unconfined//
                        |-- Dispatchers.IO        //
```

# 2. åç¨‹çš„3æ¬¡çº¿ç¨‹è°ƒåº¦

## 2.1 ç¬¬ä¸€æ¬¡çº¿ç¨‹è°ƒåº¦ï¼šåˆ‡æ¢åˆ°æŒ‡å®šçº¿ç¨‹å¼€å§‹æ‰§è¡Œåç¨‹ä»£ç 

åœ¨[ã€Škotlinåç¨‹ç¡¬æ ¸è§£è¯»(4. åç¨‹çš„åˆ›å»ºå’Œå¯åŠ¨æµç¨‹åˆ†æ)ã€‹](https://openxu.blog.csdn.net/article/details/117000126)ä¸€æ–‡ä¸­çš„ç¬¬2.1ç« èŠ‚ï¼Œå½“ä½¿ç”¨åç¨‹æ„å»ºå™¨åˆ›å»ºä¸€ä¸ªåç¨‹å¯¹è±¡æ—¶ï¼Œä¼šåœ¨`newCoroutineContext(context)`å‡½æ•°ä¸­æ£€æŸ¥ä½œç”¨åŸŸçš„ä¸Šä¸‹æ–‡ä¸­æ˜¯å¦å­˜åœ¨keyä¸º`ContinuationInterceptor`çš„å…ƒç´ ï¼Œå¦‚æœä¸å­˜åœ¨å°†ä¼šæ·»åŠ ä¸€ä¸ª`Dispatchers.Default`å¯¹è±¡ï¼Œæ‰€ä»¥**åç¨‹çš„ä¸Šä¸‹æ–‡ä¸­å¿…å®šä¼šæœ‰ä¸€ä¸ªContinuationInterceptorçš„å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯çº¿ç¨‹è°ƒåº¦å™¨ï¼Œæ¥æ˜ç¡®åç¨‹ä»£ç åœ¨å“ªä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œ**ï¼š

```kotlin
//â˜† kotlin-stlib.jar 
package kotlin.coroutines.jvm.internal
//ç»­ä½“çš„å®ç°ï¼Œå¢åŠ äº†æ‹¦æˆªåŠŸèƒ½
internal abstract class ContinuationImpl(
    completion: Continuation<Any?>?, private val _context: CoroutineContext?) : BaseContinuationImpl(completion) {
    public override val context: CoroutineContext
        get() = _context!!
    private var intercepted: Continuation<Any?>? = null   //è¢«æ‹¦æˆªçš„åŸå§‹ç»­ä½“å¯¹è±¡ï¼ˆSuspendLambdaå­ç±»å¯¹è±¡ï¼‰
    //3.1 ä»ä¸Šä¸‹æ–‡ä¸­è·å–æ‹¦æˆªå™¨ï¼Œå®ç°ç»­ä½“å¯¹è±¡åŒ…è£…
    public fun intercepted(): Continuation<Any?> =
        intercepted?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                .also { intercepted = it }
       ...
}
```

åœ¨å¯åŠ¨åç¨‹ä¹‹å‰ï¼Œä¼šè°ƒç”¨`createCoroutineUnintercepted(receiver, completion)`åˆ›å»º`SuspendLambda`å­ç±»ç±»å‹çš„åŸå§‹ç»­ä½“å¯¹è±¡ï¼Œç„¶åè°ƒç”¨ç»­ä½“çš„`intercepted()`å°†å…¶åŒ…è£…ä¸º`DispatchedContinuation`ç±»å‹ï¼Œæœ€åè°ƒç”¨`resumeCancellableWith()`å¯åŠ¨åç¨‹ã€‚`resumeCancellableWith()`å‡½æ•°ä¸­**ä½¿ç”¨è°ƒåº¦å™¨å¯¹è±¡dispatcheråˆ¤æ–­æ˜¯å¦éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œå¦‚æœéœ€è¦åˆ™è°ƒç”¨dispatcher.dispatch()å®ç°çº¿ç¨‹åˆ‡æ¢**ï¼š

```kotlin
//â˜† kotlin-coroutines-core-jvm.jar 
//â˜† CoroutineContext.kt
package kotlinx.coroutines
public actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {
    val combined = coroutineContext + context
    val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined
    //â˜…1. å¦‚æœä¸Šä¸‹æ–‡ä¸­ä¸å­˜åœ¨ContinuationInterceptorç±»å‹çš„å…ƒç´ ï¼Œæ·»åŠ é»˜è®¤çš„çº¿ç¨‹è°ƒåº¦å™¨Dispatchers.Default
    return if (combined !== Dispatchers.Default && combined[ContinuationInterceptor] == null)
        debug + Dispatchers.Default else debug
}

//â˜† Cancellable.kt
package kotlinx.coroutines.intrinsics
//å¯åŠ¨åç¨‹
internal fun <R, T> (suspend (R) -> T).startCoroutineCancellable(
    receiver: R, completion: Continuation<T>, onCancellation: ((cause: Throwable) -> Unit)? = null) =
    runSafely(completion) {
        createCoroutineUnintercepted(receiver, completion)    //â˜…2. é‡æ–°åˆ›å»ºç»­ä½“å¯¹è±¡ï¼ˆSuspendLambdaå­ç±»å¯¹è±¡ï¼‰
            .intercepted()    //â˜…3. ä»åç¨‹ä¸Šä¸‹æ–‡ä¸­è·å–è°ƒåº¦å™¨æ‹¦æˆªåŸç»­ä½“ï¼Œå°†å…¶åŒ…è£…ä¸ºDispatchedContinuationç±»å‹
            .resumeCancellableWith(Result.success(Unit), onCancellation)  //â˜…4. å¯åŠ¨åç¨‹
    }

//â˜† DispatchedContinuation.kt
package kotlinx.coroutines.internal
internal class DispatchedContinuation<in T>(   //è°ƒåº¦å™¨ç»­ä½“åŒ…è£…ç±»
    @JvmField val dispatcher: CoroutineDispatcher,  //æŒæœ‰è°ƒåº¦å™¨å¯¹è±¡
    @JvmField val continuation: Continuation<T>     //æŒæœ‰åŸå§‹ç»­ä½“å¯¹è±¡
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {
    public fun <T> Continuation<T>.resumeCancellableWith(result: Result<T>, onCancellation: ((cause: Throwable) -> Unit)? = null): Unit = when (this) {
        //â˜…5. å¦‚æœç»­ä½“ç±»å‹æ˜¯DispatchedContinuationï¼Œè°ƒç”¨resumeCancellableWith()å¯åŠ¨åç¨‹
        is DispatchedContinuation -> resumeCancellableWith(result, onCancellation)
        else -> resumeWith(result)
    }
    inline fun resumeCancellableWith(result: Result<T>, noinline onCancellation: ((cause: Throwable) -> Unit)?) {
        val state = result.toState(onCancellation)
        if (dispatcher.isDispatchNeeded(context)) {   //â˜…6. åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ‡æ¢çº¿ç¨‹
            _state = state
            resumeMode = MODE_CANCELLABLE
            dispatcher.dispatch(context, this)    //â˜…7. åˆ‡æ¢çº¿ç¨‹åå¼€å§‹æ‰§è¡Œåç¨‹ä»£ç 
        } else {
            executeUnconfined(state, MODE_CANCELLABLE) {
                if (!resumeCancelled(state)) {
                    resumeUndispatchedWith(result)
                }
            }
        }
    }
}
```

## 2.2 ç¬¬äºŒæ¬¡çº¿ç¨‹è°ƒåº¦ï¼šåˆ‡æ¢çº¿ç¨‹æ‰§è¡Œå¼‚æ­¥æŒ‚èµ·å‡½æ•°

åœ¨[ã€Škotlinåç¨‹ç¡¬æ ¸è§£è¯»(3. suspendæŒ‚èµ·å‡½æ•°&æŒ‚èµ·å’Œæ¢å¤çš„å®ç°åŸç†)ã€‹](https://openxu.blog.csdn.net/article/details/117000039)ä¸€æ–‡ä¸­è®²è§£äº†æ€æ ·è‡ªå®šä¹‰å¼‚æ­¥æŒ‚èµ·å‡½æ•°ï¼Œè¦æƒ³æŒ‚èµ·å‡½æ•°ç›¸å¯¹äºåç¨‹å¼‚æ­¥æ‰§è¡Œï¼Œæœ‰ä¸¤ç§æ–¹å¼ï¼š

```kotlin
//æ–¹å¼1ï¼šè°ƒç”¨suspendCancellableCoroutine()å®šä¹‰æŒ‚èµ·å‡½æ•°ï¼Œç›´æ¥åœ¨å‡½æ•°ä¸­å¼€å¯Threadï¼Œåœ¨å­çº¿ç¨‹ä¸­æ‰§è¡Œå‡½æ•°ä½“
suspend fun getUser(): User = suspendCancellableCoroutine {
    continuation ->
    Thread { //ä¹Ÿå¯ä»¥é€šè¿‡çº¿ç¨‹æ± å¼‚æ­¥æ‰§è¡Œï¼Œretrofitå¯¹åç¨‹çš„æ”¯æŒç½‘ç»œè¯·æ±‚å°±æ˜¯é€šè¿‡okhttpçš„å¼‚æ­¥è¯·æ±‚å®ç°çš„ï¼ˆçº¿ç¨‹æ± ï¼‰
        ...
        continuation.resume(User("openXu"))
    }.start()
}

//æ–¹å¼2ï¼šè°ƒç”¨withContext(...)å®šä¹‰æŒ‚èµ·å‡½æ•°ï¼Œé€šè¿‡ä¼ å…¥è°ƒåº¦å™¨ä¸Šä¸‹æ–‡å®ç°çº¿ç¨‹åˆ‡æ¢
suspend fun getUser(): User = withContext(Dispatchers.IO) {
    ...
    User("openXu")   //å­åç¨‹è¿”å›å€¼
}
```

ç¬¬ä¸€ç§æ–¹å¼æ²¡ä»€ä¹ˆè¯´çš„ï¼Œä¸ç®¡æ˜¯é€šè¿‡çº¿ç¨‹æ± è¿˜æ˜¯Threadï¼Œéƒ½èƒ½å°†å‡½æ•°ä½“åˆ‡æ¢åˆ°å­çº¿ç¨‹æ‰§è¡Œã€‚ç¬¬äºŒç§æ–¹å¼`withContext(Dispatchers.IO){}`å½“åˆ¤æ–­ä¼ å…¥çš„è°ƒåº¦å™¨å’Œçˆ¶åç¨‹è°ƒåº¦å™¨ä¸åŒæ—¶ï¼Œä¼šåˆ›å»ºä¸€ä¸ª`DispatchedCoroutine`ç±»å‹çš„å­åç¨‹ï¼Œå‡½æ•°ä½“å°±æ˜¯å­åç¨‹çš„æŒ‚èµ·ä»£ç å—ï¼Œå½“æ‰§è¡Œå­åç¨‹æ—¶ï¼Œåˆä¼š**èµ°2.1çš„æ­¥éª¤åˆ‡æ¢åˆ°æŒ‡å®šçº¿ç¨‹å¼€å§‹æ‰§è¡Œå­åç¨‹ä»£ç **ï¼š

```kotlin
public suspend fun <T> withContext(
    context: CoroutineContext,       //åç¨‹ä¸Šä¸‹æ–‡ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¼ é€’ä¸€ä¸ªè°ƒåº¦å™¨
    block: suspend CoroutineScope.() -> T   //å­åç¨‹ä»£ç å—
): T {
    ...
    return suspendCoroutineUninterceptedOrReturn sc@ { uCont ->
        val oldContext = uCont.context         //çˆ¶åç¨‹çš„ä¸Šä¸‹æ–‡
        val newContext = oldContext + context  //çˆ¶åç¨‹ä¸Šä¸‹æ–‡+æ–°çš„è°ƒåº¦å™¨
        ...
        if (newContext === oldContext) {
            //æ–°çš„ä¸Šä¸‹æ–‡å’Œçˆ¶åç¨‹ä¸Šä¸‹æ–‡åœ°å€ç›¸åŒï¼Œä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œå°†åˆ›å»ºä¸€ä¸ªScopeCoroutineç±»å‹çš„å­åç¨‹
            val coroutine = ScopeCoroutine(newContext, uCont)
            return@sc coroutine.startUndispatchedOrReturn(coroutine, block)
        }
        // å¦‚æœä¼ å…¥çš„è°ƒåº¦å™¨å’Œçˆ¶åç¨‹è°ƒåº¦å™¨ç›¸åŒï¼Œä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œå°†åˆ›å»ºä¸€ä¸ªUndispatchedCoroutineç±»å‹ï¼ˆScopeCoroutineå­ç±»ï¼‰çš„å­åç¨‹
        if (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) {
            val coroutine = UndispatchedCoroutine(newContext, uCont)
            withCoroutineContext(newContext, null) {
                return@sc coroutine.startUndispatchedOrReturn(coroutine, block)
            }
        }
        //â˜…ä¸Šé¢ä¸¤ç§ä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹çš„å°±æ²¡å¿…è¦è·Ÿè¸ªäº†ã€‚å½“è°ƒåº¦å™¨ä¸åŒæ—¶åˆ›å»ºä¸€ä¸ªDispatchedCoroutineç±»å‹çš„å­åç¨‹ï¼Œåˆ‡æ¢åˆ°æ–°çº¿ç¨‹æ‰§è¡Œå­åç¨‹ä»£ç å—ï¼ˆä¹Ÿå°±æ˜¯å‡½æ•°ä½“ï¼‰
        val coroutine = DispatchedCoroutine(newContext, uCont)
        coroutine.initParentJob()
        //â˜…â˜…â˜… æ¥2.1çš„startCoroutineCancellable()ï¼Œåˆ›å»ºå­SuspendLambdaç»­ä½“å¯¹è±¡ï¼Œç„¶ååŒ…è£…ä¸ºDispatchedContinuationç±»å‹ï¼Œæœ€ådispatcher.dispatch()åˆ‡æ¢åˆ°æ–°çº¿ç¨‹å¼€å§‹æ‰§è¡Œå‡½æ•°ä½“
        block.startCoroutineCancellable(coroutine, coroutine)   
        coroutine.getResult()
    }
}
```

## 2.3ç¬¬ä¸‰æ¬¡çº¿ç¨‹è°ƒåº¦ï¼šå¼‚æ­¥æŒ‚èµ·å‡½æ•°æ‰§è¡Œå®Œæ¯•åå°†å‡½æ•°æ‰§è¡Œç»“æœåˆ‡å›åç¨‹æ‰€åœ¨çº¿ç¨‹å¹¶æ¢å¤åç¨‹æ‰§è¡Œ

æ‰§è¡Œå¼‚æ­¥æŒ‚èµ·å‡½æ•°æ—¶åˆ‡æ¢åˆ°æ–°çš„åç¨‹æ‰§è¡Œå‡½æ•°æœ‰ä¸¤ç§æ–¹å¼ï¼Œå½“å‡½æ•°æ‰§è¡Œå®Œæ¯•åˆ‡å›åˆ°åç¨‹æ‰€åœ¨çº¿ç¨‹åŒæ ·æœ‰ä¸¤ç§æ–¹å¼ã€‚

å¯¹äºç¬¬ä¸€ç§åœ¨å‡½æ•°ä½“å†…é€šè¿‡çº¿ç¨‹æ± æˆ–è€…Threadçš„æ–¹å¼ï¼Œå½“å‡½æ•°æ‰§è¡Œå®Œæ¯•ä¼šè°ƒç”¨ç»­ä½“`continuation`çš„`resumeWith()`æ–¹æ³•æ¢å¤åç¨‹çš„æ‰§è¡Œï¼Œè€Œ`continuation`æ˜¯åç¨‹è¢«åŒ…è£…åçš„`DispatchedContinuation`ç±»å‹ï¼Œæ‰€ä»¥å°±æ˜¯è°ƒç”¨`DispatchedContinuation`çš„`resumeWith()`ã€‚

ç¬¬äºŒç§é€šè¿‡withContext()åˆ›å»ºäº†ä¸€ä¸ªå­åç¨‹ï¼Œæ ¹æ®[ã€Škotlinåç¨‹ç¡¬æ ¸è§£è¯»(3. suspendæŒ‚èµ·å‡½æ•°&æŒ‚èµ·å’Œæ¢å¤çš„å®ç°åŸç†ã€‹](https://openxu.blog.csdn.net/article/details/117000039)ä¸€æ–‡ä¸­<2.5 æŒ‚èµ·ã€æ¢å¤å®ç°åŸç†æºç è§£è¯»>ï¼Œåç¨‹ä»£ç å—çš„ä»£ç ä¼šé€šè¿‡çŠ¶æ€æœºè¢«åˆ†ä¸ºå¤šä¸ªæ‰§è¡Œéƒ¨åˆ†æ”¾å…¥çš„`SuspendLambda.invokeSuspend()`å‡½æ•°ä¸­ï¼Œ`invokeSuspend()`åˆæ˜¯åœ¨å­åç¨‹çš„ç»­ä½“`BaseContinuationImpl.resumeWith()`ä¸­è°ƒç”¨çš„ï¼Œæ‰€ä»¥å­åç¨‹ä»£ç å—çš„è¿”å›å€¼å°†ä½œä¸ºæœ€åä¸€æ¬¡è°ƒç”¨`invokeSuspend()`å‡½æ•°çš„è¿”å›å€¼ï¼Œåœ¨`BaseContinuationImpl.resumeWith()`å‡½æ•°ä¸­è¿™ä¸ªè¿”å›å€¼å°†è¢«ä¼ é€’ç»™å­åç¨‹çš„`AbstractCoroutine.resumeWith()`å‡½æ•°ä½œä¸ºå­åç¨‹çš„è¿”å›å€¼ã€‚`withContext()`åˆ›å»ºçš„å­åç¨‹`DispatchedCoroutine`é‡å†™äº†`afterResume()`å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸­è°ƒç”¨çˆ¶åç¨‹çš„ç»­ä½“çš„`intercepted()`å‡½æ•°å†æ¬¡å°†çˆ¶åç¨‹ç»­ä½“åŒ…è£…ä¸º`DispatchedContinuation`ç±»å‹ï¼Œç„¶åè°ƒç”¨`resumeCancellableWith()`åˆ‡æ¢çº¿ç¨‹ï¼Œå°†æŒ‚èµ·å‡½æ•°çš„ç»“æœè¿”å›å¹¶æ¢å¤çˆ¶åç¨‹æ‰§è¡Œã€‚

```kotlin
//æ‰€æœ‰åç¨‹å¯¹è±¡çš„æŠ½è±¡çˆ¶ç±»
public abstract class AbstractCoroutine<in T>(protected val parentContext: CoroutineContext, active: Boolean = true) 
    : JobSupport(active), Job, Continuation<T>, CoroutineScope {
    public final override fun resumeWith(result: Result<T>) {
        val state = makeCompletingOnce(result.toState())   //å°è¯•è®¾ç½®å½“å‰åç¨‹çŠ¶æ€ä¸ºå·²å®Œæˆ
        if (state === COMPLETING_WAITING_CHILDREN) return
        afterResume(state)
    }
    protected open fun afterResume(state: Any?): Unit = afterCompletion(state) //afterCompletion()æ˜¯ä¸€ä¸ªç©ºå®ç°ï¼Œå› ä¸ºæ™®é€šçš„åç¨‹ä»£ç å—ä¸éœ€è¦è¿”å›å€¼
}

//withContext()åˆ›å»ºçš„è°ƒåº¦å™¨å­åç¨‹ç±»å‹
private class DispatchedCoroutine<in T>(
    context: CoroutineContext,   //çˆ¶åç¨‹ä¸Šä¸‹æ–‡+æ–°çš„è°ƒåº¦å™¨
    uCont: Continuation<T>       //â˜… æŒæœ‰çˆ¶åç¨‹çš„ç»­ä½“å¯¹è±¡ï¼Œç”¨äºå°†å­åç¨‹çš„æ‰§è¡Œç»“æœåˆ‡å›åˆ°çˆ¶åç¨‹çš„æ‰§è¡Œçº¿ç¨‹
) : ScopeCoroutine<T>(context, uCont) {
    ...
    //é‡å†™afterResume()å‡½æ•°ï¼Œå› ä¸ºwithContext()å‡½æ•°æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œå­åç¨‹ä»£ç å—çš„è¿”å›å€¼å°†ä½œä¸ºwithContext()å‡½æ•°çš„è¿”å›å€¼
    override fun afterResume(state: Any?) {
        // é€šè¿‡çˆ¶åç¨‹çš„ç»­ä½“ï¼Œåˆ‡æ¢å›çˆ¶åç¨‹æ‰€åœ¨çš„çº¿ç¨‹æ¢å¤çˆ¶åç¨‹æ‰§è¡Œ
        uCont
            .intercepted()  //â˜… è°ƒç”¨çˆ¶åç¨‹çš„ç»­ä½“çš„intercepted()ï¼Œè¿™ä¸ªå‡½æ•°å°†ä»çˆ¶åç¨‹ä¸Šä¸‹æ–‡ä¸­è·å–çˆ¶åç¨‹çš„è°ƒåº¦å™¨ï¼Œå¹¶å°†çˆ¶åç¨‹ç»­ä½“å†æ¬¡åŒ…è£…ä¸ºDispatchedContinuationç±»å‹
            .resumeCancellableWith(recoverResult(state, uCont))  //æ¢å¤çˆ¶åç¨‹æ‰§è¡Œï¼Œå¹¶å°†å­åç¨‹çš„è¿”å›å€¼ä¼ ç»™çˆ¶åç¨‹ï¼ˆä¹Ÿå°±æ˜¯withContext()å‡½æ•°çš„è¿”å›å€¼ï¼‰
    }
}
```

## 2.4 å°ç»“

é€šè¿‡ä¸Šé¢çš„å¯¹åç¨‹æ‰§è¡Œè¿‡ç¨‹ä¸­çš„3æ¬¡çº¿ç¨‹åˆ‡æ¢çš„æºç è·Ÿè¸ªï¼Œå‘ç°åç¨‹ä¸­çš„çº¿ç¨‹åˆ‡æ¢éƒ½ä¼šè°ƒç”¨`DispatchedContinuation`çš„`resumeWith()`æˆ–è€…`resumeCancellableWith()`å‡½æ•°ï¼Œ**é€šè¿‡è°ƒåº¦å™¨å¯¹è±¡dispatcher.isDispatchNeeded()åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œå¦‚æœéœ€è¦åˆ™è°ƒç”¨dispatcher.dispatch()å®ç°çº¿ç¨‹åˆ‡æ¢ï¼Œç„¶ååœ¨åˆ‡æ¢åçš„çº¿ç¨‹ä¸Šæ‰§è¡ŒRunnableè°ƒç”¨åŸç»­ä½“çš„resumeWith()ä»è€Œè§¦å‘invokeSuspend()å¯åŠ¨æˆ–æ¢å¤åç¨‹æ‰§è¡Œï¼š**

```kotlin
//è°ƒåº¦å™¨ç»­ä½“ï¼Œåç¨‹çš„ç¬¬3å±‚åŒ…è£…ï¼ˆç¬¬ä¸€å±‚æ˜¯åç¨‹å¯¹è±¡ï¼Œç¬¬äºŒå±‚æ˜¯SuspendLambdaï¼‰
internal class DispatchedContinuation<in T>(
    @JvmField val dispatcher: CoroutineDispatcher,
    @JvmField val continuation: Continuation<T>  //åŸç»­ä½“å¯¹è±¡ï¼Œå¯èƒ½æ˜¯SuspendLambdaï¼Œä¹Ÿå¯èƒ½æ˜¯DispatchedContinuation
) : DispatchedTask<T>(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation<T> by continuation {
    /**
     * é‡å†™äº†ç»­ä½“çš„resumeWith()å‡½æ•°ï¼Œåœ¨åŸæœ‰çš„æ¢å¤åç¨‹æ‰§è¡Œçš„åŸºç¡€ä¸Šå¢åŠ äº†çº¿ç¨‹åˆ‡æ¢åŠŸèƒ½ï¼Œè¯¥æ–¹æ³•ä¼šä»æŒ‚èµ·å‡½æ•°æ‰§è¡Œçº¿ç¨‹ åˆ‡å›åˆ° åç¨‹è°ƒåº¦çº¿ç¨‹
     * resumeWith()ï¼šæŒ‚èµ·å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œé€šè¿‡è°ƒç”¨resumeç³»åˆ—å‡½æ•°æ¢å¤å‡½æ•°æ‰§è¡Œç»“æœæˆ–è€…å¼‚å¸¸æœ€ç»ˆéƒ½ä¼šè°ƒç”¨åˆ°è¯¥æ–¹æ³•ï¼Œæ¢å¤åç¨‹æ‰§è¡Œ
     * resumeCancellableWith()ï¼šé€šå¸¸æ˜¯å¯åŠ¨åç¨‹ã€å­åç¨‹æ‰§è¡Œå®Œæ¯•è¿”å›ç»“æœæ¢å¤çˆ¶åç¨‹æ‰§è¡Œæ—¶è°ƒç”¨
     * resumeCancellableWith()å’ŒresumeWith()å®ç°å·®ä¸å¤šï¼Œå°±å¤šäº†ä¸€ä¸ªæ˜¯å¦cancelçš„åˆ¤æ–­ï¼Œè¿™é‡Œå°±ä¸ç²˜è´´ä»£ç äº†
     */
    override fun resumeWith(result: Result<T>) {
        ...
        //â˜…1. åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ‡æ¢çº¿ç¨‹
        if (dispatcher.isDispatchNeeded(context)) {
            _state = state
            resumeMode = MODE_ATOMIC
            //â˜…2. è°ƒåº¦å™¨åˆ‡æ¢çº¿ç¨‹ï¼Œç„¶åæ‰§è¡Œthisï¼Œä¹Ÿå°±æ˜¯åœ¨åˆ‡æ¢åçš„çº¿ç¨‹ä¸Šæ‰§è¡Œä¸‹é¢çš„run()æ–¹æ³•
            dispatcher.dispatch(context, this)
        } else {
            //ä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹æ—¶ï¼Œç›´æ¥è°ƒç”¨åŸç»­ä½“çš„resumeWith()
            executeUnconfined(state, MODE_ATOMIC) {
                withCoroutineContext(this.context, countOrElement) {
                    continuation.resumeWith(result)
                }
            }
        }
    }
    
    //thiså°±æ˜¯ä»£ç†ç»­ä½“
    override val delegate: Continuation<T>
        get() = this
    
    //DispatchedTaskå®ç°äº†Runnableï¼ŒDispatchedContinuationç»§æ‰¿äº†å®ƒï¼Œç¬¬2æ­¥åˆ‡æ¢çº¿ç¨‹æ—¶ä¼ å…¥çš„thiså°±è¡¨ç¤ºåœ¨æŒ‡å®šçš„çº¿ç¨‹æ‰§è¡Œrunæ–¹æ³•ï¼ˆå·²ç»åˆ‡æ¢çº¿ç¨‹åæ‰§è¡Œï¼‰
    public final override fun run() {
        ...
        val delegate = delegate as DispatchedContinuation<T>
        val continuation = delegate.continuation  //åŸç»­ä½“å¯¹è±¡
        val context = continuation.context
        val state = takeState() // NOTE: Must take state in any case, even if cancelled
        withCoroutineContext(context, delegate.countOrElement) {
            val exception = getExceptionalResult(state)
            val job = if (exception == null && resumeMode.isCancellableMode) context[Job] else null
            //â˜…3. åœ¨åˆ‡æ¢åçš„çº¿ç¨‹ä¸­è°ƒç”¨åŸç»­ä½“continuationçš„resumeWith()ä»è€Œè§¦å‘invokeSuspend()å¯åŠ¨æˆ–æ¢å¤åç¨‹æ‰§è¡Œ
            if (job != null && !job.isActive) {
                val cause = job.getCancellationException()
                cancelCompletedResult(state, cause)
                continuation.resumeWithStackTrace(cause)   //
            } else {
                if (exception != null) {
                    continuation.resumeWithException(exception) //
                } else {
                    continuation.resume(getSuccessfulResult(state))//
                }
            }
        }
        ...
    }
    
}
```

# 3. è°ƒåº¦å™¨å®ç°çº¿ç¨‹åˆ‡æ¢çš„åŸç†

## 3.1 è°ƒåº¦å™¨çš„å¹³å°å®ç°

åç¨‹åº“ä¸­æœ‰ä¸€ä¸ª`Dispatchers`å•ä¾‹å¯¹è±¡ï¼Œè¯¥å¯¹è±¡åŒ…å«åç¨‹çš„4ä¸­è°ƒåº¦å™¨æˆå‘˜å˜é‡ï¼Œè¿™äº›å˜é‡éƒ½æ˜¯åç¨‹è°ƒåº¦å™¨`CoroutineDispatcher`åŠå…¶å­ç±»çš„å¯¹è±¡ï¼š

```kotlin
//Dispatcherså•ä¾‹å¯¹è±¡ï¼Œå®ƒåŒ…å«4ä¸­è°ƒåº¦å™¨å¯¹è±¡
public actual object Dispatchers {
    //4ç§è°ƒåº¦å™¨ï¼Œéƒ½æ˜¯CoroutineDispatcherçš„å­ç±»å¯¹è±¡ï¼ŒCoroutineDispatcheræ˜¯é€šè¿‡ç»­ä½“æ‹¦æˆªå™¨å®ç°çš„ã€‚actualè¡¨ç¤ºä¸å¹³å°ç›¸å…³ï¼Œä¸åŒå¹³å°å®ç°ä¸åŒ
    public actual val Default: CoroutineDispatcher = createDefaultDispatcher()
    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher
    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined
    public val IO: CoroutineDispatcher = DefaultScheduler.IO
}
```

æ³¨æ„è§‚å¯Ÿé™¤äº†`IO`å¤–ï¼Œ`Default`ã€`Main`ã€`Unconfined`éƒ½è¢«`actual`ä¿®é¥°ï¼Œ`actual`æ˜¯kotlinçš„å…³é”®å­—ï¼Œè¡¨ç¤ºå¹³å°ç›¸å…³çš„å®ç°ã€‚æˆ‘ä»¬çŸ¥é“kotlinæ˜¯ä¸€ä¸ªè·¨å¹³å°çš„è¯­è¨€ï¼Œå®ƒå¯ä»¥è¢«ç¼–è¯‘æˆå„ç§å¹³å°çš„å¯æ‰§è¡ŒæŒ‡ä»¤ï¼Œæ¯”å¦‚Jvmã€Androidã€jsã€Nativeã€iOSã€Linuxã€Windowsç­‰ï¼Œåœ¨ä¸åŒçš„å¹³å°ä¸Šå®ç°æœ‰äº›APIéš¾å…ä¼šæœ‰å·®å¼‚ã€‚æ¯”å¦‚ä¸€èˆ¬æƒ…å†µä¸‹å¸¦æœ‰UIç›¸å…³çš„å¹³å°æ‰ä¼šå¼ºè°ƒä¸»çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹ä¸“é—¨ç”¨äºåˆ·æ–°UIä¸èƒ½è¿›è¡Œè€—æ—¶æ“ä½œå¯¼è‡´UIå¡é¡¿ï¼Œè€Œå…¶ä»–å¹³å°å¦‚æ™®é€šjvmä¸Šä¸å¼ºè°ƒä¸»çº¿ç¨‹ï¼ˆä¹Ÿå°±ä¸éœ€è¦ä¸»çº¿ç¨‹è°ƒåº¦å™¨ï¼‰ï¼Œæ‰€ä»¥å¯¹äº`Main`è°ƒåº¦å™¨çš„å®ç°åœ¨ä¸åŒå¹³å°ä¸Šå®ç°æ˜¯ä¸ä¸€æ ·çš„ã€‚å¦‚æœæˆ‘ä»¬åœ¨æ™®é€šjvmå¹³å°ç¨‹åºä¸­ä½¿ç”¨`Dispatchers.Main`ä¼šæŠ›å¼‚å¸¸ï¼Œè¯´**ç¼ºå°‘å…·æœ‰Mainè°ƒåº¦å™¨çš„æ¨¡å—ï¼Œéœ€è¦æ·»åŠ æä¾›Mainè°ƒåº¦å™¨çš„ä¾èµ–ï¼Œæ¯”å¦‚kotlinx-coroutines-androidæ‰©å±•åŒ…**ï¼š

```kotlin
fun main(){
    runBlocking {
        //æ™®é€šjvmå¹³å°æ²¡æœ‰Mainè°ƒåº¦å™¨ï¼Œæµ‹è¯•ä¸­å¯ä»¥æ·»åŠ kotlinx-coroutines-test.jarä¾èµ–
        withContext(Dispatchers.Main){}  
    }
}
è¿è¡Œç»“æœï¼š
Exception in thread "main" java.lang.IllegalStateException: Module with the Main dispatcher is missing. Add dependency providing the Main dispatcher, e.g. 'kotlinx-coroutines-android' and ensure it has the same version as 'kotlinx-coroutines-core'
...
```

å…¶å®ä¸Šé¢ç¨‹åºæŠ¥é”™çš„æ ¹æœ¬åŸå› æ˜¯**å½“å‰å¹³å°ç¯å¢ƒä¸­æ²¡æœ‰æ·»åŠ ç›¸å…³çš„jaråŒ…ä¾èµ–ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶æ²¡æœ‰åŠ è½½åˆ°ç›¸åº”çš„å®ç°ç±»ï¼Œä»è€Œåœ¨æŸäº›åŠŸèƒ½å‡½æ•°æ‰§è¡Œæ—¶æŠ›å¼‚å¸¸**ã€‚åœ¨ç¨‹åºä¸­ä½¿ç”¨`Dispatchers.Main`å®é™…ä¸Šæ˜¯`MainDispatcherLoader`å•ä¾‹ä¸­çš„`dispatcher`å˜é‡ï¼Œå®ƒæ˜¯é€šè¿‡`loadMainDispatcher()`å‡½æ•°èµ‹å€¼çš„ï¼Œè¿™ä¸ªå‡½æ•°ä¼šä»å½“å‰å¹³å°ç¯å¢ƒä¸­é€šè¿‡`ServiceLoader`åŠ è½½æ‰€æœ‰`MainDispatcherFactory`ä¸»è°ƒåº¦å™¨å·¥å‚çš„å®ç°ç±»ï¼Œè¿™äº›å®ç°ç±»é€šå¸¸åœ¨åç¨‹çš„å„ä¸ªå¹³å°çš„æ‰©å±•åŒ…ä¸­ï¼Œæ¯”å¦‚Androidå¹³å°çš„`kotlinx-coroutines-android.jar`æ‰©å±•åŒ…ä¸­çš„`AndroidDispatcherFactory`ï¼Œ  è€Œå½“å‰æ™®é€šjvmæµ‹è¯•ç¨‹åºæ¨¡å—å¹¶æ²¡æœ‰æ·»åŠ æ‰©å±•åŒ…ä¾èµ–ï¼ˆå…¶å®æ·»åŠ äº†ä¹Ÿæ²¡ç”¨ï¼Œandroidä¸­ç‰¹æœ‰çš„å†…å®¹æ¯”å¦‚Handleråœ¨æ™®é€šjvmä¸­å¹¶ä¸å­˜åœ¨ï¼‰ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸»è°ƒåº¦å™¨`Dispatchers.Main`æ—¶å°†è¿”å›ä¸€ä¸ª`MissingMainCoroutineDispatcher`å¯¹è±¡ï¼Œå½“ç¨‹åºè¿è¡Œæ—¶æ‰§è¡Œåç¨‹åˆ‡æ¢çº¿ç¨‹æ—¶è°ƒç”¨`isDispatchNeeded()`ã€`dispatch()`ç­‰å‡½æ•°å°±ä¼šæŠ›å¼‚å¸¸ï¼š

```kotlin
//â˜† kotlinx-coroutines-core-jvm.jar
//â˜† è°ƒåº¦å™¨å•ä¾‹
package kotlinx.coroutines
public actual object Dispatchers {
    ...
    //ä¸»çº¿ç¨‹è°ƒåº¦å™¨å¯¹è±¡ï¼Œæ˜¯MainCoroutineDispatcherç±»å‹çš„
    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher
}

//â˜† ä¸»è°ƒåº¦å™¨åŠ è½½å·¥å…·ç±»
package kotlinx.coroutines.internal
internal object MainDispatcherLoader {
    //è·å–ç³»ç»Ÿå±æ€§kotlinx.coroutines.fast.service.loaderï¼Œå½“å‰å¹³å°ä¸ŠæœåŠ¡å¿«é€ŸåŠ è½½å™¨æ˜¯å¦å¯ç”¨
    private val FAST_SERVICE_LOADER_ENABLED = systemProp(FAST_SERVICE_LOADER_PROPERTY_NAME, true)    
    //ä¸»è°ƒåº¦å™¨å¯¹è±¡
    val dispatcher: MainCoroutineDispatcher = loadMainDispatcher()   
    //â˜…â˜…â˜… åŠ è½½ä¸»è°ƒåº¦å™¨ï¼Œé€šè¿‡åå°„åŠ è½½ä¸»è°ƒåº¦å™¨å·¥å‚åˆ›å»ºä¸»è°ƒåº¦å™¨å¯¹è±¡ï¼Œå¦‚æœä¸å­˜åœ¨å·¥å‚ï¼Œåˆ™åˆ›å»ºé”™è¯¯è°ƒåº¦å™¨MissingMainCoroutineDispatcher
    private fun loadMainDispatcher(): MainCoroutineDispatcher {
       val factories = if (FAST_SERVICE_LOADER_ENABLED) {
                /*
                 * é€šè¿‡åå°„åŠ è½½kotlinx.coroutines.android.AndroidDispatcherFactoryï¼ˆkotlinx-coroutines-android.jarï¼‰
                 * æˆ–è€…kotlinx.coroutines.test.internal.TestMainDispatcherFactoryï¼ˆkotlinx-coroutines-test.jarï¼‰
                 * å¹¶åˆ›å»ºå¯¹è±¡æ”¾å…¥å·¥å‚å¯¹è±¡é›†åˆä¸­ï¼Œä¾›ä¸‹é¢é€šè¿‡å·¥å‚åˆ›å»ºä¸»è°ƒåº¦å™¨ï¼Œå¦‚æœæ²¡æœ‰ä¾èµ–å¯¹åº”çš„jarï¼Œé›†åˆä¸ºç©º
                 */
                FastServiceLoader.loadMainDispatcherFactory()
            } else {
                //ServiceLoaderç”¨äºä»å½“å‰å¹³å°ç¯å¢ƒä¸­åŠ è½½æŒ‡å®šæ¥å£æˆ–è€…æŠ½è±¡ç±»çš„æ‰€æœ‰å®ç°ç±»ï¼Œä¹Ÿå°±æ˜¯MainDispatcherFactoryçš„å®ç°ç±»
                ServiceLoader.load(
                        MainDispatcherFactory::class.java,
                        MainDispatcherFactory::class.java.classLoader
                ).iterator().asSequence().toList()
            }
         //å¦‚æœæ²¡æœ‰åŠ è½½åˆ°ä¸»è°ƒåº¦å™¨å·¥å‚ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªMissingMainCoroutineDispatcherå¯¹è±¡è¿”å›
         factories.maxBy { it.loadPriority }?.tryCreateDispatcher(factories)
                ?: createMissingDispatcher()
    }
}

//â˜† ä¸»è°ƒåº¦å™¨ä¸¢å¤±çš„æƒ…å†µä¸‹åˆ›å»ºçš„è°ƒåº¦å™¨ç±»å‹ï¼Œè°ƒç”¨è¯¥è°ƒåº¦å™¨å‡½æ•°æ—¶ä¼šthrowå¼‚å¸¸
private class MissingMainCoroutineDispatcher(
    private val cause: Throwable?,
    private val errorHint: String? = null
) : MainCoroutineDispatcher(), Delay {
    ...
    override fun isDispatchNeeded(context: CoroutineContext): Boolean =
        missing()  //â˜…æŠ›å¼‚å¸¸
    override fun dispatch(context: CoroutineContext, block: Runnable) =
        missing()  //â˜…æŠ›å¼‚å¸¸
    private fun missing(): Nothing {
        if  (cause == null) {
            throwMissingMainDispatcherException()
        } else {
            val message = "Module with the Main dispatcher had failed to initialize" + (errorHint?.let { ". $it" } ?: "")
            throw IllegalStateException(message, cause)
        }
    }
}

//â˜† kotlinx-coroutines-android.jar
//â˜† åç¨‹çš„androidæ‰©å±•åŒ…ä¸­å¯¹ä¸»è°ƒåº¦å™¨å·¥å‚çš„å®ç°
internal class AndroidDispatcherFactory : MainDispatcherFactory {
    override fun createDispatcher(allFactories: List<MainDispatcherFactory>) =
        HandlerContext(Looper.getMainLooper().asHandler(async = true))
    ...
}
```

## 3.2 Androidå¹³å°ä¸‹çš„è°ƒåº¦å™¨å®ç°

ä¸Šé¢è¯´è¿‡ï¼Œåç¨‹ä¸­çº¿ç¨‹è°ƒåº¦æ—¶éƒ½ä¼šè°ƒç”¨`CoroutineDispatcher`çš„ `isDispatchNeeded()`å’Œ`dispatch()`ä¸¤ä¸ªå‡½æ•°ï¼Œ `isDispatchNeeded()`ç”¨äºåˆ¤æ–­å½“å‰çº¿ç¨‹å’Œè°ƒåº¦å™¨çº¿ç¨‹æ˜¯å¦ç›¸åŒï¼Œå¦‚æœä¸åŒåˆ™è°ƒç”¨`dispatch()`è¿›è¡Œçº¿ç¨‹åˆ‡æ¢ï¼Œç„¶ååœ¨åˆ‡æ¢åçš„çº¿ç¨‹æ‰§è¡ŒRunnableï¼ˆè§¦å‘åŸç»­ä½“çš„`invokeSuspend()`ï¼‰ã€‚æ‰€ä»¥ç ”ç©¶æŸç§è°ƒåº¦å™¨å°±çœ‹å®ƒçš„è¿™ä¸¤ä¸ªå‡½æ•°æ˜¯æ€ä¹ˆå®ç°çš„ã€‚

### 3.2.1 Dispatchers.Default

```kotlin
//â˜† kotlinx-coroutines-core-jvm.jar
public actual object Dispatchers {
    /**
     * æ‰€æœ‰æ ‡å‡†åç¨‹æ„å»ºå™¨å¦‚launchã€asyncç­‰åˆ›å»ºçš„åç¨‹å¦‚æœæ²¡æœ‰æŒ‡å®šè°ƒåº¦å™¨ï¼Œå°†ä½¿ç”¨é»˜è®¤çš„Defaultè°ƒåº¦å™¨
     * å®ƒç”±JVMä¸Šçš„å…±äº«çº¿ç¨‹æ± æä¾›æ”¯æŒã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ­¤è°ƒåº¦å™¨ä½¿ç”¨çš„æœ€å¤§å¹¶è¡Œçº§åˆ«ç­‰äºCPUå†…æ ¸æ•°ï¼Œä½†è‡³å°‘ä¸ºä¸¤ä¸ªï¼›
     * å¹¶è¡Œçº§åˆ«Xä¿è¯åœ¨è¿™ä¸ªè°ƒåº¦ç¨‹åºä¸­å¹¶è¡Œæ‰§è¡Œçš„ä»»åŠ¡ä¸è¶…è¿‡Xä¸ª
     */
    public actual val Default: CoroutineDispatcher = createDefaultDispatcher()
}

//systemProp()è°ƒç”¨System.getProperty(propertyName) è·å–å½“å‰ç³»ç»Ÿå¹³å°çš„æŸä¸ªå±æ€§ï¼Œå±æ€§å€¼å¯é€šè¿‡System.setProperty(key, value)è®¾ç½®
internal val useCoroutinesScheduler = systemProp("kotlinx.coroutines.scheduler").let { value ->
    when (value) {
        null, "", "on" -> true  //jvmå¹³å°ä¸Šè¯¥å±æ€§å€¼é»˜è®¤ä¸ºnullï¼Œæ‰€ä»¥è¿™é‡Œä¼šè¿”å›trueï¼Œè¡¨ç¤ºä½¿ç”¨kotlinå®ç°çš„é»˜è®¤è°ƒåº¦å™¨
        "off" -> false
        else -> error("System property '$COROUTINES_SCHEDULER_PROPERTY_NAME' has unrecognized value '$value'")
    }
}
//â˜… åˆ›å»ºé»˜è®¤è°ƒåº¦å™¨ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼šDefaultScheduler(jvmå¹³å°é»˜è®¤) æˆ–è€… CommonPool
internal actual fun createDefaultDispatcher(): CoroutineDispatcher =
    if (useCoroutinesScheduler) DefaultScheduler else CommonPool
```

`Dispatchers.Default`çš„å®ç°æœ‰2ç§ï¼Œç¬¬ä¸€ç§æ˜¯`DefaultScheduler`ï¼Œè¿˜æœ‰ä¸€ç§`CommonPool`ã€‚è¿™ä¸¤ç§è°ƒåº¦å™¨å•ä¾‹å¯¹è±¡éƒ½æ˜¯`ExecutorCoroutineDispatcher`çš„å­ç±»å¯¹è±¡ï¼Œéƒ½æ˜¯åŸºäºçº¿ç¨‹æ± å®ç°çš„ã€‚å½“ç³»ç»Ÿå±æ€§`kotlinx.coroutines.scheduler`çš„å€¼ä¸ºoffæ—¶ï¼Œä¼šä½¿ç”¨`CommonPool`ï¼Œä½†æ˜¯è¿™ä¸ªç³»ç»Ÿå±æ€§å¦‚æœä¸è®¾ç½®çš„è¯é»˜è®¤æ˜¯nullï¼Œæ‰€ä»¥`DefaultScheduler`æ›´å¸¸ç”¨ã€‚

```kotlin
CoroutineDispatcher   //åç¨‹è°ƒåº¦å™¨
    |--ExecutorCoroutineDispatcher //çº¿ç¨‹æ± åç¨‹è°ƒåº¦å™¨æŠ½è±¡ç±»ï¼Œç»´æŠ¤äº†ä¸€ä¸ªçº¿ç¨‹æ± Executorå¯¹è±¡ï¼Œå…·ä½“ä½¿ç”¨ä»€ä¹ˆæ ·çš„çº¿ç¨‹æ± éœ€è¦å®ç°ç±»åˆ›å»º
    |      |--ExperimentalCoroutineDispatcher //å®éªŒæ€§çš„åç¨‹è°ƒåº¦å™¨ï¼šæ ¹æ®æŒ‡å®šçš„å¹¶å‘æ•°å’Œæœ€å¤§çº¿ç¨‹æ•°åˆ›å»ºCoroutineSchedulerç±»å‹çš„çº¿ç¨‹æ± 
    |      |      |--DefaultScheduler   //â˜… kotlinå®ç°çš„é»˜è®¤è°ƒåº¦å™¨å•ä¾‹å¯¹è±¡ï¼ˆä»»åŠ¡æŠ¢å å¼æé«˜CPUåˆ©ç”¨ç‡ï¼‰
    |      |
    |      |
    |      |--CommonPool                //â˜… é€šç”¨è°ƒåº¦å™¨å•ä¾‹å¯¹è±¡ï¼ˆä»»åŠ¡æ‹†åˆ†å¼æé«˜CPUåˆ©ç”¨ç‡ï¼‰
    |      |
    |      |--LimitingDispatcher         //é™åˆ¶è°ƒåº¦å™¨
    |      |      |--DefaultScheduler.IO //â˜… IOè°ƒåº¦å™¨å•ä¾‹å¯¹è±¡ï¼Œè¯¦è§[3.2.4]
```

#### CommonPoolï¼ˆjavaä»»åŠ¡æ‹†åˆ†å¼çº¿ç¨‹æ± è°ƒåº¦å™¨ï¼‰

`CommonPool`åç¨‹è°ƒåº¦å™¨æ˜¯é€šè¿‡çº¿ç¨‹æ± å®ç°çš„ï¼Œå®ƒæ²¡æœ‰é‡å†™çˆ¶ç±»çš„`isDispatchNeeded()`å‡½æ•°ï¼Œé»˜è®¤è¿”å›trueè¡¨ç¤ºéœ€è¦åˆ‡æ¢çº¿ç¨‹ã€‚`dispatch()`å°†ä»»åŠ¡`Runnable`æäº¤åˆ°ä¸€ä¸ª`ForkJoinPool`ç±»å‹çš„ç‰¹æ®Šçº¿ç¨‹æ± ã€‚`ForkJoinPool`æ˜¯åœ¨jdk7å¼•å…¥çš„å¹¶å‘åº“ç±»ï¼Œå®ƒå¯ä»¥**å°†ä¸€ä¸ªä»»åŠ¡æ‹†åˆ†ä¸ºå¤šä¸ªâ€œå°ä»»åŠ¡â€ï¼ŒæŠŠå¤šä¸ªâ€œå°ä»»åŠ¡â€æ”¾åˆ°å¤šä¸ªå¤„ç†å™¨æ ¸å¿ƒä¸Šå¹¶è¡Œæ‰§è¡Œï¼Œå½“å¤šä¸ªâ€œå°ä»»åŠ¡â€æ‰§è¡Œå®Œæˆä¹‹åå†å°†è¿™äº›æ‰§è¡Œç»“æœåˆå¹¶èµ·æ¥ï¼Œå……åˆ†çš„åˆ©ç”¨å¤šCPUã€å¤šæ ¸CPUçš„ä¼˜åŠ¿ï¼Œä»è€Œæé«˜æ‰§è¡Œæ•ˆç‡ï¼š**ï¼ˆå…³äº`ForkJoinPool`è¿™é‡Œå°±ä¸æ·±å…¥äº†ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥å»ç ”ç©¶javaçš„çº¿ç¨‹å¹¶å‘ï¼‰

```kotlin
internal object CommonPool : ExecutorCoroutineDispatcher() {
    ...
    private fun getOrCreatePoolSync(): Executor =
        pool ?: createPool().also { pool = it }
    
    //â˜…â˜…â˜… åˆ›å»ºForkJoinPoolå¼çº¿ç¨‹æ± ï¼Œå®ƒæ˜¯ä¸€ç§æŠ¢å å¼ä»»åŠ¡è°ƒåº¦çš„çº¿ç¨‹æ± 
    private fun createPool(): ExecutorService {
        // å¦‚æœä¸å­˜åœ¨javaå®‰å…¨ç®¡ç†å™¨ï¼ˆandroidå¹³å°ä¸Šä¸ºnullï¼‰ï¼Œå°†è°ƒç”¨createPlainPool()åˆ›å»ºä¸€ä¸ªæ™®é€šçº¿ç¨‹æ± 
        if (System.getSecurityManager() != null) return createPlainPool()
        // ä¸‹é¢çš„ä»£ç é€šè¿‡åå°„åˆ›å»ºForkJoinPool
        val fjpClass = Try { Class.forName("java.util.concurrent.ForkJoinPool") }
            ?: return createPlainPool() 
        if (!usePrivatePool && requestedParallelism < 0) {
            Try { fjpClass.getMethod("commonPool")?.invoke(null) as? ExecutorService }
                ?.takeIf { isGoodCommonPool(fjpClass, it) }
                ?.let { return it }
        }
        Try { fjpClass.getConstructor(Int::class.java).newInstance(parallelism) as? ExecutorService }
            ?. let { return it }
        return createPlainPool()
    }
    //åˆ›å»ºæ™®é€šçº¿ç¨‹æ± 
    private fun createPlainPool(): ExecutorService {
        val threadId = AtomicInteger()
        return Executors.newFixedThreadPool(parallelism) {
            Thread(it, "CommonPool-worker-${threadId.incrementAndGet()}").apply { isDaemon = true }
        }
    }

    //â˜…â˜…â˜… æ²¡æœ‰é‡å†™isDispatchNeeded()å‡½æ•°ï¼Œé»˜è®¤è¿”å›trueï¼Œè¡¨ç¤ºéœ€è¦åˆ‡æ¢çº¿ç¨‹ã€‚å› ä¸ºä¸ç®¡ä¹‹å‰æ˜¯ä»€ä¹ˆçº¿ç¨‹ï¼Œåªè¦å°†ä»»åŠ¡æ‰”åˆ°çº¿ç¨‹æ± å°±éœ€è¦åˆ‡æ¢çº¿ç¨‹
    //public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
    //â˜…â˜…â˜… å°†Runnableæ‰”åˆ°çº¿ç¨‹æ± ä¸­ï¼Œå®ç°çº¿ç¨‹åˆ‡æ¢
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        try {
            (pool ?: getOrCreatePoolSync()).execute(wrapTask(block))
        } catch (e: RejectedExecutionException) {
            unTrackTask()
            DefaultExecutor.enqueue(block)
        }
    }
   ...
}
```

#### DefaultSchedulerï¼ˆkotlinå®ç°çš„ä»»åŠ¡æŠ¢å å¼çº¿ç¨‹æ± è°ƒåº¦å™¨ï¼‰

ä¸Šé¢è¯´è¿‡åœ¨kotlinåç¨‹ä¸­ä½¿ç”¨`Dispatchers.Default`ï¼Œé»˜è®¤æ˜¯ä½¿ç”¨`DefaultScheduler`ã€‚`DefaultScheduler`å’Œ`CommonPool`çš„å®ç°æ˜¯å·®ä¸å¤šçš„ï¼Œéƒ½ç»´æŠ¤äº†ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œä¸åŒçš„æ˜¯ä½¿ç”¨çš„çº¿ç¨‹æ± ä¸ä¸€æ ·ï¼š

```kotlin
//é»˜è®¤è°ƒåº¦å™¨å¯¹è±¡ï¼Œç»§æ‰¿ExperimentalCoroutineDispatcher
internal object DefaultScheduler : ExperimentalCoroutineDispatcher()

//å®éªŒæ€§çš„åç¨‹è°ƒåº¦å™¨ï¼šå®ƒç»´æŠ¤äº†ä¸€ä¸ªCoroutineSchedulerç±»å‹çš„ä»»åŠ¡æŠ¢å å¼çº¿ç¨‹æ± å¯¹è±¡
public open class ExperimentalCoroutineDispatcher(private val corePoolSize: Int, private val maxPoolSize: Int,
    private val idleWorkerKeepAliveNs: Long, private val schedulerName: String = "CoroutineScheduler"
) : ExecutorCoroutineDispatcher() {
    public constructor(
        corePoolSize: Int = CORE_POOL_SIZE,  //çº¿ç¨‹å¹¶å‘æ•°ï¼Œé»˜è®¤ä¸º2
        maxPoolSize: Int = MAX_POOL_SIZE,    //çº¿ç¨‹æ± ä¸­æœ€å¤§çº¿ç¨‹æ•°
        schedulerName: String = DEFAULT_SCHEDULER_NAME) : this(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS, schedulerName)
    
    //â˜…â˜…â˜… æ ¹æ®è®¾ç½®çš„çº¿ç¨‹å¹¶å‘æ•°å’Œæœ€å¤§æ•°åˆ›å»ºä¸€ä¸ªCoroutineSchedulerç±»å‹çš„çº¿ç¨‹æ± ï¼Œæºç åœ¨ä¸‹é¢
    private var coroutineScheduler = createScheduler()  
    private fun createScheduler() = CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName)

    //â˜…â˜…â˜… æ²¡æœ‰é‡å†™isDispatchNeeded()å‡½æ•°ï¼Œé»˜è®¤è¿”å›trueï¼Œè¡¨ç¤ºéœ€è¦åˆ‡æ¢çº¿ç¨‹ã€‚å› ä¸ºä¸ç®¡ä¹‹å‰æ˜¯ä»€ä¹ˆçº¿ç¨‹ï¼Œåªè¦å°†ä»»åŠ¡æ‰”åˆ°çº¿ç¨‹æ± å°±éœ€è¦åˆ‡æ¢çº¿ç¨‹
    //public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
    //â˜…â˜…â˜… å°†Runnableæ‰”åˆ°çº¿ç¨‹æ± ä¸­ï¼Œå®ç°çº¿ç¨‹åˆ‡æ¢
    override fun dispatch(context: CoroutineContext, block: Runnable): Unit =
        try {
            coroutineScheduler.dispatch(block)
        } catch (e: RejectedExecutionException) {
            // CoroutineScheduler only rejects execution when it is being closed and this behavior is reserved
            // for testing purposes, so we don't have to worry about cancelling the affected Job here.
            DefaultExecutor.dispatch(context, block)
        }
    ...
}
```

`CommonPool`ä¸­é‡‡ç”¨çš„æ˜¯javaä¸­çš„`ForkJoinPool`ï¼Œè¿™ç§çº¿ç¨‹æ± å¯ä»¥å°†ä¸€ä¸ªå¤§ä»»åŠ¡åˆ†ä¸ºå¤šä¸ªå°ä»»åŠ¡ï¼Œäº¤ç»™å¤šä¸ªçº¿ç¨‹æ‰§è¡Œå¤„ç†ï¼Œåˆ©ç”¨å¤šæ ¸CPUä¼˜åŠ¿æé«˜çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹åˆ©ç”¨ç‡ã€‚kotlinå€Ÿé‰´`ForkJoinPool`çš„æ€æƒ³å®ç°äº†ä¸€ç§æŠ¢å å¼çº¿ç¨‹æ± `CoroutineScheduler`ï¼Œè¿™ä¸ªçº¿ç¨‹æ± ä¸­çš„`Worker`ç±»å‹çš„çº¿ç¨‹å½“ä»»åŠ¡æ‰§è¡Œå®Œæ¯•åï¼Œä¼šä¸»åŠ¨å»å…¨å±€ä»»åŠ¡é˜Ÿåˆ—ã€ç§æœ‰ä»»åŠ¡é˜Ÿåˆ—ã€å…¶ä»–çº¿ç¨‹ä»»åŠ¡é˜Ÿåˆ—ä¸­å¯»æ‰¾ä»»åŠ¡ï¼Œ**é¿å…å½“å‰çº¿ç¨‹ä¼‘çœ ï¼Œå‡å°‘çº¿ç¨‹åˆ‡æ¢æ¬¡æ•°ï¼Œä»è€Œæé«˜CPUåˆ©ç”¨ç‡**ï¼Œä¸æŠŠèµ„æºæµªè´¹åœ¨åˆ‡æ¢çº¿ç¨‹è¿™ç§æ— æ„ä¹‰çš„äº‹æƒ…ä¸Šï¼š

```kotlin
//CoroutineSchedulerçº¿ç¨‹æ± ï¼Œè¯¥çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹éƒ½æ˜¯Workerç±»å‹çš„ï¼Œå…·æœ‰æŠ¢å ä»»åŠ¡çš„ç‰¹æ€§
internal class CoroutineScheduler(
    @JvmField val corePoolSize: Int,
    @JvmField val maxPoolSize: Int,
    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,
    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME
) : Executor, Closeable {
    //çº¿ç¨‹æ± å…¨å±€ä»»åŠ¡é˜Ÿåˆ—ï¼Œè¿™äº›é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡åœ¨æ‰§è¡Œæ—¶éƒ½å¯èƒ½æ¶‰åŠåˆ°çº¿ç¨‹æ± çš„çº¿ç¨‹åˆ‡æ¢
    val globalCpuQueue = GlobalQueue()     //å­˜æ”¾CPUå¯†é›†å‹ä»»åŠ¡çš„é˜Ÿåˆ—
    val globalBlockingQueue = GlobalQueue()//å­˜æ”¾IOå¯†é›†å‹ä»»åŠ¡çš„é˜Ÿåˆ—
    
    //çº¿ç¨‹æ•°ç»„
    val workers = AtomicReferenceArray<Worker?>(maxPoolSize + 1)
    
    //â˜…â˜…â˜… ç‰¹æ®Šçš„çº¿ç¨‹ï¼Œå¯ä»¥æŠ¢åˆ«çš„çº¿ç¨‹çš„ä»»åŠ¡
    internal inner class Worker private constructor() : Thread() {
        //æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå®ƒä¸»è¦è´Ÿè´£CPUå¯†é›†å‹ä»»åŠ¡
        val localQueue: WorkQueue = WorkQueue() 
        
        override fun run() = runWorker()
        private fun runWorker() {
            var rescanned = false
            while (!isTerminated && state != WorkerState.TERMINATED) {
                //ä¸»åŠ¨å¯»æ‰¾ä»»åŠ¡
                val task = findTask(mayHaveLocalTasks)
                // æ‰¾åˆ°ä»»åŠ¡åæ‰§è¡Œä»»åŠ¡
                ...
            }
        }
        /**
         * â˜…â˜…â˜… fundTask()ï¼šå½“çº¿ç¨‹çš„ä»»åŠ¡æ‰§è¡Œå®Œæ¯•åï¼Œè®©å®ƒä¸»åŠ¨å»å¯»æ‰¾ä»»åŠ¡ï¼Œä»è€Œé¿å…å½“å‰çº¿ç¨‹ä¼‘çœ ï¼Œå‡å°‘çº¿ç¨‹åˆ‡æ¢æ¬¡æ•°ï¼Œä»¥æé«˜CPUåˆ©ç”¨ç‡
         * å¯»æ‰¾ä»»åŠ¡
         */
        fun findTask(scanLocalQueue: Boolean): Task? {
            /**
             * tryAcquireCpuPermit()åˆ¤æ–­å½“å‰æ˜¯å¦æœ‰CPUæ§åˆ¶æƒ
             * â˜… å¦‚æœæœ‰CPUæ§åˆ¶æƒï¼šfindAnyTask()å°è¯•ä»å…¨å±€ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ï¼Œæ„ä¹‰å°±æ˜¯å½“å‰çº¿ç¨‹çš„ä»»åŠ¡æ‰§è¡Œå®Œåä¸»åŠ¨å»å…¨å±€ä»»åŠ¡é˜Ÿåˆ—æ‰¾ä»»åŠ¡ï¼Œè€Œä¸æ˜¯ä¼‘çœ ï¼Œä»è€Œå‡å°‘ä¸€æ¬¡çº¿ç¨‹åˆ‡æ¢ï¼Œæé«˜CPUåˆ©ç”¨ç‡
             */
            if (tryAcquireCpuPermit()) return findAnyTask(scanLocalQueue)
            //â˜… å¦‚æœä¸èƒ½è·å¾—CPUæ§åˆ¶æƒï¼Œå°è¯•ä»å½“å‰çº¿ç¨‹çš„ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ï¼Œå…¶ç›®çš„å°±æ˜¯é˜»å¡å½“å‰çº¿ç¨‹ï¼Œä¸è®©å®ƒä¼‘æ¯ï¼Œä½¿å…¶é¥¥é¥¿å¼çš„å¯»æ‰¾ä»»åŠ¡
            val task = if (scanLocalQueue) {
                localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull()
            } else {
                globalBlockingQueue.removeFirstOrNull()
            }
            //å¦‚æœä¸Šé¢æ²¡æœ‰æ‹¿åˆ°ä»»åŠ¡ï¼Œé€šè¿‡trySteal()å°è¯•å·åˆ«çš„çº¿ç¨‹çš„ä»»åŠ¡
            return task ?: trySteal(blockingOnly = true)
        }
        
        //â˜… å·å…¶ä»–çº¿ç¨‹çš„ä»»åŠ¡
        private fun trySteal(blockingOnly: Boolean): Task? {
            assert { localQueue.size == 0 }
            ...
            repeat(created) {
                ++currentIndex
                if (currentIndex > created) currentIndex = 1
                val worker = workers[currentIndex]   //éå†çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°ç»„ï¼Œworkerå°±æ˜¯ä¸€ä¸ªçº¿ç¨‹Thread
                if (worker !== null && worker !== this) {
                    assert { localQueue.size == 0 }
                    //å°è¯•ä»å…¶ä»–çº¿ç¨‹çš„ç§æœ‰ä»»åŠ¡é˜Ÿåˆ—ä¸­å·ä¸€ä¸ªä»»åŠ¡ï¼Œæ”¾åˆ°å½“å‰çº¿ç¨‹çš„ç§æœ‰ä»»åŠ¡é˜Ÿåˆ—ä¸­
                    val stealResult = if (blockingOnly) {
                        localQueue.tryStealBlockingFrom(victim = worker.localQueue)
                    } else {
                        localQueue.tryStealFrom(victim = worker.localQueue)
                    }
                    if (stealResult == TASK_STOLEN) {
                        return localQueue.poll()  //å·æˆåŠŸåï¼Œå°†ä»»åŠ¡è¿”å›
                    } else if (stealResult > 0) {
                        minDelay = min(minDelay, stealResult)
                    }
                }
            }
            minDelayUntilStealableTaskNs = if (minDelay != Long.MAX_VALUE) minDelay else 0
            return null
        }
    }
    
}
```

### 3.2.2 Dispatchers.Main

Androidä¸­çš„ä¸»è°ƒåº¦å™¨æ˜¯é€šè¿‡ä¸»çº¿ç¨‹Handlerå®ç°çº¿ç¨‹åˆ‡æ¢çš„ï¼Œ`isDispatchNeeded()`ä¸­é€šè¿‡**åˆ¤æ–­å½“å‰çº¿ç¨‹çš„Looperæ˜¯å¦ç­‰äºMainLooper**ï¼Œå¦‚æœä¸ç›¸ç­‰åˆ™è¡¨ç¤ºå½“å‰çº¿ç¨‹æ˜¯å­çº¿ç¨‹ï¼Œè€Œæˆ‘ä»¬è¦è°ƒåº¦åˆ°ä¸»çº¿ç¨‹ï¼Œæ‰€ä»¥`dispatch()`ä¸­**ä½¿ç”¨Handlerå°†ä»»åŠ¡æäº¤åˆ°ä¸»çº¿ç¨‹æ¶ˆæ¯é˜Ÿåˆ—**ï¼Œä»è€Œåœ¨ä¸»çº¿ç¨‹è§¦å‘`invokeSuspend()`ï¼š

```kotlin
//â˜† kotlinx-coroutines-android.jar
//â˜† åç¨‹çš„androidæ‰©å±•åŒ…ä¸­å¯¹ä¸»è°ƒåº¦å™¨å·¥å‚çš„å®ç°
internal class AndroidDispatcherFactory : MainDispatcherFactory {
    //Androidå¹³å°ä¸Šåˆ›å»ºHandlerContextç±»å‹çš„ä¸»è°ƒåº¦å™¨ï¼Œä¼ å…¥çš„å‚æ•°æ˜¯é€šè¿‡ä¸»çº¿ç¨‹Looperåˆ›å»ºçš„Handlerå¯¹è±¡
    override fun createDispatcher(allFactories: List<MainDispatcherFactory>) =
        HandlerContext(Looper.getMainLooper().asHandler(async = true))
}

//â˜† Androidå¹³å°UIçº¿ç¨‹è°ƒåº¦å™¨çš„å®ç°
internal class HandlerContext private constructor(
    private val handler: Handler,   //ä¸»çº¿ç¨‹Handler
    private val name: String?,
    private val invokeImmediately: Boolean
) : HandlerDispatcher(), Delay {
    public constructor(handler: Handler, name: String? = null) : this(handler, name, false)
    //æ˜¯å¦éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Ÿ
    override fun isDispatchNeeded(context: CoroutineContext): Boolean {
        //â˜…â˜…â˜… å½“å‰çº¿ç¨‹çš„Looperä¸ç­‰äºä¸»çº¿ç¨‹Looperæ—¶ï¼Œè¯´æ˜å½“å‰çº¿ç¨‹æ˜¯å­çº¿ç¨‹ï¼Œéœ€è¦åˆ‡æ¢åˆ°ä¸»è°ƒåº¦å™¨æŒ‡å®šçš„ä¸»çº¿ç¨‹ä¸­
        return !invokeImmediately || Looper.myLooper() != handler.looper
    }
    //ä»å­çº¿ç¨‹åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        //â˜…â˜…â˜… é€šè¿‡ä¸»çº¿ç¨‹çš„handlerå°†ä»»åŠ¡Runnableæäº¤åˆ°ä¸»çº¿ç¨‹æ¶ˆæ¯é˜Ÿåˆ—ï¼ŒRunnableå°†åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ
        handler.post(block)
    }
}
```

### 3.2.3 Dispatchers.Unconfined

`Dispatchers.Unconfined`å•ä¾‹å¯¹è±¡é‡å†™äº†`isDispatchNeeded()`ç›´æ¥è¿”å›falseï¼Œè¡¨ç¤º**ä»»ä½•æƒ…å†µä¸‹éƒ½ä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œç›´æ¥åœ¨å½“å‰çº¿ç¨‹æ‰§è¡Œ**ï¼š

```kotlin
//â˜† kotlinx-coroutines-core-jvm.jar
//ä¸å±€é™äºä»»ä½•ç‰¹å®šçº¿ç¨‹çš„åç¨‹è°ƒåº¦å™¨ï¼Œä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹
internal object Unconfined : CoroutineDispatcher() {
    //â˜…â˜…â˜… ä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹
    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        // It can only be called by the "yield" function. See also code of "yield" function.
        val yieldContext = context[YieldContext]
        if (yieldContext != null) {
            // report to "yield" that it is an unconfined dispatcher and don't call "block.run()"
            yieldContext.dispatcherWasUnconfined = true
            return
        }
        throw UnsupportedOperationException("Dispatchers.Unconfined.dispatch function can only be used by the yield function. " +
            "If you wrap Unconfined dispatcher in your code, make sure you properly delegate " +
            "isDispatchNeeded and dispatch calls.")
    }
}
```

å¦‚æœåç¨‹æ„å»ºå™¨ä¼ å…¥`Dispatchers.Unconfined`ï¼Œå°†åœ¨å½“å‰çº¿ç¨‹å¯åŠ¨æ‰§è¡Œåç¨‹ï¼Œä½†ä»…ä»…åªæ˜¯è¿è¡Œåˆ°ç¬¬ä¸€ä¸ªæŒ‚èµ·ç‚¹ï¼ˆåˆå§‹çŠ¶æ€ï¼‰ï¼Œç¬¬ä¸€ä¸ªæŒ‚èµ·ç‚¹ä¹‹åçš„ä»£ç åœ¨å“ªä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œå°†ç”±è¢«è°ƒç”¨çš„æŒ‚èµ·å‡½æ•°æ¥å†³å®šï¼ˆæŒ‚èµ·å‡½æ•°åœ¨å“ªä¸ªçº¿ç¨‹è°ƒåº¦ï¼Œåç¨‹æ¢å¤åå°†åœ¨å“ªä¸ªçº¿ç¨‹æ‰§è¡Œï¼‰ï¼š

```kotlin
fun main() = runBlocking{
    launch(Dispatchers.Unconfined) { // Dispatchers.Unconfinedåœ¨å½“å‰çº¿ç¨‹ä¸Šå¯åŠ¨æ‰§è¡Œåç¨‹
        println("Unconfined: åœ¨ ${Thread.currentThread().name}çº¿ç¨‹æ‰§è¡Œ")     //åœ¨mainçº¿ç¨‹æ‰§è¡Œ
        delay(500)   //æŒ‚èµ·å‡½æ•°ï¼Œä¼šåœ¨å­çº¿ç¨‹ç­‰å¾…å»¶è¿Ÿ0.5s
        println("Unconfined: å»¶è¿Ÿååœ¨${Thread.currentThread().name}çº¿ç¨‹æ‰§è¡Œ") //å»¶è¿Ÿååœ¨kotlinx.coroutines.DefaultExecutorçº¿ç¨‹æ‰§è¡Œ
    }
    launch { //ç»§æ‰¿runBlockingçˆ¶åç¨‹çš„ä¸Šä¸‹æ–‡
        println("main runBlocking: åœ¨ ${Thread.currentThread().name}çº¿ç¨‹æ‰§è¡Œ")  //åœ¨mainçº¿ç¨‹æ‰§è¡Œ
        delay(1000)
        println("main runBlocking: å»¶è¿Ÿååœ¨${Thread.currentThread().name}çº¿ç¨‹æ‰§è¡Œ") //å»¶è¿Ÿååœ¨mainçº¿ç¨‹æ‰§è¡Œ
    }
}
```

å®ƒæ˜¯**éå—é™çš„è°ƒåº¦å™¨**ï¼Œéå¸¸é€‚ç”¨äºæ‰§è¡Œä¸æ¶ˆè€—CPUæ—¶é—´çš„ä»»åŠ¡ï¼ˆå› ä¸ºä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼‰ï¼Œä»¥åŠä¸æ›´æ–°å±€é™äºç‰¹å®šçº¿ç¨‹çš„ä»»ä½•å…±äº«æ•°æ®ï¼ˆå¦‚UIï¼‰çš„åç¨‹ï¼Œå®ƒæ˜¯`runBlocking{}` åç¨‹çš„é»˜è®¤è°ƒåº¦å™¨ã€‚éå—é™çš„è°ƒåº¦å™¨æ˜¯ä¸€ç§é«˜çº§æœºåˆ¶ï¼Œå¯ä»¥åœ¨æŸäº›æç«¯æƒ…å†µä¸‹æä¾›å¸®åŠ©è€Œä¸éœ€è¦è°ƒåº¦åç¨‹ä»¥ä¾¿ç¨åæ‰§è¡Œæˆ–äº§ç”Ÿä¸å¸Œæœ›çš„å‰¯ä½œç”¨ï¼Œ å› ä¸ºæŸäº›æ“ä½œå¿…é¡»ç«‹å³åœ¨åç¨‹ä¸­æ‰§è¡Œã€‚ **éå—é™è°ƒåº¦å™¨ä¸åº”è¯¥åœ¨é€šå¸¸çš„ä»£ç ä¸­ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨å®é™…å¼€å‘ä¸­é€šå¸¸ä¸ç”¨ï¼Œåªåœ¨æµ‹è¯•ç¨‹åºä¸­ä½¿ç”¨**ã€‚

### 3.2.4 Dispatchers.IO

`Dispatchers.IO`è°ƒåº¦å™¨å’Œ`Dispatchers.Default`çš„`DefaultScheduler`æ˜¯å·®ä¸å¤šçš„ï¼Œéƒ½ä½¿ç”¨kotlinå®ç°çš„ä»»åŠ¡æŠ¢å å¼çš„`CoroutineScheduler`ç±»å‹çš„çº¿ç¨‹æ± ã€‚ä¸åŒçš„æ˜¯è¿™ä¸¤ç§åç¨‹è°ƒåº¦å™¨çš„ä½¿ç”¨åœºæ™¯ä¸åŒï¼Œ**Dispatchers.Defaulté€‚ç”¨äºCPUå¯†é›†å‹ä»»åŠ¡ï¼ŒDispatchers.IOé€‚ç”¨äºI/Oå¯†é›†å‹ä»»åŠ¡ã€‚**

åœ¨ä½¿ç”¨çº¿ç¨‹æ± è°ƒåº¦å™¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ˜¯è¯¥é€‰æ‹©`Dispatchers.Default`è¿˜æ˜¯`Dispatchers.IO`å‘¢ï¼Ÿå…¶å®åªéœ€è¦åŒºåˆ†è¿™ä¸ªä»»åŠ¡æ˜¯CPUå¯†é›†å‹çš„è¿˜æ˜¯I/Oå¯†é›†å‹çš„ã€‚

- CPUå¯†é›†å‹

  ä»»ä½•ä»»åŠ¡åœ¨æ‰§è¡Œæ—¶éƒ½ä¼šæ¶ˆè€—CPUå’Œå†…å­˜ï¼Œå¦‚æœä»»åŠ¡å¤§éƒ¨åˆ†æ—¶é—´éƒ½åœ¨åšä¸€äº›è®¡ç®—å’Œé€»è¾‘åˆ¤æ–­ç­‰æ¶ˆè€—CPUçš„åŠ¨ä½œï¼Œè€ŒI/Oåœ¨å¾ˆçŸ­çš„æ—¶é—´å°±å¯ä»¥å®Œæˆçš„ä»»åŠ¡é€šå¸¸ç§°ä¸ºCPUå¯†é›†å‹ä»»åŠ¡ã€‚è¿™ç±»ä»»åŠ¡æœ‰ä¸€ä¸ªæ˜æ˜¾çš„ç‰¹ç‚¹ï¼Œå°±æ˜¯åœ¨æ‰§è¡Œæ—¶ä¼šè®©CPUå ç”¨é‡ç¬é—´å‡é«˜ï¼Œå¹¶ä¸”ç»´æŒæ—¶é—´è¾ƒé•¿ï¼ˆå¯é€šè¿‡ä»»åŠ¡ç®¡ç†å™¨çš„æ€§èƒ½æŸ¥çœ‹ï¼‰ã€‚åœ¨Androidä¸­ï¼ŒåŠ è½½å¸ƒå±€æ ‘(é€’å½’è¿­ä»£å¡«å……)ã€è¯†åˆ«äºŒç»´ç ç­‰ä»»åŠ¡å°±å±äºè¯¥ç±»ä»»åŠ¡ã€‚

- I/Oå¯†é›†å‹

  I/Oå¯†é›†å‹ä»»åŠ¡æ˜¯ç›¸å¯¹äºCPUå¯†é›†å‹è€Œè¨€çš„ï¼Œè¿™ç±»ä»»åŠ¡é€šå¸¸å ç”¨è¾ƒå¤šçš„å†…å­˜ï¼Œè€Œè®¡ç®—ç›¸å¯¹ç®€å•ã€‚Androidä¸­æ•°æ®å­˜å‚¨ã€æ–‡ä»¶æ‹·è´ã€è¯·æ±‚æ•°æ®ç­‰ç­‰éƒ½å±äºI/Oå¯†é›†å‹ä»»åŠ¡ã€‚

ä¸ç®¡æ˜¯ä»€ä¹ˆç±»å‹çš„ä»»åŠ¡ï¼Œéƒ½æ˜¯é€šè¿‡çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ‰§è¡Œçš„ï¼Œè€Œä¸”IOè°ƒåº¦å™¨å’Œé»˜è®¤è°ƒåº¦å™¨ä½¿ç”¨çš„æ˜¯åŒä¸€ç§ç±»å‹çš„çº¿ç¨‹æ± ï¼ˆéƒ½æ˜¯ä»»åŠ¡æŠ¢å å¼çš„Workerçº¿ç¨‹ï¼‰ï¼Œå²‚ä¸æ˜¯æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«äº†ï¼Ÿä¸ºä»€ä¹ˆè¿˜è¦ä¸º`Dispatchers.IO`å®šä¹‰ä¸€ä¸ª`LimitingDispatcher`å®ç°ç±»å‘¢ï¼ŸåŸå› å°±æ˜¯**åœ¨åˆ›å»ºçº¿ç¨‹æ± å¯¹è±¡æ—¶ï¼Œéœ€è¦è®¾ç½®è¯¥çº¿ç¨‹æ± æœ€å¤§çº¿ç¨‹æ•°å’Œå¹¶å‘æ•°ï¼Œæˆ‘ä»¬è¦æ ¹æ®ä¸åŒç±»å‹ä»»åŠ¡é…ç½®ä¸åŒçš„å¹¶å‘å’Œæœ€å¤§çº¿ç¨‹æ•°é‡ï¼Œä»¥æœ€å¤§é™åº¦æé«˜CPUåˆ©ç”¨ç‡ã€‚**

å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ä¸€èˆ¬æœ€å¤§çº¿ç¨‹ä¸ªæ•°éƒ½å¤§äº CPU æ ¸å¿ƒçš„ä¸ªæ•°ï¼Œè€Œä¸€ä¸ª CPU æ ¸å¿ƒåœ¨ä»»æ„æ—¶åˆ»åªèƒ½è¢«ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œä¸ºäº†è®©è¿™äº›çº¿ç¨‹éƒ½èƒ½å¾—åˆ°æœ‰æ•ˆæ‰§è¡Œï¼ŒCPU é‡‡å–çš„ç­–ç•¥æ˜¯ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ†é…æ—¶é—´ç‰‡å¹¶è½®è½¬çš„å½¢å¼ã€‚å½“ä¸€ä¸ªçº¿ç¨‹çš„æ—¶é—´ç‰‡ç”¨å®Œæ—¶ä¼šä¿å­˜è‡ªå·±çš„çŠ¶æ€å¹¶ä¼šé‡æ–°å¤„äºå°±ç»ªçŠ¶æ€è®©ç»™å…¶ä»–çº¿ç¨‹ä½¿ç”¨ï¼Œè€Œå…¶ä»–çº¿ç¨‹æ—¶é—´ç‰‡ç”¨å®Œå®ƒåˆæœ‰æœºä¼šäº‰å–åˆ°æ‰§è¡Œæƒï¼Œæ¥ç€ä¹‹å‰çš„çŠ¶æ€ç»§ç»­æ‰§è¡Œã€‚çº¿ç¨‹åˆ‡æ¢æ˜¯è®¡ç®—å¯†é›†å‹çš„ï¼Œè¿‡å¤šçš„çº¿ç¨‹åˆ‡æ¢æ„å‘³ç€æ¶ˆè€—å¤§é‡çš„CPUæ—¶é—´ï¼Œé€ æˆé¢å¤–çš„æ€§èƒ½å¼€é”€æµªè´¹ã€‚è€Œæœ€å¤§å¹¶å‘æ•°ä¹Ÿä¸æ˜¯éšä¾¿è®¾ç½®çš„ï¼Œæœ€å¤§å¹¶å‘æ•°è‚¯å®šä¸èƒ½è¶…å¤šCPUæ ¸å¿ƒæ•°ï¼Œé‚£å°±ç­‰äºæ ¸å¿ƒæ•°ï¼Ÿå¦‚æœç­‰äºæ ¸å¿ƒæ•°å°±ä¼šå¯¼è‡´åœ¨æŸä¸€æ®µæ—¶é—´éƒ½åœ¨æ‰§è¡ŒæŸä¸€ç§ç±»å‹çš„ä»»åŠ¡ï¼Œè€Œå…¶ä»–ä»»åŠ¡å°±è¢«æç½®äº†ï¼Œé€ æˆèµ„æºåˆ†é…ä¸å‡ï¼Œä»æŸç§æ„ä¹‰ä¸Šæ¥è¯´ä¹Ÿæ˜¯æ‰§è¡Œæ•ˆç‡ä¸é«˜çš„è¡¨ç°ã€‚é‚£åˆ°åº•åº”è¯¥æ€æ ·é…ç½®çº¿ç¨‹æ± å‘¢ï¼Ÿå…¶å®å¹¶æ²¡æœ‰ä¸€ä¸ªå¼ºç¡¬çš„è§„å®šï¼Œä½†æ˜¯é€šå¸¸ä¼šæœ‰ç›¸åº”çš„è§„åˆ™ï¼ˆå¹¶ä¸æ˜¯ä¸€å®šçš„ï¼Œç½‘ä¸Šä¹Ÿæœ‰å…¶ä»–è§„åˆ™ï¼‰ï¼š

**CPU å¯†é›†å‹ä»»åŠ¡(N+1)ï¼š** è¿™ç§ä»»åŠ¡ä¸»è¦æ¶ˆè€—CPUèµ„æºï¼Œå¯ä»¥å°†çº¿ç¨‹æœ€å¤§æ•°è®¾ç½®ä¸º Nï¼ˆCPU æ ¸å¿ƒæ•°ï¼‰+1ï¼Œæ¯” CPU æ ¸å¿ƒæ•°å¤šå‡ºæ¥çš„ä¸€ä¸ªçº¿ç¨‹æ˜¯ä¸ºäº†é˜²æ­¢çº¿ç¨‹å¶å‘çš„ç¼ºé¡µä¸­æ–­ï¼Œæˆ–è€…å…¶å®ƒåŸå› å¯¼è‡´çš„ä»»åŠ¡æš‚åœè€Œå¸¦æ¥çš„å½±å“ã€‚ä¸€æ—¦ä»»åŠ¡æš‚åœï¼ŒCPU å°±ä¼šå¤„äºç©ºé—²çŠ¶æ€ï¼Œè€Œåœ¨è¿™ç§æƒ…å†µä¸‹å¤šå‡ºæ¥çš„ä¸€ä¸ªçº¿ç¨‹å°±å¯ä»¥å……åˆ†åˆ©ç”¨ CPU çš„ç©ºé—²æ—¶é—´ã€‚

**I/O å¯†é›†å‹ä»»åŠ¡(2N)ï¼š** å¯¹äºè¿™ç§ä»»åŠ¡ï¼Œç³»ç»Ÿä¼šç”¨å¤§éƒ¨åˆ†çš„æ—¶é—´æ¥å¤„ç† I/O äº¤äº’ï¼Œè€Œçº¿ç¨‹åœ¨å¤„ç† I/O çš„æ—¶é—´æ®µå†…ä¸ä¼šå ç”¨ CPU æ¥å¤„ç†ï¼Œè¿™æ—¶å°±å¯ä»¥å°† CPU äº¤å‡ºç»™å…¶å®ƒçº¿ç¨‹ä½¿ç”¨ã€‚å› æ­¤åœ¨ I/O å¯†é›†å‹ä»»åŠ¡çš„åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¤šé…ç½®ä¸€äº›çº¿ç¨‹ï¼Œå…·ä½“çš„è®¡ç®—æ–¹æ³•æ˜¯ 2Nã€‚

æ¯”å¦‚kotlinåç¨‹å¯¹äº`Dispatchers.Default`è°ƒåº¦å™¨çš„çº¿ç¨‹æ± ï¼š
- å¹¶å‘æ•°é‡`CORE_POOL_SIZE = CPUæ ¸å¿ƒæ•°(æœ€å°ä¸º2)` ï¼Œå¯é€šè¿‡`kotlinx.coroutines.scheduler.core.pool.size`è®¾ç½®ï¼›

- æœ€å¤§æ•°é‡`MAX_POOL_SIZE = CPUæ ¸å¿ƒæ•°*128`ï¼Œå¯é€šè¿‡`kotlinx.coroutines.scheduler.max.pool.size`è®¾ç½®ã€‚ä¸æ˜¯è¯´N+1å—ï¼Ÿä¸ºä»€ä¹ˆæœ€å¤§æ•°é‡æ˜¯N*128ï¼Ÿå…¶å®æ˜¯å› ä¸ºkotlinåç¨‹è°ƒåº¦å™¨çš„çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ˜¯ä¸€ç§ä»»åŠ¡æŠ¢å¤ºå¼çš„Workerçº¿ç¨‹ï¼Œä¸Šé¢æˆ‘ä»¬ä¹Ÿå¯¹å…¶è¿›è¡Œåˆ†æäº†ï¼Œå¹¶ä¸ä¼šå› ä¸ºçº¿ç¨‹æ± æœ€å¤§çº¿ç¨‹é‡è¿‡å¤§è€Œé€ æˆè¿‡å¤šçš„çº¿ç¨‹åˆ‡æ¢å¼€é”€ã€‚

 `Dispatchers.IO`è°ƒåº¦å™¨çš„çº¿ç¨‹æ± çš„é…ç½®å’Œ`Dispatchers.Default`æ˜¯ç›¸åŒçš„ï¼Œä¸è¿‡åœ¨IOè°ƒåº¦å™¨ä¸­é€šè¿‡`parallelism`æ¥æ§åˆ¶äº†å¾€çº¿ç¨‹æ± åŒæ—¶æ‰”ä»»åŠ¡çš„æœ€å¤§æ•°é‡ï¼Œå¦‚æœè¶…è¿‡äº†è¿™ä¸ªé˜ˆå€¼ï¼Œåˆ™å…ˆæ”¾å…¥åˆ°é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…çº¿ç¨‹æ± æœ‰ä¸€ä¸ªçº¿ç¨‹ç©ºé—²æ—¶å†å¾€é‡Œæ‰”ï¼Œè™½ç„¶æˆ‘ç°åœ¨ä¹Ÿä¸çŸ¥é“è¿™ä¹ˆå¹²çš„æ„ä¹‰æ˜¯ä»€ä¹ˆğŸ˜€ï¼Œä½†æ˜¯ä»–å’Œé»˜è®¤è°ƒåº¦å™¨ç¡®å®æ˜¯æœ‰åŒºåˆ«çš„ã€‚`parallelism`çš„é»˜è®¤å€¼ = max(64, jvmè™šæ‹Ÿæœºå¯ç”¨å¤„ç†å™¨æ•°)ï¼Œå¯é€šè¿‡`kotlinx.coroutines.io.parallelism`è®¾ç½®ã€‚ä¸‹é¢æ˜¯IOè°ƒåº¦å™¨æºç ï¼š

```kotlin
//â˜† kotlinx-coroutines-core-jvm.jar
//IOè°ƒåº¦å™¨
public val IO: CoroutineDispatcher = DefaultScheduler.IO

//3.2.1ä¸­è®²è§£çš„é»˜è®¤è°ƒåº¦å™¨DefaultScheduler
internal object DefaultScheduler : ExperimentalCoroutineDispatcher() {
    val IO: CoroutineDispatcher = LimitingDispatcher(
        this,  //â˜…ä¼ å…¥thisï¼Œä¹Ÿå°±æ˜¯ExperimentalCoroutineDispatcherï¼Œæ‰€ä»¥IOè°ƒåº¦å™¨ä¹Ÿæ˜¯ä½¿ç”¨çš„ä»»åŠ¡æŠ¢å å¼çš„CoroutineSchedulerç±»å‹çº¿ç¨‹æ± 
        //ä»ç³»ç»Ÿé…ç½®å±æ€§ä¸­è·å–IOå¯†é›†å‹ä»»åŠ¡é€‚ç”¨çš„æœ€å¤§çº¿ç¨‹æ•°ï¼Œé»˜è®¤å€¼æ˜¯ 64 å’Œ jvmè™šæ‹Ÿæœºå¯ç”¨çš„å¤„ç†å™¨æ•° ä¸­çš„è¾ƒå¤§å€¼
        systemProp(IO_PARALLELISM_PROPERTY_NAME, 64.coerceAtLeast(AVAILABLE_PROCESSORS)), 
        "Dispatchers.IO",   //è°ƒåº¦å™¨åç§°
        TASK_PROBABLY_BLOCKING
    )
    ...
}

//â˜† IOè°ƒåº¦å™¨çš„å®ç°
private class LimitingDispatcher(
    private val dispatcher: ExperimentalCoroutineDispatcher,  //çº¿ç¨‹æ± è°ƒåº¦å™¨
    private val parallelism: Int,  //åŒæ—¶æ‰§è¡Œçš„æœ€å¤§ä»»åŠ¡æ•°ï¼ˆä¸æ˜¯çº¿ç¨‹æ± çš„å¹¶å‘æ•°ï¼‰
    private val name: String?,
    override val taskMode: Int
) : ExecutorCoroutineDispatcher(), TaskContext, Executor {

    ...
    //â˜…â˜…â˜… æ²¡æœ‰é‡å†™isDispatchNeeded()å‡½æ•°ï¼Œé»˜è®¤è¿”å›trueï¼Œè¡¨ç¤ºéœ€è¦åˆ‡æ¢çº¿ç¨‹ã€‚å› ä¸ºä¸ç®¡ä¹‹å‰æ˜¯ä»€ä¹ˆçº¿ç¨‹ï¼Œåªè¦å°†ä»»åŠ¡æ‰”åˆ°çº¿ç¨‹æ± å°±éœ€è¦åˆ‡æ¢çº¿ç¨‹
    //public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true
    
    override fun dispatch(context: CoroutineContext, block: Runnable) = dispatch(block, false)
    //â˜…â˜…â˜… å°†ä»»åŠ¡æ‰”åˆ°ä»»åŠ¡æŠ¢å å¼CoroutineSchedulerç±»å‹çš„çº¿ç¨‹æ± ä¸­
    private fun dispatch(block: Runnable, tailDispatch: Boolean) {
        var taskToSchedule = block
        while (true) {
            val inFlight = inFlightTasks.incrementAndGet()
            //å¦‚æœæœªè¾¾åˆ°å¹¶å‘æ•°é‡é™åˆ¶ï¼Œåˆ™ç«‹å³è°ƒåº¦ä»»åŠ¡å¹¶è¿”å›
            if (inFlight <= parallelism) {
                dispatcher.dispatchWithContext(taskToSchedule, this, tailDispatch)
                return
            }
            // å·²è¾¾åˆ°å¹¶å‘æ•°é‡é™åˆ¶ï¼Œå°†ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—
            queue.add(taskToSchedule)
            if (inFlightTasks.decrementAndGet() >= parallelism) {
                return
            }
            taskToSchedule = queue.poll() ?: return
        }
    }
}
```



## 3.3 æ€»ç»“

kotlinåç¨‹åº“ä¸­çš„4ç§è°ƒåº¦å™¨çš„å®ç°æ˜¯ä¸ç³»ç»Ÿå¹³å°ç›¸å…³çš„ï¼š

- `Dispatchers.Main`ï¼šåœ¨å¸¦æœ‰UIæ¨¡å—çš„ç³»ç»Ÿä¸­ï¼Œè¡¨ç¤ºåœ¨**UIçº¿ç¨‹è°ƒåº¦**
- `Dispatchers.Default`ï¼šé€šå¸¸æƒ…å†µä¸‹ä¼šé‡‡ç”¨`CoroutineScheduler`ç±»å‹çš„çº¿ç¨‹æ± ï¼Œè¿™ä¸ªçº¿ç¨‹æ± ä½¿ç”¨ç‰¹æ®Šçš„**ä»»åŠ¡æŠ¢å å¼**çš„`Worker`ç±»å‹çš„çº¿ç¨‹ï¼Œé¿å…çº¿ç¨‹åˆ‡æ¢é€ æˆCPUèµ„æºæ¶ˆè€—ã€‚ä½†æ˜¯å¦‚æœè®¾ç½®äº†ç³»ç»Ÿå±æ€§`kotlinx.coroutines.scheduler`çš„å€¼ä¸º`off`æ—¶ï¼Œå°†é‡‡ç”¨javaçš„`ForkJoinPool`çº¿ç¨‹æ± ï¼Œå®ƒæ˜¯ä¸€ç§ä»»åŠ¡æ‹†åˆ†å¼çº¿ç¨‹æ± ï¼Œå¯ä»¥å°†ä¸€ä¸ªå¤§ä»»åŠ¡æ‹†åˆ†ä¸ºå¤šä¸ªå°ä»»åŠ¡åç»™å¤šä¸ªçº¿ç¨‹å¹¶å‘æ‰§è¡Œï¼Œç„¶åæ±‡æ€»ç»“æœï¼Œä»è€Œæé«˜äº†CPUåˆ©ç”¨ç‡ã€‚
- `Dispatchers.IO`ï¼šå®ƒå’Œ`Dispatchers.Default`ä¸€æ ·é‡‡ç”¨çš„æ˜¯`CoroutineScheduler`**ä»»åŠ¡æŠ¢å¤ºå¼çº¿ç¨‹æ± **ï¼ŒåŒºåˆ«æ˜¯åœ¨å¾€çº¿ç¨‹æ± æ‰”ä»»åŠ¡ä¹‹å‰å¤šäº†ä¸€ä¸ªé˜Ÿåˆ—ï¼Œç”¨äºæ§åˆ¶æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°é‡
- `Dispatchers.Unconfined`ï¼šæ— é™åˆ¶çš„ï¼Œ**åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½ä¸éœ€è¦åˆ‡æ¢çº¿ç¨‹ï¼Œç›´æ¥åœ¨å½“å‰çº¿ç¨‹æ‰§è¡Œ**ï¼Œå¦‚æœå¼‚æ­¥æŒ‚èµ·å‡½æ•°æ‰§è¡Œå®Œæ¯•åæ¢å¤åç¨‹æ‰§è¡Œï¼Œåç¨‹å°†æ²¿ç”¨æŒ‚èµ·å‡½æ•°çš„çº¿ç¨‹ä¸Šæ‰§è¡Œ



å¸Œæœ›æœ¬æ–‡èƒ½ç»™å„ä½å¸¦æ¥å¸®åŠ©ï¼Œå–œæ¬¢çš„åŒå­¦ä¸è¦å¿˜äº†**ä¸€é”®ä¸‰è”ï¼ˆç‚¹èµæŠ•å¸+å…³æ³¨ï¼‰**
> ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºopenXuåŸåˆ›æ–‡ç« [ã€openXuçš„åšå®¢ã€‘](http://blog.csdn.net/xmxkf)ï¼Œæœªç»åšä¸»å…è®¸ä¸å¾—ä»¥ä»»ä½•å½¢å¼è½¬è½½

@[toc]

æœ¬æ–‡ç« ä¸»è¦è®°å½•åœ¨é¡¹ç›®ä¸­ä½¿ç”¨Retrofit+åç¨‹æ—¶é‡åˆ°çš„é—®é¢˜ï¼Œå½“ç„¶æœ‰å…³é—®é¢˜ä¸å±€é™äºä½¿ç”¨åç¨‹ï¼Œå¯èƒ½ä½¿ç”¨RxJavaæˆ–è€…åŸå§‹Callä¹Ÿä¼šé‡åˆ°ï¼Œæ‰€ä»¥ç®—æ˜¯å¯¹Retrofitç›¸å…³é—®é¢˜çš„è§£å†³å’Œä¼˜åŒ–ã€‚æ–‡ç« ç¬¬ä¸€ä¸ªé—®é¢˜è®²çš„æ¯”è¾ƒå•°å—¦ï¼Œä¸»è¦ä»‹ç»äº†å½“æˆ‘ä»¬é‡åˆ°é—®é¢˜æ—¶åº”è¯¥æ€æ ·å»åˆ†æï¼Œå¹¶å­¦ä¼šä½¿ç”¨ç›¸å…³å·¥å…·å®šä½é—®é¢˜äº§ç”Ÿçš„æ ¹æœ¬åŸå› ï¼Œè¿™æ ·æ‰èƒ½æ›´å¥½çš„è§£å†³é—®é¢˜ï¼Œè€Œåé¢çš„å°±ç›´æ¥ç®€å•çš„æè¿°é—®é¢˜ã€é˜è¿°åŸå› å’Œè§£å†³åŠæ³•ã€‚

# 1. (ä¼˜åŒ–)Retrofit+åç¨‹ç¬¬ä¸€æ¬¡è¯·æ±‚æ—¶å¡é¡¿ç°è±¡

## 1.1 èƒŒæ™¯

```kotlin
/**1. æ¥å£å®šä¹‰*/
@POST("jeecg-boot/.../phoneLogin")
suspend fun login(@Body body: LoginBody): ApiResult<LoginInfo>

/**2. Retrofité…ç½®*/
private val retrofit = Retrofit.Builder()
    .client(okHttpClient)
    .baseUrl(PublicApiService.TEST_URL)
    .addConverterFactory(MoshiConverterFactory.create()) 
    .build()

/**Retrofit+åç¨‹å‘èµ·è¯·æ±‚*/
viewModelScope.launch {
    showDialog.value = true   //æ˜¾ç¤ºdialog
    var startTime = System.currentTimeMillis()
    FLog.w("å¼€å§‹è·å–åŠ¨æ€ä»£ç†å¯¹è±¡${startTime}")
    val service = RetrofitClient.getService(ApiService::class.java)
    FLog.w("1. è·å–åŠ¨æ€ä»£ç†å¯¹è±¡è€—æ—¶${System.currentTimeMillis() - startTime}")  //25ms
    startTime = System.currentTimeMillis()
    val loginBody = LoginBody(account,
            Base64.encodeToString(
                    FEncryptUtils.encryptAES2Base64(
                            password.toByteArray(),
                            LoginBody.key.toByteArray(),
                            "AES/CBC/PKCS5Padding",
                            LoginBody.iv.toByteArray()
                    ), Base64.NO_WRAP),
            AppConfig.productAppId,
            getDeviceToken(),
            "1")
    FLog.w("2. ç»„ç»‡å‚æ•°è€—æ—¶${System.currentTimeMillis() - startTime}") //10ms
    val loginInfo = service.login(loginBody).data()
    FLog.w("3. ç™»å½•å®Œæˆ")
    showDialog.value = false
}
```

ä¸Šè¿°ä»£ç ä¸­é€šè¿‡Retrofitå®šä¹‰äº†ä¸€ä¸ªæ¥å£`login()`ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‚èµ·å‡½æ•°ï¼Œåœ¨ViewModelä¸­ç›´æ¥è·å–æ¥å£ä»£ç†å¯¹è±¡å¹¶è°ƒç”¨`login()`ç™»å½•ã€‚å‡ºç°çš„é—®é¢˜**ç¨‹åºè¿è¡Œåç¬¬ä¸€æ¬¡ç™»å½•ä¼šæœ‰æ˜æ˜¾çš„å¡é¡¿ç°è±¡(dialogå»¶è¿Ÿäº†å·®ä¸å¤š1.5sæ‰èƒ½æ˜¾ç¤ºå‡ºæ¥)**ï¼Œåé¢å†è°ƒç”¨ç™»å½•æ¥å£å°±ä¸ä¼šå¡é¡¿äº†ã€‚

## 1.2 åˆæ­¥è§£å†³æ–¹æ¡ˆ

åŸå› å¯èƒ½æ˜¯Retrofitåœ¨ç¬¬ä¸€æ¬¡è¯·æ±‚è°ƒç”¨åŠ¨æ€ä»£ç†æ–¹æ³•æ—¶ä¼šåå°„åˆ›å»ºä»£ç†å¯¹è±¡ã€è§£ææ¥å£æ–¹æ³•æ³¨è§£ã€å‚æ•°ç­‰æ“ä½œéƒ½æ˜¯åœ¨ä¸»çº¿ç¨‹è¿›è¡Œçš„ï¼Œåªæœ‰çœŸæ­£çš„OkHttpè¯·æ±‚call.enqueue()å‘èµ·å¼‚æ­¥è¯·æ±‚çš„æ—¶å€™æ‰ä¼šåˆ‡åˆ°å­çº¿ç¨‹ï¼ŒCallçš„æ‰©å±•æŒ‚èµ·å‡½æ•°å¦‚ä¸‹ï¼š

```java
//ServiceMethodçš„adapt()ä¸­è°ƒç”¨callçš„æ‰©å±•å‡½æ•°await()ï¼Œå¹¶ä¼ å…¥continuationä½œä¸ºå‚æ•°
//è¿™ç§è°ƒç”¨æ–¹å¼çœ‹èµ·æ¥æœ‰äº›å¥‡æ€ªï¼Œå…¶å®å°±æ˜¯javaè°ƒç”¨kotlinä»£ç 
KotlinExtensions.await(call, continuation);

/**Callçš„æ‰©å±•æ–¹æ³•ï¼Œè¢«å®šä¹‰åœ¨retrofit2.KotlinExtensions.ktæ–‡ä»¶ä¸­*/
suspend fun <T : Any> Call<T>.await(): T {
    return suspendCancellableCoroutine { continuation ->
        ...
        //å‘èµ·è¯·æ±‚ï¼šç›¸å½“äºthis.enqueueï¼Œè€Œæ‰©å±•æ–¹æ³•ä¸­çš„thiså°±æ˜¯è¢«æ‰©å±•çš„ç±»ä¹Ÿå°±æ˜¯callå¯¹è±¡
        enqueue(object : Callback<T> {
            override fun onResponse(call: Call<T>, response: Response<T>) {
                if (response.isSuccessful) {
                    val body = response.body()
                    //æ¢å¤åç¨‹æ‰§è¡Œï¼Œè¿”å›å“åº”ç»“æœ
                    continuation.resume(body)
                } else {
                	//æ¢å¤åç¨‹æ‰§è¡Œï¼ŒæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸
                    continuation.resumeWithException(HttpException(response))
                }
            }
            ...
        })
    }
}
```

ä¸ºäº†ä½¿Retrofitçš„æ“ä½œå…¨éƒ¨åˆ‡åˆ°å­çº¿ç¨‹ï¼Œåº”è¯¥åœ¨è°ƒç”¨æ¥å£çš„æ—¶å€™å°±åˆ‡çº¿ç¨‹ï¼Œè¿™æ ·å°±ä¸ä¼šå¡é¡¿äº†ï¼š

```kotlin
viewModelScope.launch {
	val category : ApiResult<MutableList<Category>> = withContext(Dispatchers.IO){
                    RetrofitClient.apiService.login()
                }
}
```

## 1.3 é—®é¢˜æ¢ç´¢(ä½¿ç”¨å·¥å…·å¯¹åº”ç”¨è¿›è¡Œç›‘æµ‹å‰–æ)

é—®é¢˜è™½ç„¶è§£å†³äº†ï¼Œè¿˜æ˜¯å¸Œæœ›ææ¸…æ¥šç©¶ç«Ÿæ˜¯å“ªä¸ªæ­¥éª¤å¯¼è‡´çš„å¡é¡¿ã€‚launch{}ä¸­çš„ä»£ç å¯åˆ†ä¸º3ä¸ªéƒ¨åˆ†ï¼šåˆ›å»ºæ¥å£ä»£ç†å¯¹è±¡ã€ç»„ç»‡æ¥å£å‚æ•°ã€è°ƒç”¨æ¥å£å‘èµ·è¯·æ±‚ï¼Œå‰ä¸¤ä¸ªæ­¥éª¤é€šè¿‡æ—¥å¿—æ‰“å°å‘ç°è€—æ—¶æ€»å…±ä¹Ÿå°±20å‡ æ¯«ç§’ï¼Œé‚£å°±æ˜¯è°ƒç”¨ç™»å½•æ¥å£æ—¶åˆæ¬¡è§£ææ¥å£æ–¹æ³•è€—æ—¶çš„ï¼Ÿä»¥å‰æˆ‘ä»¬ç›´æ¥è°ƒç”¨Retrofitæ¥å£å¾—åˆ°ä¸€ä¸ªCallå¯¹è±¡ï¼Œç„¶åå‘èµ·è¯·æ±‚ï¼Œè°ƒç”¨æ¥å£çš„ä»£ç ä¹Ÿæ˜¯åœ¨ä¸»çº¿ç¨‹ä¸­å®Œæˆçš„ä¸ºä»€ä¹ˆæ²¡æœ‰å‘ç°æ˜æ˜¾å¡é¡¿ï¼Ÿå¯ä»¥æ€€ç–‘å¡é¡¿å¹¶ä¸æ˜¯Retrofitè§£ææ¥å£æ–¹æ³•é€ æˆçš„ã€‚ä¸ºäº†å‡†ç¡®çš„æ‰¾å‡ºåŸå› ï¼Œå†³å®šå¯¹launch{}ä¸­çš„ä»£ç ä½¿ç”¨å·¥å…·è¿›è¡Œç›‘æµ‹è¿½è¸ª

### 1.3.1 Android Studio CPUæ€§èƒ½å‰–æå™¨

#### â‘ . é€šè¿‡ä»£ç æ’æ¡©ç”Ÿæˆè·Ÿè¸ªæ—¥å¿—

åœ¨ä»£ç ä¸­æˆ‘ä»¬é€šè¿‡`FLog.w("${System.currentTimeMillis() - startTime}")`çš„æ–¹å¼æ‰“å°äº†ä¸»è¦æ­¥éª¤çš„è€—æ—¶æ—¶é—´ï¼Œä½†æ˜¯è°ƒç”¨login()æ¥å£çš„æ—¶é—´å´æ²¡åŠæ³•æ‰“å°ï¼ˆä¸€éƒ¨åˆ†åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œã€å¦ä¸€éƒ¨åˆ†åœ¨å­çº¿ç¨‹ï¼‰ã€‚å…¶å®Androidç³»ç»Ÿä¸ºæˆ‘ä»¬æä¾›äº†[**Method Tracing**](https://developer.android.google.cn/studio/profile/generate-trace-logs?hl=zh_cn)ç”¨äºæ£€æŸ¥CPUæ´»åŠ¨ï¼Œè·Ÿè¸ªAppæŸæ®µæ—¶é—´å†…è°ƒç”¨è¿‡çš„æ‰€æœ‰æ–¹æ³•ä»¥åŠå®ƒä»¬èŠ±è´¹çš„æ—¶é—´ï¼Œåœ¨éœ€è¦è·Ÿè¸ªçš„ä»£ç å¼€å¤´å’Œç»“å°¾æ’å…¥`android.os.Debug.startMethodTracing()`å’Œ`stopMethodTracing()`åè¿è¡Œç¨‹åºï¼Œç³»ç»Ÿä¼šæŠŠè¿½è¸ªç»“æœä¿å­˜åˆ°æ‰‹æœºçš„`Android\data\åŒ…å\files\dmtrace.trace`æ–‡ä»¶ä¸­ï¼ˆä¸åŒç³»ç»Ÿç‰ˆæœ¬ä¿å­˜ä½ç½®å¯èƒ½ä¸ä¸€æ ·ï¼ŒæŸ¥çœ‹startMethodTracing()æ–¹æ³•æºç è¯´æ˜ï¼‰ï¼Œå°†è¯¥æ–‡ä»¶å¯¼å‡ºå¹¶ä½¿ç”¨Android Studioçš„Profileræ‰“å¼€ï¼š

![](pic/2-3-1-Method Traceåˆ†æ.png)

åˆ†æè¿‡ç¨‹æˆªå›¾ä¸­å·²ç»æ ‡è®°å‡ºæ¥äº†ï¼Œæ ¹æ®æ–¹æ³•è°ƒç”¨æ ˆï¼ŒRetrofitåœ¨è§£ææ¥å£æ–¹æ³•åˆ›å»º`ServiceMethod`å¯¹è±¡æ—¶ï¼Œä¼šè°ƒç”¨`RequestFactory.parseParameterAnnotation()`è§£ææ¥å£æ–¹æ³•çš„å‚æ•°å’Œæ³¨è§£ï¼Œè§£æå‚æ•°å’Œæ³¨è§£æ—¶ï¼Œéœ€è¦ä¸ºæ¯ä¸ªå‚æ•°åˆ›å»ºéƒ½åˆ›å»ºä¸€ä¸ªè¯·æ±‚æ•°æ®è½¬æ¢å™¨`Converter`å¯¹è±¡ã€‚é€šè¿‡`Converter.Factory`çš„`requestBodyConverter()`åˆ›å»ºè¯·æ±‚æ•°æ®è½¬æ¢å™¨ï¼ˆä½œç”¨æ˜¯å°†æ¥å£æ–¹æ³•ä¸­çš„å‚æ•°è½¬æ¢ä¸ºRequestBodyå¯¹è±¡ï¼‰ï¼Œè€Œæˆ‘åœ¨é…ç½®Retrofitæ—¶æ·»åŠ äº†Moshié€‚é…å™¨å·¥å‚`MoshiConverterFactory`ï¼Œè¯¥å·¥å‚çš„`requestBodyConverter()`å®ç°ä¸­è°ƒç”¨äº†`moshi.adapter()`æ¥åˆ›å»º`JsonAdapter`å¯¹è±¡ï¼Œå…¶å®è·Ÿè¸ªåˆ°è¿™é‡Œæˆ‘ä»¬å°±å·²ç»çŸ¥é“äº†ä¸»è¦å°±æ˜¯`moshi.adapter()`è€—æ—¶çš„ã€‚æ‰€ä»¥**Retrofitåˆ›å»ºä»£ç†å¯¹è±¡ã€è§£ææ¥å£æ–¹æ³•ç­‰æ“ä½œå¹¶ä¸æ˜¯è€—æ—¶çš„æ ¹æœ¬åŸå› ï¼Œè™½ç„¶è¿™äº›æ“ä½œä¼šæ¶ˆè€—ä¸€äº›æ—¶é—´(ä¸åˆ°50ms)ï¼Œä½†ä¸ä¼šé€ æˆè‚‰çœ¼å¯è§çš„å¡é¡¿ï¼ŒçœŸæ­£è€—æ—¶çš„æ“ä½œæ˜¯`moshi.adapter()`ã€‚**

**ä¸ºä»€ä¹ˆ`moshi.adapter()`ä¼šé‚£ä¹ˆè€—æ—¶ï¼Ÿ** ä¸Šé¢æˆªå›¾ä¸­æ–¹æ³•è°ƒç”¨æ ˆä¸å®Œæ•´ï¼Œæˆ‘æ ¹æ®æ–¹æ³•æ ˆå‘ç°moshiåœ¨åˆ›å»º`JsonAdapter`å¯¹è±¡æ—¶ä¼šé€šè¿‡`InputStream`è¯»å–æ¸…å•æ–‡ä»¶Manifestä¸­çš„ç›¸å…³é…ç½®ï¼Œæ‰€ä»¥æ‰ä¼šè¿™ä¹ˆè€—æ—¶ã€‚

**é‚£ä¸ºä»€ä¹ˆåªæœ‰ç¬¬ä¸€æ¬¡è¯·æ±‚ä¼šæ˜æ˜¾å¡é¡¿ï¼Œè€Œåé¢å†æ¬¡è°ƒç”¨è¯¥æ¥å£å°±ä¸ä¼šå¡é¡¿äº†ï¼Ÿ** æŸ¥çœ‹æºç å‘ç°`Moshi`ä¸­ç»´æŠ¤äº†ä¸€ä¸ª`Map<Object, JsonAdapter<?>> adapterCache`ï¼Œç”¨äºç¼“å­˜å·²ç»åˆ›å»ºçš„`JsonAdapter`å¯¹è±¡ï¼Œå…¶keyæ˜¯æ¥å£æ–¹æ³•çš„å‚æ•°ç±»å‹å’Œæ³¨è§£ç±»å‹ç»„æˆçš„æ•°ç»„ï¼ŒåŒä¸€ç§å‚æ•°å°±åªéœ€è¦åˆ›å»ºä¸€æ¬¡JsonAdapterï¼Œä¸‹æ¬¡æ˜¯ç›´æ¥å–çš„ç¼“å­˜ã€‚æ‰€ä»¥å‚æ•°ç±»å‹ç›¸åŒçš„æ¥å£æ–¹æ³•(åŒ…æ‹¬åŒä¸€ä¸ªæ¥å£ å’Œ éœ€è¦jsonè½¬æ¢çš„å‚æ•°ç±»å‹ç›¸åŒçš„æ¥å£)åªæœ‰ç¬¬ä¸€æ¬¡è¯·æ±‚æ—¶ä¼šå¡é¡¿ï¼Œå¦‚æœæ¥å£æ–¹æ³•æ²¡æœ‰å‚æ•°ï¼Œæˆ–è€…æ‰€æœ‰å‚æ•°ç±»å‹éƒ½æ˜¯Stringå’ŒåŸºæœ¬ç±»å‹ï¼Œè¿™ç§æ¥å£ç¬¬ä¸€æ¬¡è¯·æ±‚ä¸ä¼šå¡é¡¿ï¼Œå› ä¸ºä¸éœ€è¦å‚æ•°åºåˆ—åŒ–

```java
public final class Moshi {
  ...
  //ç¼“å­˜
  private final Map<Object, JsonAdapter<?>> adapterCache = new LinkedHashMap<>();
  ...
  //æ ¹æ®Retrofitå®šä¹‰çš„æ¥å£æ–¹æ³•çš„å‚æ•°å’Œæ³¨è§£ï¼Œè·å–JsonAdapterå¯¹è±¡
  public <T> JsonAdapter<T> adapter(
      Type type, Set<? extends Annotation> annotations, @Nullable String fieldName) {
    ...

    // è·å–key = Arrays.asList(type, annotations);
    Object cacheKey = cacheKey(type, annotations);
    synchronized (adapterCache) {
      //ä»ç¼“å­˜ä¸­è·å–
      JsonAdapter<?> result = adapterCache.get(cacheKey);
      if (result != null) return (JsonAdapter<T>) result;
    }
    ...
      for (int i = 0, size = factories.size(); i < size; i++) {
        //ç¼“å­˜ä¸­æ²¡æœ‰åˆ™åˆ›å»º
        JsonAdapter<T> result = (JsonAdapter<T>) factories.get(i).create(type, annotations, this);
        if (result == null) continue;
        lookupChain.adapterFound(result);
        success = true;
        return result;
      }
    ...

  }
  ...
}
```

è¦æ€æ ·ä¼˜åŒ–å®ƒï¼Ÿç°åœ¨çœ‹æ¥æœ‰2ç§è§£å†³åŠæ³•ï¼š

- å°†è€—æ—¶æ“ä½œåˆ‡æ¢åˆ°å­çº¿ç¨‹ï¼ˆä¸Šé¢å·²ç»é€šè¿‡`withContext(Dispatchers.IO)`è§£å†³äº†ï¼‰ã€‚å¦‚æœä½¿ç”¨Retrofit+RxJavaçš„è¯ï¼Œå¯ä»¥ä½¿ç”¨äºŒæ¬¡åŠ¨æ€ä»£ç†å°†Retrofitçš„æ”¾åˆ°å­çº¿ç¨‹ä¸­å®Œæˆï¼Œå‚è€ƒ[çŸ¥ä¹å®‰å“å®¢æˆ·ç«¯å¯åŠ¨ä¼˜åŒ–ï¼šRetrofit ä»£ç†](https://www.infoq.cn/article/bl4trpybwadwjfaay1of)

```java
public final class Net {
    public static <T> createService(Class<T> service) {
        // ...
        return createWrapperService(mRetrofit, service);
    }
    private static <T> T createWrapperService(Retrofit retrofit, Class<T> service) {
        //åˆ›å»ºRetrofitæ¥å£çš„äºŒæ¬¡åŠ¨æ€ä»£ç†å¯¹è±¡ï¼Œç›®çš„æ˜¯å½“è°ƒç”¨äºŒæ¬¡åŠ¨æ€ä»£ç†å¯¹è±¡çš„æ¥å£æ–¹æ³•æ—¶ï¼Œè®©æ¥å£æ–¹æ³•çš„è§£æåˆ‡åˆ°å­çº¿ç¨‹
        return (T) Proxy.newProxyInstance(service.getClassLoader(),
                new Class<?>[]{service}, new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {
                        //é€šè¿‡Retrofitå¯¹è±¡åˆ›å»ºæ¥å£åŸä»£ç†å¯¹è±¡ï¼Œè¿™é‡Œéœ€è¦æ·»åŠ ç¼“å­˜æœºåˆ¶ï¼Œè¦ä¸ç„¶æ¯æ¬¡éƒ½ä¼šåˆ›å»ºæ–°çš„ä»£ç†å¯¹è±¡
                        final T originalService = retrofit.create(service);
                        if (method.getReturnType() == Observable.class) {
                            // å¦‚æœæ–¹æ³•è¿”å›å€¼æ˜¯Observableçš„è¯ï¼Œåˆ™åŒ…ä¸€å±‚å†è¿”å›
                            return Observable.defer(() -> {
                                // è°ƒç”¨åŸå§‹ä»£ç†å¯¹è±¡çš„æ¥å£æ–¹æ³•ï¼Œè·å–åŸå§‹Observable,ç„¶ååœ¨åŒ…è£¹ä¸€å±‚subscribeOn(Schedulers.io()
                                return ((Observable) getRetrofitMethod(originalService, method)
                                        .invoke(originalService, args))
                                        .subscribeOn(Schedulers.io());   //å°†loadServiceMethod()æ“ä½œåˆ‡æ¢åˆ°å­çº¿ç¨‹
                            }).subscribeOn(Schedulers.single());
                        }
                        // è¿”å›å€¼ä¸æ˜¯Observableçš„è¯ä¸å¤„ç†ï¼Œç›´æ¥ä½¿ç”¨åŸä»£ç†å¯¹è±¡æ‰§è¡Œæ–¹æ³•
                        return getRetrofitMethod(originalService, method).invoke(originalService, args);
                    }
                    // ...
                });
    }
    private static <T> Method getRetrofitMethod(T serviceOne, Method method) throws NoSuchMethodException {
        return serviceOne.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes());
    }
}
```

- ä¸è¦ç”¨Moshiï¼Œè€Œç”¨å…¶ä»–çš„æ•°æ®è½¬æ¢å™¨æ¯”å¦‚`GsonConverterFactory`ï¼Œè¿™ç§æ–¹å¼æˆ‘ä¹Ÿè¯•è¿‡äº†ï¼Œç¡®å®ä¸ä¼šæ˜æ˜¾å¡é¡¿ã€‚ä½†æ˜¯GsonConverterFactoryå¯¹kotlinçš„æ”¯æŒä¸æ˜¯å¤ªå¥½ï¼Œæœ€å¥½è¿˜æ˜¯ç»§ç»­ä½¿ç”¨Moshiï¼Œæ‰€ä»¥é‡‡ç”¨ç¬¬ä¸€ä¸­è§£å†³åŠæ³•æœ€å®Œç¾

#### â‘¡. ç›´æ¥ä½¿ç”¨Android Studio Profilerè¿›è¡Œå®æ—¶ç›‘æµ‹

ä¸Šé¢æ˜¯é€šè¿‡æ’å…¥ä»£ç ç”Ÿæˆè¿½è¸ªç»“æœæ–‡ä»¶æ¥è¿›è¡Œä»£ç è¿½è¸ªåˆ†æï¼Œè¿™ç§æ–¹å¼éœ€è¦å¯¼å‡º`dmtrace.trace`æ–‡ä»¶ååœ¨Profilerè§†å›¾ä¸­æ‰“å¼€ï¼Œæ¯”è¾ƒéº»çƒ¦ï¼Œå…¶å®å¯ä»¥ç›´æ¥é€šè¿‡Profilerçª—å£è¿›è¡Œä»£ç è¿½è¸ªã€‚æ‰“å¼€åº”ç”¨ï¼Œè¿›å…¥åˆ°éœ€è¦è¿½è¸ªçš„ä»£ç é¡µé¢ï¼Œåœ¨Profilerçª—å£ä¸­ç‚¹å‡»+å·ï¼Œé€‰æ‹©ä½ çš„æµ‹è¯•è®¾å¤‡->åº”ç”¨åŒ…åï¼Œè¿™æ—¶å€™å°±å¼€å§‹å¯¹åº”ç”¨è¿›ç¨‹çš„CPUã€å†…å­˜ã€ç½‘ç»œç­‰è¿›è¡Œå®æ—¶ç›‘æµ‹äº†ã€‚ç”±äºæˆ‘ä»¬éœ€è¦è¿½è¸ªæ–¹æ³•çš„è€—æ—¶ï¼Œä¹Ÿå°±æ˜¯CPUæ‰§è¡Œæ—¶é—´ï¼Œç›´æ¥ç‚¹å‡»CPUé‚£ä¸€æ ï¼Œç„¶ååˆ‡æ¢åˆ°åªç›‘æµ‹CPUï¼Œä¸‹æ–¹æœ‰ä¸€ä¸ª**Record**æŒ‰é’®ï¼Œç‚¹å‡»ä¸€ä¸‹è¯¥æŒ‰é’®å°±ç›¸å½“äºåœ¨ä»£ç ä¸­æ’å…¥äº†`Debug.startMethodTracing()`ï¼Œè¿™æ—¶å€™å°±å¼€å§‹å¯¹CPUè¿›è¡Œç›‘æµ‹è®°å½•äº†ï¼Œå¯¹åº”ç”¨è¿›è¡Œç›¸å…³æ“ä½œåï¼Œç‚¹å‡»**Stop**æŒ‰é’®ï¼Œåˆ™ä¼šåœæ­¢ç›‘æµ‹è®°å½•ï¼ŒåŒæ—¶å¯ä»¥ç›´æ¥æŸ¥çœ‹åˆ†æè¿½è¸ªç»“æœï¼Œçœå»äº†å¯¹`dmtrace.trace`æ–‡ä»¶çš„å¯¼å‡ºå’ŒåŠ è½½ã€‚

#### â‘¢. é€šè¿‡adbå‘½ä»¤ç›‘æµ‹åº”ç”¨å†·å¯åŠ¨

ä¸Šé¢æˆ‘ä»¬éƒ½æ˜¯å¯¹åº”ç”¨å¯åŠ¨ä¹‹åçš„æŸæ®µæ—¶é—´å†…è¿›è¡Œè¿½è¸ªï¼Œä½†æœ‰æ—¶å€™æˆ‘ä»¬å‘ç°ç¨‹åºå¯åŠ¨é€Ÿåº¦å˜æ…¢äº†ï¼Œè¦æ€æ ·å¯¹Appå†·å¯åŠ¨è¿›è¡Œç›‘æµ‹å‘¢ï¼Ÿéœ€è¦ä½¿ç”¨Androidç³»ç»Ÿçš„amå‘½ä»¤æ¥å¯åŠ¨Appï¼Œç„¶åå¯¼å‡º.traceæ–‡ä»¶è¿›è¡Œåˆ†æ:

```xml

# å¯åŠ¨æŒ‡å®šActivityï¼Œå¹¶åŒæ—¶è¿›è¡Œé‡‡æ ·è·Ÿè¸ª
adb shell am start -n com.fpc.zs119/com.fpc.zs119.ui.activity.SplashActivity --start-profiler /data/local/tmp/zs119-startup.trace --sampling 1000

# å½“Appå†·å¯åŠ¨å®Œæ¯•ï¼ŒActivityå·²ç»ç»˜åˆ¶åˆ°å±å¹•åï¼Œåœæ­¢è¿½è¸ª
adb shell am profile 

# æ‹‰å– .trace æ–‡ä»¶åˆ°æœ¬æœºå½“å‰ç›®å½•
adb pull /data/local/tmp/zs119-startup.trace .
```

### 1.3.2 Systrace(ç³»ç»Ÿè·Ÿè¸ª)

ä¸Šé¢éƒ½æ˜¯é€šè¿‡**Android Studio CPUæ€§èƒ½å‰–æå™¨**å¯¹ä»£ç è¿›è¡Œè¿½è¸ªï¼Œå‘ç°æ’å…¥è¿½è¸ªä»£ç åï¼Œç¨‹åºè¿è¡Œé€Ÿåº¦ä¸¥é‡å˜æ…¢ï¼ˆå› ä¸ºéœ€è¦å°†è¿½è¸ªæ—¥å¿—å†™å…¥æ–‡ä»¶ä¸­ï¼‰ï¼Œæ‰€ä»¥æœ€ç»ˆç›‘æµ‹ç»“æœå’Œå®é™…æƒ…å†µè‚¯å®šæ˜¯æœ‰ä¸€äº›åå·®çš„ï¼Œåªèƒ½ä½œä¸ºå‚è€ƒç”¨äºåˆæ­¥æŸ¥æ‰¾å®šä½è€—æ—¶æ–¹æ³•ã€‚Googleåœ¨2017å¹´IOå¤§ä¼šä¸Šæ¨å‡ºäº†[**ç³»ç»Ÿè·Ÿè¸ªå·¥å…·**](https://developer.android.google.cn/topic/performance/tracing)ï¼Œå®ƒæ˜¯ä¸€ç§å¯ä»¥å°†è®¾å¤‡æ´»åŠ¨ä¿å­˜åˆ°è·Ÿè¸ªæ–‡ä»¶çš„Androidå·¥å…·ï¼Œæ˜¯åˆ†æå¡é¡¿æ‰å¸§é—®é¢˜æ ¸å¿ƒå·¥å…·ï¼Œåªè¦èƒ½æä¾›å¡é¡¿ç°åœºå°±èƒ½å¾ˆå¥½å®šä½é—®é¢˜ã€‚å…¶åŸç†æ˜¯åœ¨Androidç³»ç»Ÿçš„ä¸€äº›å…³é”®é“¾è·¯(å¦‚System Serviceï¼ŒDalvik VMï¼ŒBinderç­‰)æ’å…¥ä¸€äº›ä¿¡æ¯äº‹ä»¶ï¼Œé€šè¿‡äº‹ä»¶çš„å¼€å§‹å’Œç»“æŸæ¥ç¡®å®šæŸä¸ªæ ¸å¿ƒè¿‡ç¨‹çš„æ‰§è¡Œæ—¶é—´ï¼Œç„¶åå°†è¿™äº›äº‹ä»¶ä¿¡æ¯æ”¶é›†èµ·æ¥ç”Ÿæˆhtmlæ ¼å¼çš„æŠ¥å‘Šã€‚Android Frameworkå±‚çš„é‡è¦æ¨¡å—éƒ½æ’å…¥äº†äº‹ä»¶(Javaå±‚çš„é€šè¿‡android.os.Traceç±»å®Œæˆï¼Œnativeå±‚é€šè¿‡ATraceå®å®Œæˆ)ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ ¹æ®è‡ªå·±éœ€æ±‚åœ¨è‡ªå·±çš„ä»£ç ä¸­æ·»åŠ è‡ªå®šä¹‰äº‹ä»¶ï¼Œè¯·å‚è€ƒ[ğŸ”—å®šä¹‰è‡ªå®šä¹‰äº‹ä»¶](https://developer.android.google.cn/topic/performance/tracing/custom-events)ã€‚æ¯”å¦‚ä¸‹é¢åœ¨è‡ªå·±çš„ä»£ç ä¸­æ’å…¥è‡ªå®šä¹‰äº‹ä»¶ï¼š

```kotlin
/**Retrofit+åç¨‹å‘èµ·è¯·æ±‚*/
viewModelScope.launch {
	showDialog.value = true
    //æ’å…¥è‡ªå®šä¹‰äº‹ä»¶åç§°çš„å¼€å§‹äº‹ä»¶ï¼Œæ³¨æ„beginSection()å’ŒendSection()å¿…é¡»æˆå¯¹å‡ºç°
    Trace.beginSection("--------RetrofitStart")
    val service = RetrofitClient.getService(ApiService::class.java)
    val loginBody = LoginBody(...)
    val loginInfo = service.login(loginBody).data()
    //äº‹ä»¶ç»“æŸ
    Trace.endSection()
    showDialog.value = false
}
```

åœ¨éœ€è¦åˆ†æçš„ä»£ç å‰åæ’å…¥äº‹ä»¶å¯¹åè¿è¡Œä»£ç ï¼Œç„¶åå°±å¯ä»¥å¼€å§‹æŠ“å–æŠ¥å‘Šäº†ã€‚åœ¨Android10(API29)åŠä»¥ä¸Šç‰ˆæœ¬çš„è®¾å¤‡ä¸Šï¼Œè·Ÿè¸ªæŠ¥å‘Šæ–‡ä»¶ä¼šä»¥`Perfetto`æ ¼å¼ä¿å­˜ï¼Œè€Œä½ç‰ˆæœ¬Androidç³»ç»Ÿçš„è®¾å¤‡ä¸Šï¼Œè·Ÿè¸ªæ–‡ä»¶ä¼šä»¥`Systrace`æ ¼å¼ä¿å­˜ã€‚ç”±äºæˆ‘æµ‹è¯•æœºæ˜¯8.0ç‰ˆæœ¬çš„ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç”ŸæˆSystraceæŠ¥å‘Šï¼Œå’Œä¸Šé¢CPUç›‘æµ‹ä¸€æ ·ï¼ŒSystraceæŠ¥å‘Šä¹Ÿæœ‰å¤šç§æ–¹å¼è·å–ï¼š

#### â‘ . é€šè¿‡systraceå‘½ä»¤æŠ“å–

systraceå‘½ä»¤åœ¨Android SDKå·¥å…·è½¯ä»¶åŒ…ä¸­æä¾›ï¼Œå¹¶ä¸”å¯ä»¥åœ¨`android-sdk/platform-tools/systrace/`ä¸­æ‰¾åˆ°ï¼Œå‘½ä»¤æ˜¯é€šè¿‡pythonè„šæœ¬ç¼–å†™çš„ï¼Œå¦‚æœè¦è¿è¡Œsystraceéœ€è¦å®Œæˆå¦‚ä¸‹æ­¥éª¤ï¼š

1. ä¸‹è½½å®‰è£…Android SDKå·¥å…·ï¼ˆè¿™ä¸ªä¸€èˆ¬éƒ½ä¸ç”¨äº†å§ï¼‰
2. å°† `android-sdk/platform-tools/` æ·»åŠ åˆ° `PATH` ç¯å¢ƒå˜é‡
3. å®‰è£…[python](https://www.python.org/downloads/)ï¼Œå¹¶é…ç½®ç¯å¢ƒï¼ˆä¸ä¼šçš„[çœ‹è¿™é‡Œ](https://www.runoob.com/python/python-install.html)ï¼‰
4. ä½¿ç”¨USB adbå°†Android4.3(API18)åŠä»¥ä¸Šè®¾å¤‡è¿æ¥åˆ°å¼€å‘ç³»ç»Ÿï¼Œç„¶ååœ¨å‘½ä»¤è¡Œè¿è¡Œå¦‚ä¸‹å‘½ä»¤ï¼š

```xml
// â˜… æŸ¥çœ‹pythonç‰ˆæœ¬ï¼Œæ£€æŸ¥ç¯å¢ƒæ˜¯å¦é…ç½®æˆåŠŸ
> python -V 

// â˜… cdåˆ°systrace.pyæ‰€åœ¨ç›®å½•
> cd F:\IDE\sdk\platform-tools\systrace

// â˜… -lå‚æ•°åˆ—å‡ºå·²è¿æ¥è®¾å¤‡å¯ç”¨çš„è·Ÿè¸ªç±»åˆ«
> python systrace.py -l
	  //é”™è¯¯ï¼šSystraceä¸æ”¯æŒpython3.xç‰ˆæœ¬ï¼Œè¯·ä½¿ç”¨python2.7.xç‰ˆæœ¬ï¼Œfuckï¼Œé‡æ–°æ‰¾å¯¹åº”ç‰ˆæœ¬å®‰è£…ï¼Œæ³¨æ„æˆ‘é‡æ–°å®‰è£…çš„æ˜¯2.7.9ç‰ˆæœ¬
      Systrace does not support Python 3.9. Please use Python 2.7.

// å®‰è£…Python2.7.9ç‰ˆæœ¬å®Œæˆåé‡å¤ä¸Šé¢çš„å‘½ä»¤
> python systrace.py -l
	  //é”™è¯¯ï¼šæ‰¾ä¸åˆ°win32conæ¨¡å—ï¼Œå®‰è£…pythonæ‰©å±•æ¨¡å—
      ImportError: No module named win32con

// å®‰è£…pythonæ‰©å±•æ¨¡å—ï¼Œå¯ä»¥ç›´æ¥å»ç½‘ä¸Šæœç›¸åº”æ¨¡å—åŒ…ä¸‹è½½å®‰è£…ï¼Œæ¯”å¦‚ä»https://github.com/mhammond/pywin32/releasesä¸­ä¸‹è½½å®‰è£…win32conæ‰©å±•
// ç”±äºpythonæœ‰å¾ˆå¤šæ‰©å±•æ¨¡å—ï¼Œä¸ºäº†å®‰è£…æ–¹ä¾¿å¯ä»¥é€šè¿‡pipç›´æ¥å®‰è£…ï¼Œå¦‚æœä½ çš„pythonç‰ˆæœ¬æ˜¯2.7.9åŠä»¥ä¸Šç‰ˆæœ¬å·²ç»è‡ªå¸¦pipï¼Œå¦åˆ™éœ€è¦å…ˆå»https://pip.pypa.io/en/latest/installing/ä¸‹è½½å®‰è£…pip
// æˆ‘çš„pythonæ˜¯2.7.9ç‰ˆæœ¬çš„ï¼Œç›´æ¥é€šè¿‡ä¸‹é¢å‘½ä»¤å®‰è£…éœ€è¦çš„æ‰©å±•
> py -m pip install pypiwin32
	   //å®‰è£…pypiwin32å¤±è´¥ï¼Œæ‰€ä»¥è¿˜æ˜¯è€è€å®å®æ‰“å¼€ä¸Šé¢ç»™å‡ºçš„é“¾æ¥ä¸‹è½½å®‰è£…win32conæ‰©å±•
       Could not find any downloads that satisfy the requirement pywin32>=223 (from pypiwin32)
> py -m pip install six    //æ³¨æ„è¿˜éœ€è¦å®‰è£…sixæ‰©å±•

// â˜… å†æ¬¡åˆ—å‡ºå¯è·Ÿè¸ªç±»åˆ«
> python systrace.py -l
        gfx - Graphics
        input - Input
        view - View System
        webview - WebView
        wm - Window Manager
        am - Activity Manager
        sm - Sync Manager
		...

// â˜…â˜…â˜… ä½¿ç”¨pythonæ‰§è¡Œsystrace.pyè„šæœ¬è®°å½•è®¾å¤‡æ´»åŠ¨,å‚æ•°è¯´æ˜å¦‚ä¸‹
// -o ï¼šå°†HTMLè·Ÿè¸ªæŠ¥å‘Šå†™å…¥æŒ‡å®šçš„æ–‡ä»¶,å¦‚æœªæŒ‡å®šï¼Œå°†ä¼šä¿å­˜ä¸ºsystrace.pyæ‰€åœ¨çš„ç›®å½•ä¸­çš„trace.htmlæ–‡ä»¶
// -a ï¼šæŒ‡å®šåº”ç”¨åŒ…å
// categoriesï¼šåé¢çš„éƒ½æ˜¯éœ€è¦è·Ÿè¸ªçš„ç±»åˆ«ï¼Œæ”¯æŒä»€ä¹ˆç±»åˆ«ä»ä¸Šé¢åˆ—å‡ºçš„æ”¯æŒç±»åˆ«ä¸­æŸ¥çœ‹
> python systrace.py -o mynewtrace.html -a syberos.sdisclient am pm sm app res
	//è¾“å…¥ä¸Šé¢çš„å‘½ä»¤å›è½¦ä¼šæ‰“å°å¦‚ä¸‹å†…å®¹ï¼Œè¿™æ—¶å€™å¼€å§‹æ“ä½œåº”ç”¨ï¼Œéœ€è¦ç»“æŸè¿½è¸ªæ—¶å†æ¬¡å›è½¦å³å¯
	Starting tracing (stop with enter)
    //æ“ä½œå®Œæˆï¼Œå†æ¬¡å›è½¦åœæ­¢è®°å½•ï¼Œè¾“å‡ºè®°å½•æŠ¥å‘Šï¼Œè¿™é‡Œéœ€è¦ç­‰ä¸€ä¼šå„¿
	Tracing completed. Collecting output...
```

æ›´å¤šsystraceå‘½ä»¤å‚æ•°è¯·å‚è€ƒ[ğŸ”—åœ¨å‘½ä»¤è¡Œä¸Šæ•è·ç³»ç»Ÿè·Ÿè¸ªè®°å½•](https://developer.android.google.cn/topic/performance/tracing/command-line)ã€‚é€šè¿‡å‘½ä»¤çš„æ–¹å¼æŠ“å–æŠ¥å‘Šæ˜¯æœ€æ–¹ä¾¿çš„ï¼Œå½“ç„¶å¯èƒ½æœ‰äº›åŒå­¦æ„Ÿè§‰è¦å»å®‰è£…pythonå¥½éº»çƒ¦å“¦ï¼Œå…¶å®ä¸‹è½½å®‰è£…é…ç½®ç¯å¢ƒä¹Ÿå°±å‡ åˆ†é’Ÿçš„äº‹ï¼Œå®‰è£…å®Œå°±ä¸€åŠ³æ°¸é€¸äº†ã€‚å½“ç„¶ï¼Œå®åœ¨è§‰å¾—éº»çƒ¦ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ä¸‹é¢ç¬¬ä¸‰ç§æ–¹æ³•é€šè¿‡DDMSæŠ“å–

#### â‘¡. æ•è·è®¾å¤‡ä¸Šçš„ç³»ç»Ÿè·Ÿè¸ªè®°å½•

Android9(API28)åŠä»¥ä¸Šç‰ˆæœ¬çš„è®¾å¤‡ä¸­åŒ…å«ä¸€ä¸ªåä¸ºSystem Tracingçš„ç³»ç»Ÿçº§åº”ç”¨ã€‚æ­¤åº”ç”¨ç±»ä¼¼äºsystraceå‘½ä»¤è¡Œå®ç”¨å·¥å…·ï¼Œä½†å¯ä»¥ç›´æ¥ä»æµ‹è¯•è®¾å¤‡æœ¬èº«å½•åˆ¶è·Ÿè¸ªè®°å½•ï¼Œæ— éœ€æ’å…¥è®¾å¤‡å¹¶é€šè¿‡ADBè¿æ¥åˆ°è¯¥è®¾å¤‡ã€‚å¦‚æœä½ çš„æµ‹è¯•æœºæ˜¯Android9ä»¥ä¸Šï¼Œå¯ä»¥è¯•è¯•[ğŸ”—å½•åˆ¶ç³»ç»Ÿè·Ÿè¸ªè®°å½•](https://developer.android.google.cn/topic/performance/tracing/on-device)

#### â‘¢. é€šè¿‡Android Device MonitoræŠ“å–

ç”±äºAndroid Studio3.0å¼€å§‹å¼ƒç”¨äº†Android Device Monitorï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å·¥å…·ï¼Œæˆ‘ä»¬éœ€è¦è‡ªè¡Œè¿›å…¥`sdk/tools/lib/monitor-x86_64/monitor.exe`è¿è¡Œmonitor.exeå¯åŠ¨Androidè®¾å¤‡ç›‘è§†å™¨ï¼Œç„¶åæŒ‰ç…§ä¸‹å›¾æ­¥éª¤æŠ“å–æŠ¥å‘Šï¼ŒæŠ“å–å®Œå°±å¯ä»¥åœ¨ç¬¬2æ­¥è®¾ç½®çš„æ–‡ä»¶ä½ç½®æ‰¾åˆ°æŠ¥å‘Šæ–‡ä»¶äº†

![](pic/2-3-2-ADMSysTrace.png)



#### â‘£. SystraceæŠ¥å‘Šåˆ†æ

ä¸ç®¡ä½¿ç”¨ä¸Šé¢ä¸‰ç§æ–¹å¼ä¸­çš„å“ªä¸€ç§ï¼Œæœ€ç»ˆéƒ½ä¼šå¾—åˆ°ä¸€ä¸ªhtmlæ ¼å¼çš„æŠ¥å‘Šæ–‡ä»¶ï¼Œæ‰“å¼€**Chrome**æµè§ˆå™¨ï¼Œåœ°å€æ è¾“å…¥`chrome://tracing/`ï¼Œç„¶åå°†æŠ¥å‘Šæ–‡ä»¶æ‹–å…¥æµè§ˆå™¨ä¸­å³å¯ã€‚



> å¦‚éœ€è¯¦ç»†äº†è§£åº”ç”¨æ­£åœ¨æ‰§è¡Œå“ªäº›æ–¹æ³•åŠå…¶å ç”¨äº†å¤šå°‘CPUèµ„æºï¼Œè¿˜æ˜¯åº”è¯¥ä½¿ç”¨ä¸Šè¿°Android Studio CPUæ€§èƒ½å‰–æå™¨ã€‚




# 2. (ä¼˜åŒ–)ç»„ä»¶åŒ–ä¸­çš„Retrofitä½¿ç”¨äº«å…ƒæ¨¡å¼æ€æƒ³é‡ç”¨æ¥å£åŠ¨æ€ä»£ç†å¯¹è±¡

äº«å…ƒæ¨¡å¼å°è¯•é‡ç”¨ç°æœ‰çš„åŒç±»å¯¹è±¡ï¼Œå¦‚æœæœªæ‰¾åˆ°åŒ¹é…çš„å¯¹è±¡ï¼Œåˆ™åˆ›å»ºæ–°å¯¹è±¡ï¼Œç”¨äºå‡å°‘åˆ›å»ºå¯¹è±¡çš„æ•°é‡ï¼Œä»¥å‡å°‘å†…å­˜å ç”¨å’Œæé«˜æ€§èƒ½ï¼Œè¿™ç§ç±»å‹çš„è®¾è®¡æ¨¡å¼å±äºç»“æ„å‹æ¨¡å¼ã€‚è¯´çš„ç®€å•ä¸€ç‚¹å°±æ˜¯ï¼Œä¸€æ®µç¨‹åºä¸­ç»å¸¸éœ€è¦åˆ›å»ºæŸç§ç±»å‹çš„å¯¹è±¡ï¼Œè€Œå¯¹è±¡çš„æ•°é‡æ˜¯æœ‰é™çš„ï¼Œå¯ä»¥å°†å·²ç»åˆ›å»ºçš„å¯¹è±¡ç¼“å­˜èµ·æ¥ï¼Œä¸‹æ¬¡è¦åˆ›å»ºè¿™ä¸ªå¯¹è±¡æ—¶ç›´æ¥ä»ç¼“å­˜ä¸­æ‹¿ï¼Œç¼“å­˜ä¸­æ²¡æœ‰å°±å»åˆ›å»ºã€‚Retrofitä¸­åˆ›å»ºæ¥å£æ–¹æ³•`ServiceMethod`å¯¹è±¡æ—¶å°±ç”¨åˆ°äº†äº«å…ƒæ¨¡å¼ï¼š

```java
public final class Retrofit {
  private final Map<Method, ServiceMethod<?>> serviceMethodCache = new ConcurrentHashMap<>();
  //è°ƒç”¨æ¥å£æ–¹æ³•æ—¶ï¼Œä½¿ç”¨äº«å…ƒæ¨¡å¼å°è¯•ä»ç¼“å­˜ä¸­è·å–ï¼Œè¿™æ ·é¿å…ä¸€ä¸ªæ¥å£è¢«è°ƒç”¨å¤šæ¬¡æ—¶æ¯æ¬¡éƒ½è¦è§£ææ¥å£æ–¹æ³•çš„æ³¨è§£å’Œå‚æ•°
  ServiceMethod<?> loadServiceMethod(Method method) {
    //å–ç¼“å­˜
    ServiceMethod<?> result = serviceMethodCache.get(method);
    if (result != null) return result;
    synchronized (serviceMethodCache) {
      result = serviceMethodCache.get(method);
      if (result == null) {
        //åˆ›å»ºå¹¶ç¼“å­˜
        result = ServiceMethod.parseAnnotations(this, method);
        serviceMethodCache.put(method, result);
      }
    }
    return result;
  }
}
```

ä¸€ä¸ªå¤§é¡¹ç›®æ ¹æ®ä¸šåŠ¡åˆ’åˆ†ä¸ºå¤šä¸ªæ¨¡å—ï¼Œä¸åŒæ¨¡å—ä¸­ä½¿ç”¨åˆ°çš„æœåŠ¡å™¨æ¥å£ä¸åŒï¼Œé€šå¸¸ä¼šå°†Retrofitæ¥å£å®šä¹‰åˆ°å¯¹åº”çš„moduleä¸­ï¼Œç„¶åé€šè¿‡`RetrofitClient.retrofit.create(ModuleApiService::class.java)`è·å–æ¥å£åŠ¨æ€ä»£ç†å¯¹è±¡ï¼Œå¦‚æœæ¯æ¬¡è¯·æ±‚æ¥å£éƒ½åˆ›å»ºä¸€ä¸ªæ¥å£ä»£ç†å¯¹è±¡è‚¯å®šä¸åˆé€‚ï¼Œæ‰€ä»¥é€šè¿‡**äº«å…ƒæ¨¡å¼**çš„æ€æƒ³å¯¹ç°æœ‰ä»£ç†å¯¹è±¡è¿›è¡Œç¼“å­˜é‡ç”¨ï¼š

```kotlin
object RetrofitClient {
    private val okHttpClient = OkHttpClient.Builder()
            .retryOnConnectionFailure(true)
            .connectTimeout(4000, TimeUnit.MILLISECONDS)       //IPè¿æ¥è¶…æ—¶
            .dns(TimeOutDns(4000, TimeUnit.MILLISECONDS))
            .readTimeout(20000, TimeUnit.MILLISECONDS)
            .writeTimeout(30000, TimeUnit.MILLISECONDS)
            .addInterceptor(TokenInterceptor()) //must call proceed() exactly once
            .addInterceptor(HttpUrlInterceptor())
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = if(AppConfig.DEBUG)
                    HttpLoggingInterceptor.Level.BODY
                else HttpLoggingInterceptor.Level.BASIC
            })
            .build()


    /**Retrofit*/
    private val retrofit = Retrofit.Builder()
        .client(okHttpClient)
        .baseUrl(PublicApiService.TEST_URL)
        .addConverterFactory(MoshiConverterFactory.create())
        .addCallAdapterFactory(CoroutinesResponseCallAdapterFactory())
        .build()

    /**ApiService*/
    private val serviceMap = mutableMapOf<Class<out Any>, Any>()
    //è·å–åŠ¨æ€ä»£ç†å¯¹è±¡
    fun <S> getService(javaClass : Class<out S>) : S{
        //äº«å…ƒæ¨¡å¼é‡ç”¨ç°æœ‰å¯¹è±¡
        if(!serviceMap.containsKey(javaClass)){
            serviceMap.put(javaClass, retrofit.create(javaClass)!!)
        }
        return serviceMap[javaClass] as S
    }
}
```

# 3. (ä¼˜åŒ–)Retrofit+OkHttpä¸‹è½½ã€ä¸Šä¼ æ–‡ä»¶æ—¶è¿›åº¦æ¡å¡é¡¿

## 3.1 é—®é¢˜

```kotlin
//1 æ–‡ä»¶ä¸Šä¼ 
@Multipart
@POST("/jeecg-boot/cmds/attachment/uploadMultipleFile")
suspend fun uploadFile(@PartMap map:MutableMap<String, RequestBody>, @Part parts:MutableList<MultipartBody.Part>): ApiResult<String>

//2 æ–‡ä»¶ä¸‹è½½
@Streaming
@GET
suspend fun downloadFile(@Url url: String): Response<ResponseBody>

fun downloadFile(path: String, build: IDownloadBuild) = flow {
        val response = getService(PublicApiService::class.java).downloadFile(path)
        response.body()?.let { body ->
            val allLength = body.contentLength()
            val contentType = body.contentType().toString()
            val inputStream = body.byteStream()
            val info = try {
                dowloadBuildToOutputStream(build, contentType)
            } catch(e:Exception){
                emit(DownloadStatus.DownloadErron(e))
                DownloadInfo(null)
                return@flow
            }
            val outputStream = info.ops
            if (outputStream == null) {
                emit(DownloadStatus.DownloadErron(RuntimeException("ä¸‹è½½å‡ºé”™")))
                return@flow
            }
            //å½“å‰ä¸‹è½½é•¿åº¦
            var currentLength = 0
            //å†™å…¥æ–‡ä»¶ï¼Œæ¯æ¬¡è¯»å–8kb
            val bufferSize = 1024 * 8
            val buffer = ByteArray(bufferSize)
            val bufferedInputStream = BufferedInputStream(inputStream, bufferSize)
            var readLength = 0
            FLog.e("æ–‡ä»¶æ€»é•¿åº¦ï¼š$allLength")
            while (bufferedInputStream.read(buffer, 0, bufferSize).also { readLength = it } != -1) {
                outputStream.write(buffer, 0, readLength)
                outputStream.flush()
                currentLength += readLength
                //â˜… å‘å°„ä¸‹è½½è¿›åº¦ï¼Œä¸»çº¿ç¨‹ä¸­æ”¶åˆ°åæ›´æ–°è¿›åº¦æ¡
                FLog.e("å‘å°„è¿›åº¦ï¼š${currentLength.toFloat() / allLength.toFloat()}")
                emit(
                        DownloadStatus.DownloadProcess(
                                currentLength.toLong(),
                                allLength,
                                currentLength.toFloat() / allLength.toFloat()
                        )
                )
            }
            bufferedInputStream.close()
            outputStream.close()
            inputStream.close()
            if (info.uri != null)
                emit(DownloadStatus.DownloadSuccess(info.uri))
            else
                emit(DownloadStatus.DownloadSuccess(Uri.fromFile(info.file)))
        } ?: kotlin.run {
            emit(DownloadStatus.DownloadErron(RuntimeException("ä¸‹è½½å‡ºé”™")))
        }

    }.flowOn(Dispatchers.IO)
```

é€šè¿‡åç¨‹çš„`flow{}`è°ƒç”¨Retrofitä¸‹è½½æ–‡ä»¶æ¥å£çš„æ—¶å€™ï¼Œé€šè¿‡å¾ªç¯è¯»å–ResponseBodyçš„`byteStream()`è¾“å…¥æµå°†æ•°æ®å†™å…¥æœ¬åœ°æ–‡ä»¶ï¼Œæ¯æ¬¡è¯»å–8kbï¼Œç„¶åå‘å°„è¿›åº¦ç»™ä¸»çº¿ç¨‹æ›´æ–°ä¸‹è½½è¿›åº¦æ¡ã€‚ç°è±¡æ˜¯ä¸‹è½½è¿‡ç¨‹ä¸­ï¼Œâ€œå‘å°„è¿›åº¦â€çš„logæ‰“å°æ­£å¸¸ï¼Œä½†æ˜¯é¡µé¢ä¸Šè¿›åº¦æ¡ä¸æ›´æ–°ï¼Œç›´åˆ°ä¸‹è½½æˆåŠŸçš„å‰ä¸€åˆ»ï¼Œè¿›åº¦æ¡çªç„¶å°±å˜ä¸º100%ã€‚è§‚å¯ŸLogcatæ—¥å¿—ï¼Œå‘ç°è¿™æ®µæ—¶é—´åªæœ‰GCæ—¥å¿—ï¼Œè¯´æ˜å†…å­˜å ç”¨ä¸¥é‡ï¼Œé€šè¿‡Android Studio Profilerå¯¹å†…å­˜è¿›è¡Œç›‘æµ‹å¯ä»¥è¯å®åœ¨æ–‡ä»¶ä¸‹è½½è¿‡ç¨‹ä¸­ï¼Œå†…å­˜ç¡®å®å ç”¨è¿‡é«˜ã€‚é€šè¿‡æ’æŸ¥ï¼Œå‘ç°é—®é¢˜æ˜¯**OkHttpæ—¥å¿—æ‹¦æˆªå™¨ä¸­æ‰“å°çš„Bodyå†…å®¹å¤ªå¤šé€ æˆå†…å­˜å ç”¨ä¸¥é‡é€ æˆçš„å¡é¡¿**ã€‚

```kotlin
private val okHttpClient = OkHttpClient.Builder()
    ...
    .addInterceptor(HttpLoggingInterceptor().apply {
        level = if(AppConfig.DEBUG)  //debugæ¨¡å¼ä¸‹æ‰“å°è¯·æ±‚å’Œå“åº”ä½“
            HttpLoggingInterceptor.Level.BODY
        else HttpLoggingInterceptor.Level.BASIC
    })
    .build()

```

åœ¨æµ‹è¯•ç‰ˆæœ¬ä¸­ï¼Œé€šå¸¸è®¾ç½®levelä¸ºbodyï¼Œä»è€Œæ‰“å°å®Œæ•´çš„è¯·æ±‚å’Œè¿”å›ä½“æ–¹ä¾¿è°ƒè¯•ï¼Œä½†å½“è¯·æ±‚ä¸ºä¸Šä¼ æ–‡ä»¶æˆ–è€…ä¸‹è½½æ–‡ä»¶æ—¶ï¼Œç”±äºå®ä½“ä¸­æ•°æ®é‡è¾ƒå¤§ï¼Œå°†bodyä¸­çš„æ•°æ®å†™å…¥ç¼“å†²åŒº`requestBody!!.writeTo(buffer)` or `responseBody.source().buffer()`çš„æ“ä½œä¼šå ç”¨å¤§é‡å†…å­˜ï¼Œé€ æˆç¨‹åºå¡é¡¿ï¼Œæ¯”å¦‚ä¸‹è½½è¿›åº¦ä¸æ›´æ–°ç­‰æƒ…å†µã€‚

##  3.2 è§£å†³

è§£å†³åŠæ³•å¯ä»¥ç²—æš´çš„**å°†Levelè®¾ç½®ä¸ºBODYä»¥ä¸Šçº§åˆ«**ï¼Œå¦‚`HEADERS`ã€`BASIC`ã€`NONE`ï¼Œä½†æ˜¯è¿™æ ·åœ¨å¼€å‘æ—¶å°±çœ‹ä¸åˆ°å®Œæ•´çš„è¯·æ±‚å†…å®¹äº†ï¼Œæ¯”å¦‚æˆ‘è¦çœ‹ä¼ é€’ç»™åå°çš„å‚æ•°æ˜¯ä»€ä¹ˆï¼Œè¿™äº›éƒ½æ˜¯åœ¨å®ä½“ä¸­çš„ã€‚æ‰€ä»¥Debugæ¨¡å¼ä¸‹Levelå¿…é¡»è®¾ç½®ä¸ºBODYï¼Œè¿™æ ·å°±åªèƒ½**é€šè¿‡è‡ªå®šä¹‰`HttpLoggingInterceptor`ï¼Œåˆ¤æ–­å®ä½“çš„`Content-Type`å†…å®¹ç±»å‹ï¼Œå¦‚æœå‘ç°æ˜¯`multipart/form-data`è¡¨å•æ–‡ä»¶ä¸Šä¼ æˆ–è€…æ˜¯`application/octet-stream`äºŒè¿›åˆ¶æµæ•°æ®ä¸‹è½½ï¼Œåˆ™ä¸è¿›è¡Œå°†å®ä½“åŠ è½½åˆ°ç¼“å†²åŒºåè½¬æ¢ä¸ºå­—ç¬¦ä¸²æ‰“å°çš„æ“ä½œ**ï¼Œå®Œæ•´çš„æ—¥å¿—æ‹¦æˆªå™¨å¦‚ä¸‹ï¼ˆå¯¹äºå®ä½“ç±»å‹çš„åˆ¤æ–­ï¼Œå¯ç»“åˆé¡¹ç›®æ ¹æ®å®é™…æƒ…å†µè¿›è¡Œæ”¹é€ ï¼‰ï¼š

```kotlin
/**
 * Author: openXu
 * Time: 2021/4/28 10:09
 * class: HttpLoggingInterceptor
 * Description:
 */
class HttpLoggingInterceptor(private val logger: Logger) : Interceptor{
    private val UTF8 = Charset.forName("UTF-8")
    
    var level = Level.NONE

    enum class Level {
        NONE, BASIC, HEADERS, BODY
    }
    interface Logger {
        fun log(message: String?)
        companion object {
            val DEFAULT: Logger = object : Logger {
                override fun log(message: String?) {
                    Platform.get().log(Platform.INFO, message, null)
                }
            }
        }
    }
    constructor() : this(Logger.DEFAULT)

    override fun intercept(chain: Interceptor.Chain): Response {
        FLog.w("æ—¥å¿—æ‹¦æˆªå™¨============")
        /**æ‰“å°è¯·æ±‚æ—¥å¿—*/
        val request = chain.request()
        if (level == Level.NONE)  //ä¸æ‰“å°æ—¥å¿—
            return chain.proceed(request)

        val logBody = level == Level.BODY
        val logHeaders = logBody || level == Level.HEADERS
        val requestBody = request.body()
        val hasRequestBody = requestBody != null
        val connection = chain.connection()
        val protocol = if (connection != null) connection.protocol() else Protocol.HTTP_1_1
        // --> GET http://39.98.164.162:8080/jeecg-boot/public/GetTaskCount http/1.1
        var requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol
        if (!logHeaders && hasRequestBody) {
            requestStartMessage += " (" + requestBody!!.contentLength() + "-byte body)"
        }
        logger.log(requestStartMessage)
        if (logHeaders) {   //æ‰“å°è¯·æ±‚å¤´  å¦‚ï¼šConnection: keep-alive ...
            requestBody?.let {
                if (requestBody.contentType() != null) logger.log("Content-Type: " + requestBody.contentType())
                if (requestBody.contentLength() != -1L) logger.log("Content-Length: " + requestBody.contentLength())
            }
            val headers = request.headers()
            var i = 0
            while (i < headers.size()) {
                val name = headers.name(i)
                if (!"Content-Type".equals(name, ignoreCase = true) && !"Content-Length".equals(name, ignoreCase = true))
                    logger.log(name + ": " + headers.value(i))
                i++
            }
            if (!logBody || !hasRequestBody) {
                logger.log("--> END " + request.method())
            } else if (bodyEncoded(request.headers())) {
                logger.log("--> END " + request.method() + " (encoded body omitted)")
            } else {
                val contentType = requestBody!!.contentType()
                /**â˜…â˜…â˜… æ‰“å°è¯·æ±‚å®ä½“æ•°æ®ä¹‹å‰ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºä¸Šä¼ è¡¨å•æ–‡ä»¶ï¼Œå¦‚æœæ˜¯åˆ™æ‹¦æˆªä¸è¿›è¡Œæ‰“å°*/
                if(!interceptLog(false, contentType, requestBody.contentLength())){
                    val buffer = Buffer()
                    requestBody.writeTo(buffer)   //â˜…â˜…â˜… å ç”¨å¤§é‡å†…å­˜
                    logger.log("")
                    if (isPlaintext(buffer)) {
                        var charset = UTF8
                        if (contentType != null)
                            charset = contentType.charset(UTF8)
                        logger.log(buffer.readString(charset))   //æ‰“å°è¯·æ±‚å®ä½“bodyæ•°æ®
                        logger.log("--> END ${request.method()} (${requestBody.contentLength()}-byte body)")
                    } else {
                        logger.log("--> END ${request.method()} (binary ${requestBody.contentLength()}-byte body omitted))")
                    }
                }
            }
        }
        /**æ‰“å°å“åº”æ—¥å¿—*/
        val startNs = System.nanoTime()
        val response: Response
        response = try {
            chain.proceed(request)
        } catch (e: Exception) {
            logger.log("<-- HTTP FAILED: $e")  //è¯·æ±‚å¤±è´¥
            throw e
        }
        val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)

        val responseBody = response.body()
        val contentLength = responseBody!!.contentLength()
        val bodySize = if (contentLength != -1L) "$contentLength-byte" else "unknown-length"
        logger.log("<-- ${response.code()} ${response.message()} ${response.request().url()} (${tookMs}ms"
                + (if (!logHeaders) ", $bodySize body" else "") + ')')

        if (logHeaders) {
            val headers = response.headers()
            var i = 0
            while (i < headers.size()) {
                logger.log(headers.name(i) + ": " + headers.value(i))
                i++
            }
            if (!logBody || !HttpHeaders.hasBody(response)) {
                logger.log("<-- END HTTP")
            } else if (bodyEncoded(response.headers())) {
                logger.log("<-- END HTTP (encoded body omitted)")
            } else {
                val contentType = responseBody.contentType()
                /**â˜…â˜…â˜… åœ¨æ‰“å°å®ä½“æ•°æ®ä¹‹å‰ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºä¸‹è½½äºŒè¿›åˆ¶æ–‡ä»¶æµï¼Œå¦‚æœæ˜¯åˆ™æ‹¦æˆªä¸è¿›è¡Œæ‰“å°*/
                if(!interceptLog(false, contentType, responseBody.contentLength())){
                    val source = responseBody.source()
                    source.request(Long.MAX_VALUE) // Buffer the entire body.
                    val buffer = source.buffer()  //â˜…â˜…â˜… å ç”¨å¤§é‡å†…å­˜
                    if (!isPlaintext(buffer)) {
                        logger.log("")
                        logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)")
                        return response
                    }
                    var charset = UTF8
                    contentType?.let {
                        charset = try {  //è·å–å“åº”ä½“å­—ç¬¦ç¼–ç æ ¼å¼
                            contentType.charset(UTF8)
                        } catch (e: UnsupportedCharsetException) {
                            logger.log("")
                            logger.log("Couldn't decode the response body; charset is likely malformed.")
                            logger.log("<-- END HTTP")
                            return response
                        }
                    }
                    if (contentLength != 0L) {
                        logger.log("")
                        logger.log(buffer.clone().readString(charset))
                    }
                    logger.log("<-- END HTTP (" + buffer.size() + "-byte body)")
                }
            }
        }

        return response
    }

    private fun interceptLog(isResponse: Boolean, mediaType: MediaType?, contentLength: Long) :Boolean {
        if(mediaType==null)
            return false
        val mediaTypeStr = mediaType?.toString()  //application/json;charset=UTF-8
        val type = mediaType?.type()        //application
        val subtype = mediaType?.subtype()  ///json
        val requestOrReponse = if(isResponse) "å“åº”è¿”å›" else "è¯·æ±‚å‘é€"
        /**â˜…â˜…â˜…â˜…â˜…â˜… å½“å®ä½“ç±»å‹ä¸ºä¸Šä¼ è¡¨å•æ–‡ä»¶ or ä¸‹è½½äºŒè¿›åˆ¶æµæ•°æ®æ—¶ å¯¹å…¶æ‹¦æˆªï¼Œä¸æ‰“å°å®ä½“æ•°æ®*/
        when(type){
            "multipart" -> {logger.log(">>>>>${requestOrReponse}è¡¨å•orä¸Šä¼ æ–‡ä»¶ï¼Œå¤§å°ä¸º${contentLength}"); return true}
            "application" -> when (subtype) {
                "octet-stream" -> {logger.log("<<<<<$requestOrReponse äºŒè¿›åˆ¶æµæ•°æ®ï¼ˆå¦‚å¸¸è§çš„æ–‡ä»¶ä¸‹è½½)ï¼Œå¤§å°ä¸º${contentLength}"); return true}
            }
        }
        return false
    }

    private fun isPlaintext(buffer: Buffer): Boolean {
        return try {
            val prefix = Buffer()
            val byteCount = if (buffer.size() < 64) buffer.size() else 64
            buffer.copyTo(prefix, 0, byteCount)
            for (i in 0..15) {
                if (prefix.exhausted()) {
                    break
                }
                val codePoint = prefix.readUtf8CodePoint()
                if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
                    return false
                }
            }
            true
        } catch (e: EOFException) {
            false
        }
    }

    private fun bodyEncoded(headers: Headers): Boolean {
        val contentEncoding = headers["Content-Encoding"]
        return contentEncoding != null && !contentEncoding.equals("identity", ignoreCase = true)
    }
}
```

# 4. (å‘)åŠ¨æ€æ‹¦æˆªæ›¿æ¢BaseUrlåä¸‹è½½ä¸äº†æ–‡ä»¶

é¡¹ç›®ä¸­éœ€è¦åŠ¨æ€é€‰æ‹©æœåŠ¡å™¨åœ°å€ï¼Œå°†åœ°å€ä¿å­˜åœ¨æœ¬åœ°ï¼Œä¸éœ€è¦é‡å¯è¾¾åˆ°å®æ–½æ›´æ–°BaseUrlçš„ç›®çš„ï¼Œé€šå¸¸ä¼šåœ¨æ‹¦æˆªå™¨ä¸­è¿›è¡Œæ›¿æ¢ï¼Œè¿™æ ·æ‰€æœ‰çš„è¯·æ±‚åœ¨å‘èµ·ä¹‹å‰éƒ½ä¼šè¢«åŠ¨æ€ä¿®æ”¹BaseUrlï¼Œæµ‹è¯•é˜¶æ®µå‘ç°æ–‡ä»¶ä¸‹è½½å¤±è´¥ï¼ŒåŸå› æ˜¯**æ–‡ä»¶åœ°å€æ˜¯åå°è¿”å›çš„å…¨è·¯å¾„ï¼Œåœ¨ä¸‹è½½æ–‡ä»¶ä¹‹å‰å°†å…¨è·¯å¾„ä¸­çš„ä¸»æœºç»™åŠ¨æ€ä¿®æ”¹äº†ï¼Œé€ æˆè®¿é—®ä¸åˆ°æ–‡ä»¶ã€‚**è§£å†³åŠæ³•æ˜¯ï¼Œåœ¨ä¸‹è½½æ–‡ä»¶çš„æ¥å£å®šä¹‰ä¸Šæ·»åŠ ä¸€ä¸ªè‡ªå®šä¹‰Headerï¼Œæ‹¦æˆªå™¨ä¸­åˆ¤æ–­å¦‚æœå¸¦æœ‰è¿™ä¸ªheaderçš„è¯·æ±‚éƒ½ä¸è¿›è¡Œä¸»æœºæ›¿æ¢ï¼š

```kotlin
/*2 æ–‡ä»¶ä¸‹è½½*/
@Streaming
@Headers("isDownload: true")   //è‡ªå®šä¹‰headeré¿å…æ›¿æ¢baseUrl
@GET
suspend fun downloadFile(@Url url: String): Response<ResponseBody>

class HttpUrlInterceptor : Interceptor {

    override fun intercept(chain: Interceptor.Chain): Response  {
        val oldRequest = chain.request()
        var httpUrl:HttpUrl = oldRequest.url()

        val isDownload = oldRequest.header("isDownload")
        FLog.w("â˜…â˜…â˜…åˆ¤æ–­æ˜¯å¦æ˜¯æ–‡ä»¶ä¸‹è½½è¯·æ±‚ï¼ˆæ˜¯å¦æœ‰è‡ªå®šä¹‰isDownloadè¯·æ±‚å¤´ï¼‰: $isDownload")
        if(!isDownload.isNullOrEmpty()){
            FLog.d("æ–‡ä»¶ä¸‹è½½ä¸éœ€è¦æ›¿æ¢BaseUrlï¼Œå› ä¸ºæ˜¯åå°è¿”å›çš„æ–‡ä»¶å…¨è·¯å¾„")
        }else{
            try {
                val addr = MMKV.defaultMMKV()?.decodeString(Mmkv.KEY_ADDRESS)
                val port = MMKV.defaultMMKV()?.decodeInt(Mmkv.KEY_PORT)
                val baseUrl = HttpUrl.parse("http://$addr:$port")
                httpUrl = httpUrl
                        .newBuilder()
                        //åŠ¨æ€ä¿®æ”¹BaseUrl
                        .scheme(baseUrl?.scheme())
                        .host(baseUrl?.host())
                        .port(baseUrl?.port()!!)
                        .build()
                FLog.w("åŠ¨æ€æ›¿æ¢BaseUrlåï¼š$httpUrl")
                if(httpUrl==null)
                    throw IOException("æ›¿æ¢åŸŸåå¤±è´¥:$httpUrl")
            }catch (e:Exception){
                throw IOException("æ›¿æ¢åŸŸåå¤±è´¥:${e.message}")
            }
        }

        var token = MMKV.defaultMMKV()?.decodeString(Mmkv.KEY_TOKEN)
        val request = oldRequest.newBuilder()
                .url(httpUrl)
                .addHeader("Connection", "keep-alive")
                .addHeader("Content-Type","application/json;charset=UTF-8")
                //æ¥å—ä»»ä½• MIME ç±»å‹çš„èµ„æºï¼Œæ”¯æŒé‡‡ç”¨ gzipã€deflate æˆ– sdch å‹ç¼©è¿‡çš„èµ„æº
                .addHeader("Accept", "*/*")   //å‘ŠçŸ¥æœåŠ¡å™¨å‘é€ä½•ç§åª’ä½“ç±»å‹  å¯¹åº”å“åº”å¤´Content-Type
                //å¯ä»¥æ¥å— zh-CNã€en-US å’Œ en ä¸‰ç§è¯­è¨€ï¼Œå¹¶ä¸” zh-CN çš„æƒé‡æœ€é«˜ï¼ˆq å–å€¼ 0 - 1ï¼Œæœ€é«˜ä¸º 1ï¼Œæœ€ä½ä¸º 0ï¼Œé»˜è®¤ä¸º 1ï¼‰ï¼ŒæœåŠ¡ç«¯åº”è¯¥ä¼˜å…ˆè¿”å›è¯­è¨€ç­‰äº zh-CN çš„ç‰ˆæœ¬ã€‚
                .addHeader("Accept-Language", "zh-CN,en-US;q=0.8,en;q=0.6")
                //å‘ŠçŸ¥æœåŠ¡å™¨å‘é€ä½•ç§å­—ç¬¦é›†   å¯¹åº”å“åº”å¤´Content
                .addHeader("Accept-Charset", "UTF-8")
                /**
                 * Accept-Encodingå‘ŠçŸ¥æœåŠ¡å™¨é‡‡ç”¨ä½•ç§å‹ç¼©æ–¹å¼ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œåå°å¯èƒ½è¿”å›gzipæ ¼å¼
                 * è¿”å›ä¹±ç çš„åŸå› å°±æ˜¯Okhttpæ²¡æœ‰æ­£ç¡®è§£å‹Gzipçš„æ•°æ®
                 * Okhttpä¸ä¼šå¸®ä½ å¤„ç†Gzipçš„è§£å‹ï¼Œéœ€è¦ä½ è‡ªå·±å»å¤„ç†ã€‚
                 */
                .header("Accept-Encoding", "")
                .addHeader("X-Access-Token", token?:"")
                .build()

        return chain.proceed(request)
    }
}
```

# 5. (å‘)Chain.proceed()åªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡

```kotlin
class TokenInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response  {
        val originalRequest = chain.request()
        val response = chain.proceed(originalRequest)
        //åˆ¤æ–­æ˜¯å¦Tokenè¿‡æœŸ
        if(response.code()==500) {
            try {
                val responseBody = response.body()
                val source = responseBody?.source()  //è§£å†³response.body().string()åªèƒ½æ‰“å°ä¸€æ¬¡
                source?.request(Long.MAX_VALUE) // Buffer the entire body.
                val buffer = source?.buffer
                var charset = Charset.forName("UTF-8")
                val responseStr = buffer?.clone()?.readString(charset)
                val tokenResponse = MoshiHelper.fromJson<TokenResponse>(responseStr!!)
                // {"timestamp":"2021-03-10 16:00:54",
                // "status":500,
                // "error":"Internal Server Error",
                // "message":"Tokenå¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•",
                // "path":"/jeecg-boot/sys/permission/getPhoneUserPermissionByToken"}
                tokenResponse?.let {
                    if(tokenResponse.status==500 && tokenResponse.message!!.contains("Tokenå¤±æ•ˆ")){
                        return refreshToken(chain, response)
                    }
                }
            }catch (e:Exception){
                e.printStackTrace()
            }
        }
        return response
    }

    private fun refreshToken(chain: Interceptor.Chain, oldResponse: Response) : Response{
        FLog.w("æ£€æµ‹åˆ°Tokenå·²ç»è¿‡æœŸï¼Œéœ€è¦åˆ·æ–°Token${Thread.currentThread()}")
        //åŒæ­¥è¯·æ±‚ï¼Œè·å–æœ€æ–°çš„Token
        val mmkv = MMKV.defaultMMKV()
        val oldToken = mmkv?.decodeString(Mmkv.KEY_TOKEN)
        val call = RetrofitClient.getService(PublicApiService::class.java)
                .changeToken(ChangeAppTokenBody(oldToken))
        val result : String? = call.execute().body()?.data()
        mmkv?.encode(Mmkv.KEY_TOKEN, result)    //å°†æ–°tokenä¿å­˜åˆ°æœ¬åœ°
        FLog.v("è€token:${oldToken}")
        FLog.v("æ–°token:${mmkv?.decodeString(Mmkv.KEY_TOKEN)}")
        result?.let {
            //åˆ›å»ºæ–°çš„è¯·æ±‚
            val newRequest = chain.request()
                    .newBuilder()
                    //è¿™é‡Œä¸ç”¨æ·»åŠ ï¼Œé‡æ–°è¯·æ±‚æ—¶HttpUrlInterceptoræ‹¦æˆªå™¨ä¸­ä¼šæ·»åŠ æ–°token
//                                    .header("X-Access-Token", result)
                    .build()
            //â˜…â˜…â˜…é‡æ–°è¯·æ±‚
            return chain.proceed(newRequest)
        }
        return oldResponse
    }
}
```

ä½¿ç”¨è‡ªå®šä¹‰æ‹¦æˆªå™¨å®ç°Tokenè¿‡æœŸè‡ªåŠ¨åˆ·æ–°åè‡ªåŠ¨é‡æ–°å‘èµ·è¯·æ±‚ï¼Œç»“æœé‡æ–°å‘èµ·è¯·æ±‚æ—¶æŠ¥é”™**`must call proceed() exactly once`**ï¼Œæœç´¢åå‘ç°æ˜¯æ·»åŠ æ‹¦æˆªå™¨çš„æ–¹å¼ä¸å¯¹ï¼Œ`addNetworkInterceptor()`æ·»åŠ çš„æ‹¦æˆªå™¨ä¸å…è®¸é‡è¯•ï¼ˆ`Chain.proceed()`è°ƒç”¨å¤šæ¬¡ï¼‰ï¼Œè€Œåº”è¯¥ä½¿ç”¨`addInterceptor()`æ·»åŠ æ‹¦æˆªå™¨ï¼š

```kotlin
//    Okhttp çš„addInterceptor å’Œ addNetworkInterceptor çš„åŒºåˆ«
//    addInterceptorï¼ˆåº”ç”¨æ‹¦æˆªå™¨ï¼‰ï¼š
//    1ï¼Œä¸éœ€è¦æ‹…å¿ƒä¸­é—´è¿‡ç¨‹çš„å“åº”,å¦‚é‡å®šå‘å’Œé‡è¯•.
//    2ï¼Œæ€»æ˜¯åªè°ƒç”¨ä¸€æ¬¡,å³ä½¿HTTPå“åº”æ˜¯ä»ç¼“å­˜ä¸­è·å–.
//    3ï¼Œè§‚å¯Ÿåº”ç”¨ç¨‹åºçš„åˆè¡·. ä¸å…³å¿ƒOkHttpæ³¨å…¥çš„å¤´ä¿¡æ¯å¦‚: If-None-Match.
//    4ï¼Œå…è®¸çŸ­è·¯è€Œä¸è°ƒç”¨ Chain.proceed(),å³ä¸­æ­¢è°ƒç”¨.
//    5ï¼Œå…è®¸é‡è¯•,ä½¿ Chain.proceed()è°ƒç”¨å¤šæ¬¡.
//    addNetworkInterceptorï¼ˆç½‘ç»œæ‹¦æˆªå™¨ï¼‰ï¼š
//    1ï¼Œèƒ½å¤Ÿæ“ä½œä¸­é—´è¿‡ç¨‹çš„å“åº”,å¦‚é‡å®šå‘å’Œé‡è¯•.
//    2ï¼Œå½“ç½‘ç»œçŸ­è·¯è€Œè¿”å›ç¼“å­˜å“åº”æ—¶ä¸è¢«è°ƒç”¨.
//    3ï¼Œåªè§‚å¯Ÿåœ¨ç½‘ç»œä¸Šä¼ è¾“çš„æ•°æ®.
//    4ï¼Œæºå¸¦è¯·æ±‚æ¥è®¿é—®è¿æ¥.
    private val okHttpClient = OkHttpClient.Builder()
            ...
            .addInterceptor(TokenInterceptor()) 
            .addInterceptor(HttpUrlInterceptor())
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = if(AppConfig.DEBUG)
                    HttpLoggingInterceptor.Level.BODY
                else HttpLoggingInterceptor.Level.BASIC
            })
            .build()
```

# 6. (å‘)OkHttpåªèƒ½å°†IOå¼‚å¸¸ä»æ‹¦æˆªå™¨å‘é€åˆ°è°ƒç”¨å¤„

## 6.1 èƒŒæ™¯

é¡¹ç›®ä¸­ä½¿ç”¨äº†tokenè®¤è¯æœºåˆ¶ï¼Œç”¨æˆ·è°ƒç”¨ç™»å½•æ¥å£ç™»å½•æˆåŠŸåå°è¿”å›å¦‚ä¸‹æ•°æ®:

- token ï¼š tokenä»¤ç‰Œï¼Œæœ‰æ•ˆæ—¶é—´è¾ƒçŸ­ï¼Œæ¯”å¦‚1å¤©
- tokenPeriodTime ï¼š tokenä»¤ç‰Œè¿‡æœŸæ—¶é—´æˆ³
- refreshToken ï¼šå½“tokenè¿‡æœŸåï¼Œæäº¤refreshTokenè®¿é—®tokenåˆ·æ–°çš„æ¥å£è·å–æ–°çš„tokenï¼Œæœ‰æ•ˆæœŸè¾ƒé•¿ç”¨äºå¼ºåˆ¶ç”¨æˆ·é‡æ–°ç™»å½•

tokenæœºåˆ¶æ˜¯ä¸ºäº†æœåŠ¡å™¨éªŒè¯å®¢æˆ·ç«¯èº«ä»½çš„ï¼Œä¸€äº›æ¥å£åªæœ‰ç™»å½•ç”¨æˆ·æ‰èƒ½è®¿é—®æœåŠ¡å™¨ã€‚ä¸ºäº†æé«˜tokençš„å®‰å…¨æ€§ï¼Œé€šå¸¸ä¼šç»™tokenè®¾ç½®ä¸€ä¸ªå¾ˆçŸ­çš„æœ‰æ•ˆæ—¶é—´ï¼Œå½“tokenè¿‡æœŸåå°±ä¸èƒ½ä½¿ç”¨äº†ï¼Œéš¾é“è®©ç”¨æˆ·é‡æ–°ç™»å½•ï¼Ÿè¿™æ ·ä½“éªŒå°±å¾ˆå·®ï¼Œä¸ºäº†æå‡ç”¨æˆ·ä½“éªŒï¼Œå‡ºç°äº†refreshTokenï¼Œå®ƒçš„æœ‰æ•ˆæ—¶é—´é€šå¸¸è¾ƒé•¿ï¼Œæ¯”å¦‚ä¸€ä¸ªæœˆã€ä¸€å¹´ï¼Œå½“tokenè¿‡æœŸåå¯ä»¥æäº¤refreshTokenæ¥è·å–æ–°çš„tokenå€¼ï¼ˆç”¨æˆ·æ— æ„ŸçŸ¥ï¼‰ï¼Œä½†æ˜¯refreshTokenä¹Ÿæœ‰è¿‡æœŸçš„æ—¶å€™ï¼Œå½“åˆ·æ–°tokenæ—¶åå°å¦‚æœè¿”å›é”™è¯¯â€œrefreshTokenå·²è¿‡æœŸâ€ï¼Œåˆ™éœ€è¦å¼ºåˆ¶ç”¨æˆ·é‡æ–°ç™»å½•ã€‚

> æœ‰äº›éœ€æ±‚æ˜¯å¦‚æœä¸€åˆ‡æ­£å¸¸æ°¸ä¸éœ€è¦å¼ºåˆ¶ç™»å½•ï¼Œé‚£å°±ä¸å­˜åœ¨refreshTokenå’ŒtokenPeriodTimeï¼Œåªéœ€è¦ä¸€ä¸ªtokenå°±å¯ä»¥äº†ã€‚æ¯æ¬¡è¯·æ±‚æ—¶å‘é€åŸå§‹è¯·æ±‚ï¼Œå½“æœåŠ¡å™¨è¿”å›tokenå¤±æ•ˆï¼Œé‚£å°±æäº¤è€tokenè·å–æ–°çš„tokenï¼Œå¦‚æœåˆ·æ–°tokenæˆåŠŸåˆ™é‡æ–°è¯·æ±‚ï¼Œåªæœ‰åˆ·æ–°tokenå¤±è´¥çš„æƒ…å†µä¸‹æ‰éœ€è¦å¼ºåˆ¶é‡æ–°ç™»å½•ï¼Œåˆ·æ–°tokenå¤±è´¥ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯éå¸¸å°‘è§çš„ï¼ˆå› ä¸ºæ—¢ç„¶åå°è¿”å›äº†tokenå¤±æ•ˆè¯´æ˜ç½‘ç»œé€šä¿¡æ­£å¸¸ï¼Œè€Œç«‹é©¬åˆ·æ–°tokenå¤±è´¥åªæœ‰å¯èƒ½æ˜¯è€tokenä¸åˆæ³•æˆ–è€…æœåŠ¡å™¨é”™è¯¯ï¼‰

æˆ‘ä»¬é€šè¿‡OkHttpæ‹¦æˆªå™¨æ¥å®ç°è¿™ä¸ªè¿‡ç¨‹ï¼š

```kotlin
/**
 * Author: openXu
 * Time: 2020/3/9 11:28
 * class: TokenInterceptor
 * Description: ç”¨äºæ£€æµ‹Tokenæ˜¯å¦è¿‡æœŸï¼Œå¦‚æœè¿‡æœŸè‡ªåŠ¨åˆ·æ–°ï¼Œå¦‚æœrefreshTokenä¹Ÿè¿‡æœŸåˆ™å¼ºåˆ¶é‡æ–°ç™»å½•
 */
class TokenInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response  {
        val originalRequest = chain.request()
        var token = MMKV.defaultMMKV()?.decodeString(Mmkv.KEY_TOKEN)
        var tokenPeriodTime = MMKV.defaultMMKV()?.decodeLong(Mmkv.KEY_TOKEN_TIME)

        if(tokenPeriodTime!=null && System.currentTimeMillis()>tokenPeriodTime){
            //1. tokenè¿‡æœŸäº†ï¼Œæäº¤refreshTokenåˆ·æ–°token
            var refreshToken = MMKV.defaultMMKV()?.decodeString(Mmkv.KEY_REFRESH_TOKEN)
            val call = RetrofitClient.getService(PublicApiService::class.java)
                    .changeToken(refreshToken)
            val response = call.execute()
            if(response.code()==200){  //ç½‘ç»œæ­£å¸¸
                when(response.body()?.code){
                    200 -> {
                        val newToken = response.body()?.data()
                        //2. åˆ·æ–°tokenæˆåŠŸï¼Œå°†æ–°tokenä¿å­˜åˆ°æœ¬åœ°
                        MMKV.defaultMMKV()?.encode(Mmkv.KEY_TOKEN, newToken)
                    }
                    else->{
                        //3. åˆ·æ–°tokenå¤±è´¥ï¼Œè·å–æ–°tokenä¸ºç©º
                        //https://stackoverflow.com/questions/58697459/handle-exceptions-thrown-by-a-custom-okhttp-interceptor-in-kotlin-coroutines
                        //https://github.com/square/okhttp/issues/5992
                        //â˜…â˜…â˜… æŠ›å‡ºä¸€ä¸ªç‰¹æ®Šçš„è‡ªå®šä¹‰å¼‚å¸¸ï¼Œç»Ÿä¸€é”™è¯¯å¤„ç†æ—¶æ£€æµ‹åˆ°è¯¥å¼‚å¸¸ä¼šå¼ºåˆ¶è·³è½¬åˆ°ç™»å½•é¡µ
                        // throw RuntimeException("ç™»å½•ä¿¡æ¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•")  âŒâŒâŒé”™è¯¯
                        // TODO OkHttpåªèƒ½å°†IOå¼‚å¸¸ä»æ‹¦æˆªå™¨ï¼ˆå­çº¿ç¨‹ï¼‰å‘é€åˆ°è°ƒç”¨å¤„çš„ä»£ç ï¼ˆè°ƒç”¨å¤„çš„çº¿ç¨‹ï¼‰ï¼Œå…¶ä»–ç±»å‹å¼‚å¸¸ç›´æ¥å°±å´©æºƒäº†
                        //class LoginException(var code: Int?, override var message: String?) : IOException()
                        throw LoginException(-1001, "ç™»å½•ä¿¡æ¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•")
                    }
                }
            }
        }
        //4. ç»§ç»­å‘èµ·è¯·æ±‚
        return chain.proceed(originalRequest)
    }
}
```

## 6.2 é—®é¢˜

é¡¹ç›®ä¸­ä½¿ç”¨çš„æ˜¯Retrofit+åç¨‹ï¼Œé€šè¿‡`viewModelScope`å¼€å¯åç¨‹ï¼Œå¹¶å°†é€šè¿‡`try`åŒ…è£¹åç¨‹ä»£ç å—å®ç°å¼‚å¸¸ç»Ÿä¸€å¤„ç†ã€‚ä¸Šé¢ä»£ç ç¬¬3æ­¥ï¼Œå½“åˆ·æ–°tokenå¤±è´¥æ—¶é€šè¿‡æŠ›å‡ºå¼‚å¸¸å®ç°å¼ºåˆ¶ç™»å½•ï¼Œåˆšå¼€å§‹æˆ‘éšä¾¿æŠ›äº†ä¸€ä¸ª`RuntimeException`ç±»å‹çš„å¼‚å¸¸ï¼Œç»“æœå¼‚å¸¸è¢«tryä½äº†ï¼Œä½†æ˜¯åº”ç”¨ç¨‹åºå´å´©æºƒäº†ã€‚ç„¶ååœ¨[okhttp Issues](https://github.com/square/okhttp/issues/5992)ä¸­æ‰¾åˆ°äº†ç­”æ¡ˆï¼Œæ˜¯å› ä¸º**OkHttpåªèƒ½å°†IOå¼‚å¸¸ä»æ‹¦æˆªå™¨ï¼ˆå­çº¿ç¨‹ï¼‰å‘é€åˆ°è°ƒç”¨å¤„çš„ä»£ç ï¼ˆè°ƒç”¨å¤„çš„çº¿ç¨‹ï¼‰ï¼Œå…¶ä»–ç±»å‹å¼‚å¸¸ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ**ã€‚æ‰€ä»¥æˆ‘è‡ªå®šä¹‰äº†ä¸€ä¸ª`LoginException`ç±»å‹çš„å¼‚å¸¸ï¼Œå®ƒç»§æ‰¿è‡ª`IOException`ï¼Œè¿™æ ·å°±å¯ä»¥æ•è·åˆ°è¿™ä¸ªå¼‚å¸¸å®ç°å¼ºåˆ¶ç™»å½•äº†

å°†é—®é¢˜å½’çº³ä¸€ä¸‹ï¼š**æ‹¦æˆªå™¨ä¸­çš„æ‰€æœ‰ç±»å‹å¼‚å¸¸åœ¨åç¨‹ä¸­éƒ½èƒ½è¢«tryä½ï¼Œä½†æ˜¯éIOExceptionå¼‚å¸¸ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ**

```kotlin
    protected fun launch(
            block: Block<Unit>,
            error: Error? = null,
            cancel: Cancel? = null,
            showErrorToast: Boolean = true
    ): Job {
        return viewModelScope.launch {
            try {
                block.invoke(this)
            } catch (e: Exception) {
                e.printStackTrace()
                FLog.e("blockæ‰§è¡Œå¼‚å¸¸ï¼š$e")
                when (e) {
                    is CancellationException -> {
                        cancel?.invoke(e)
                    }
                    else -> {
                        //â˜…â˜…â˜… ç»Ÿä¸€é”™è¯¯å¤„ç†
                        onError(e, showErrorToast)
                        error?.invoke(e)
                    }
                }
            }
        }
    }

    private fun onError(e: Exception, showErrorToast: Boolean) {
        when (e) {
            is LoginException ->{
                wToast.value="ç™»å½•ä¿¡æ¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•"
                startActivity("/module_common/login", Bundle())
                finish()
            }
            is ApiException -> {
                if (showErrorToast) wToast.value = e.message
            }
            // ç½‘ç»œè¯·æ±‚å¤±è´¥
            is ConnectException,
            ...
            is HttpException,
            is SSLHandshakeException ->
                if (showErrorToast) wToast.value="ç½‘ç»œè¯·æ±‚å¤±è´¥"
            // æ•°æ®è§£æé”™è¯¯
            is JsonDataException, is JsonEncodingException ->
                wToast.value="æ•°æ®è§£æé”™è¯¯"
            else -> // å…¶ä»–é”™è¯¯
                wToast.value=e.message
        }
    }

```

## 6.3 é—®é¢˜åŸå› 

æŸ¥çœ‹okhttpæºç ï¼Œé‡ç‚¹å…³æ³¨`AsyncCall`çš„`execute()`æ–¹æ³•ï¼Œè¯¥æ–¹æ³•åœ¨å­çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œ**å°†é™¤äº†`IOException`ç±»å‹çš„å¼‚å¸¸éƒ½æŠ›å‡ºä¼šå¯¼è‡´ç¨‹åºå´©æºƒï¼ŒåŒæ—¶å°†æ‰€æœ‰ç±»å‹å¼‚å¸¸éƒ½é€šè¿‡å›è°ƒè¿”å›åˆ°è°ƒç”¨å¤„ï¼Œæ‰€ä»¥å¯ä»¥tryä½å¼‚å¸¸ï¼ˆæ³¨æ„tryä½çš„å¼‚å¸¸æ˜¯é€šè¿‡åç¨‹æ¢å¤åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹å†throwçš„è€Œéå­çº¿ç¨‹ä¸­throwçš„é‚£ä¸ªå¼‚å¸¸ï¼‰**

```java
/**1 OkHttpçš„Callæ¥å£*/
public interface Call extends Cloneable {
    ...
    //å‘èµ·åŒæ­¥è¯·æ±‚
    Response execute() throws IOException;
    //å¼‚æ­¥è¯·æ±‚
    void enqueue(Callback responseCallback);
    ...
}

/**2 å¼‚æ­¥è¯·æ±‚å›è°ƒ*/
public interface Callback {
  //å¼‚æ­¥è¯·æ±‚çš„å¤±è´¥å›è°ƒä¸­åªå›è°ƒIOExceptionç±»å‹çš„å¼‚å¸¸
  void onFailure(Call call, IOException e);
  //æˆåŠŸå›è°ƒæ–¹æ³•åªæŠ›å‡ºIOExceptionç±»å‹çš„å¼‚å¸¸
  void onResponse(Call call, Response response) throws IOException;
}

/**3 Callçš„å®ç°ç±»*/
final class RealCall implements Call {
    //3.1 åŒæ­¥è¯·æ±‚å®ç°
    @Override 
    public Response execute() throws IOException {
        ...
        try {
          client.dispatcher().executed(this);
          //åŒæ­¥è¯·æ±‚:å¹¶æ²¡æœ‰å¤„ç†å¼‚å¸¸åªæ˜¯å°†å¼‚å¸¸æŠ›å‡ºå»äº†
          return getResponseWithInterceptorChain();
        } finally {
          client.dispatcher().finished(this);
        }
    }
    //â˜…3.1 å¼‚æ­¥è¯·æ±‚å®ç°
    @Override 
    public void enqueue(Callback responseCallback) {
        ...
        //å°†å½“å‰è¯·æ±‚åŒ…è£…ä¸ºä¸€ä¸ªAsyncCallç±»å‹çš„Runnableæ‰”è¿›çº¿ç¨‹æ± 
        client.dispatcher().enqueue(new AsyncCall(responseCallback));
    }

    //å†…éƒ¨ç±»Runnable
    final class AsyncCall extends NamedRunnable {
        @Override 
        protected void execute() {
          //ä»¥ä¸‹ä»£ç ä¼šåœ¨å­çº¿ç¨‹ä¸­æ‰§è¡Œ
          try {
            Response response = getResponseWithInterceptorChain();
            responseCallback.onResponse(RealCall.this, response);
          } catch (IOException e) {
            ...
            //â˜…â˜…â˜… IOå¼‚å¸¸é€šè¿‡å›è°ƒè¿”å›
            responseCallback.onFailure(RealCall.this, e);
          } catch (Throwable t) {
            cancel();
            if (!signalledCallback) {
              IOException canceledException = new IOException("canceled due to " + t);
              canceledException.addSuppressed(t);
              //â˜…â˜…â˜… å…¶ä»–ç±»å‹å¼‚å¸¸é€šè¿‡å›è°ƒè¿”å›
              responseCallback.onFailure(RealCall.this, canceledException);
            }
            //â˜…â˜…â˜…â˜…â˜…â˜… å°†å…¶ä»–å¼‚å¸¸åŸå°ä¸åŠ¨çš„æŠ›å‡ºå»
            throw t;   
          } finally {
            client.dispatcher().finished(this);
          }
        }
    }

    //ä¸ç®¡æ˜¯åŒæ­¥è¯·æ±‚è¿˜æ˜¯å¼‚æ­¥è¯·æ±‚éƒ½ä¼šè°ƒç”¨åˆ°è¿™é‡Œï¼Œæ‹¦æˆªå™¨æŠ›å‡ºçš„å¼‚å¸¸
    Response getResponseWithInterceptorChain() throws IOException {
        // åˆ›å»ºå®Œæ•´çš„æ‹¦æˆªå™¨æ ˆ
        List<Interceptor> interceptors = new ArrayList<>();
        interceptors.addAll(client.interceptors());
        interceptors.add(new RetryAndFollowUpInterceptor(client));
        interceptors.add(new BridgeInterceptor(client.cookieJar()));
        interceptors.add(new CacheInterceptor(client.internalCache()));
        interceptors.add(new ConnectInterceptor(client));
        if (!forWebSocket) {
          interceptors.addAll(client.networkInterceptors());
        }
        interceptors.add(new CallServerInterceptor(forWebSocket));
        //åˆ›å»ºä¸€ä¸ªæ‹¦æˆªå™¨é“¾
        Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,
            originalRequest, this, client.connectTimeoutMillis(),
            client.readTimeoutMillis(), client.writeTimeoutMillis());

        boolean calledNoMoreExchanges = false;
        try {
          //å‘èµ·è¯·æ±‚
          Response response = chain.proceed(originalRequest);
          if (transmitter.isCanceled()) {
            closeQuietly(response);
            throw new IOException("Canceled");
          }
          return response;
        } catch (IOException e) {
          //åªæ‹¦æˆªäº†IOå¼‚å¸¸ï¼Œå…¶å®è¿™é‡Œè¿˜æ˜¯å°†IOå¼‚å¸¸æŠ›å‡ºå»äº†ï¼Œåªæ˜¯åšäº†ä¸€äº›é‡åˆ¶å·¥ä½œ
          calledNoMoreExchanges = true;
          throw transmitter.noMoreExchanges(e);
        } finally {
          if (!calledNoMoreExchanges) {
            transmitter.noMoreExchanges(null);
          }
        }
    }
}
```

ä¸ç®¡æ˜¯é€šè¿‡Retrofitè¿˜æ˜¯ç›´æ¥ä½¿ç”¨OkHttpå‘èµ·ç½‘ç»œè¯·æ±‚ï¼Œæœ€åéƒ½æ˜¯ç”±okhttpæ¡†æ¶ä¸­çš„`okhttp3.Call`å¯¹è±¡å‘èµ·è¯·æ±‚çš„ï¼ŒOkHttpä¸­çš„`Call`çš„å®ç°ç±»ä¸º`RealCall`ï¼Œå‘ç°ä¸ç®¡æ˜¯åŒæ­¥è¯·æ±‚è¿˜æ˜¯å¼‚æ­¥è¯·æ±‚çš„å®ç°ï¼Œæœ€ç»ˆéƒ½è°ƒç”¨äº†`getResponseWithInterceptorChain()`æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸­å¹¶æ²¡æœ‰å¤„ç†æ‹¦æˆªå™¨ä¸­çš„æ‰€æœ‰å¼‚å¸¸ï¼Œè€Œæ˜¯å°†å¼‚å¸¸éƒ½æŠ›å‡ºå»äº†ã€‚æ–‡ç« å¼€å¤´ç¬¬ä¸€ä¸ªé—®é¢˜ä¸­æˆ‘ä»¬çŸ¥é“Retrofit+åç¨‹æœ€ç»ˆæ˜¯è°ƒç”¨äº†`call.enqueue()`å‘èµ·å¼‚æ­¥è¯·æ±‚ï¼Œæˆ‘ä»¬é‡ç‚¹å…³æ³¨RealCallçš„`enqueue()`ï¼Œå®ƒå°†å½“å‰è¯·æ±‚åŒ…è£…ä¸ºä¸€ä¸ªRunnableç±»å‹`AsyncCall`æ‰”åˆ°çº¿ç¨‹æ± (**å­çº¿ç¨‹**)ä¸­ï¼Œç„¶ååœ¨å­çº¿ç¨‹ä¸­æ‰§è¡Œ`execute()`ã€‚

`execute()`ä¸­è°ƒç”¨äº†`getResponseWithInterceptorChain()`å¹¶ä¸”å°†å…¶ç”¨tryåŒ…è£¹ï¼Œcatchåˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç¬¬ä¸€éƒ¨åˆ†æ˜¯å¤„ç†IOå¼‚å¸¸ï¼Œå°†IOå¼‚å¸¸é€šè¿‡å›è°ƒè¿”å›åˆ°è°ƒç”¨å¤„ï¼›ç¬¬äºŒéƒ¨åˆ†æ˜¯**å…¶ä»–ç±»å‹çš„å¼‚å¸¸`Throwable`ï¼ŒåŒæ ·é€šè¿‡å›è°ƒè¿”å›ï¼Œé‡ç‚¹æ˜¯æœ€åé€šè¿‡`throw`åˆå°†å¼‚å¸¸æŠ›äº†å‡ºå»ã€‚**

æˆ‘ä»¬å†æ¥çœ‹çœ‹åç¨‹ç›¸å…³çš„å¤„ç†ï¼š

```java
//Retrofitçš„Callçš„æ‰©å±•å‡½æ•°å‘èµ·è¯·æ±‚
KotlinExtensions.await(call, continuation);

/**Callçš„æ‰©å±•æ–¹æ³•ï¼Œè¢«å®šä¹‰åœ¨retrofit2.KotlinExtensions.ktæ–‡ä»¶ä¸­*/
suspend fun <T : Any> Call<T>.await(): T {
    return suspendCancellableCoroutine { continuation ->
        ...
        //1. å‘èµ·è¯·æ±‚ï¼šç›¸å½“äºthis.enqueueï¼Œè€Œæ‰©å±•æ–¹æ³•ä¸­çš„thiså°±æ˜¯OkHttpCallç±»å‹å¯¹è±¡
        enqueue(object : Callback<T> {
            override fun onResponse(call: Call<T>, response: Response<T>) {
                ...
                //è¿”å›å“åº”ç»“æœï¼Œæ¢å¤åç¨‹æ‰§è¡Œ
                continuation.resume(body)
            }
            //â˜…â˜…â˜… OkHttpæ‹¦æˆªå™¨çš„æ‰€ä»¥å¼‚å¸¸æœ€ç»ˆéƒ½ä¼šé€šè¿‡continuationæŠ›ç»™åˆ›å»ºåç¨‹çš„çº¿ç¨‹ï¼ˆä¸»çº¿ç¨‹ï¼‰
            override fun onFailure(call: Call<T>, t: Throwable) {
                continuation.resumeWithException(t)
            }
        })
    }
}


//2. Retrofitçš„Callå®ç°ç±»OkHttpCallä¸­çš„enqueue()
public void enqueue(final Callback<T> callback) {

    okhttp3.Call call;
    Throwable failure;
    //...çœç•¥okhttp3.Callå¯¹è±¡çš„åˆ›å»º
    //è°ƒç”¨okhttpçš„RealCall.enqueue()
    call.enqueue(
        //OkHttpå±‚çš„å›è°ƒ
        new okhttp3.Callback() {
          @Override
          public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {
            ...
            Response<T> response = parseResponse(rawResponse);
            ...
            callback.onResponse(OkHttpCall.this, response);
            ...
          }
          @Override
          //å¼‚å¸¸å›è°ƒ
          public void onFailure(okhttp3.Call call, IOException e) {
            callFailure(e);
          }
          private void callFailure(Throwable e) {
              //å°†OkHttpçš„å¼‚å¸¸é€šè¿‡å›è°ƒè¿”å›åˆ°Retrofitå±‚çš„å›è°ƒä¸­
              callback.onFailure(OkHttpCall.this, e);
              ...
          }
        });
  }

```

å½“æˆ‘ä»¬è°ƒç”¨Retrofitå®šä¹‰çš„æŒ‚èµ·æ¥å£æ—¶ï¼Œä¼šè°ƒç”¨åˆ°Retrofitçš„OkHttpCallç±»å‹çš„æ‰©å±•å‡½æ•°`await()`ï¼›ç„¶åè°ƒç”¨å…¶`enqueue()`æ–¹æ³•ï¼Œåˆ›å»ºokhttp3çš„`Call`å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯OkHttpå±‚çš„`RealCall`å¯¹è±¡ï¼›ç„¶åè°ƒç”¨`RealCall.enqueue()`ã€‚çœ‹èµ·æ¥è°ƒç”¨é“¾æ¯”è¾ƒå¤æ‚ï¼Œå…¶å®æˆ‘ä»¬åªéœ€è¦å…³æ³¨å¤´(å‘èµ·è°ƒç”¨å¤„)å’Œå°¾(å¼‚å¸¸æŠ›å‡ºå¤„)ï¼š

- å°¾:`RealCall.enqueue()`åœ¨å­çº¿ç¨‹æ‰§è¡Œçš„æ—¶å€™æ•è·äº†æ‰€æœ‰å¼‚å¸¸ï¼Œå¹¶é€šè¿‡callbackå°†å¼‚å¸¸å›è°ƒåˆ°è°ƒç”¨å¤„ï¼›é™¤æ­¤ä¹‹å¤–è¿˜å°†é™¤äº†IOç±»å‹çš„å¼‚å¸¸éƒ½æŠ›å‡ºå»äº†
- å¤´ï¼šRetrofitçš„Callæ‰©å±•å‡½æ•°`await()`ä¸­åœ¨`onFailure()`é‡Œæ‹¿åˆ°å›è°ƒçš„å¼‚å¸¸åï¼Œé€šè¿‡ç»­ä½“`continuation`å°†å¼‚å¸¸å¯¹è±¡å¸¦åˆ°äº†åç¨‹æ‰€åœ¨çš„çº¿ç¨‹(ä¸»çº¿ç¨‹)ï¼Œç„¶ååœ¨ä¸»çº¿ç¨‹throwå‡ºå»ã€‚(è¿™éƒ¨åˆ†æ¶‰åŠåˆ°åç¨‹æŒ‚èµ·å’Œæ¢å¤çš„åŸç†)

å›åˆ°æˆ‘ä»¬çš„é—®é¢˜ï¼š**æ‹¦æˆªå™¨ä¸­çš„æ‰€æœ‰ç±»å‹å¼‚å¸¸åœ¨åç¨‹ä¸­éƒ½èƒ½è¢«tryä½ï¼Œä½†æ˜¯éIOExceptionå¼‚å¸¸ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ**

**é€šè¿‡`viewModelScope`åœ¨ä¸»çº¿ç¨‹ä¸­å¼€å¯åç¨‹ï¼Œå¹¶å°†æ¥å£è¯·æ±‚ä»£ç å—tryä½ï¼Œè™½ç„¶æ‹¦æˆªå™¨æŠ›å‡ºçš„æ‰€æœ‰ç±»å‹çš„å¼‚å¸¸éƒ½èƒ½è¢«tryä½ï¼Œæ˜¯å› ä¸ºé€šè¿‡åç¨‹æ¢å¤å°†å¼‚å¸¸å¯¹è±¡åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹æŠ›å‡ºçš„ï¼Œæ‰€ä»¥ä¸»çº¿ç¨‹tryä½çš„å¼‚å¸¸å¯¹è±¡å¹¶ä¸æ˜¯å­çº¿ç¨‹ä¸­throwçš„é‚£ä¸ªå¼‚å¸¸å¯¹è±¡ã€‚ä¸»çº¿ç¨‹å¹¶ä¸èƒ½tryä½å­çº¿ç¨‹æŠ›å‡ºçš„å¼‚å¸¸ï¼Œ`execute()`ä¸­å°†é™¤äº†`IOException`ç±»å‹çš„å¼‚å¸¸éƒ½throwå‡ºå»æ‰€ä»¥å¯¼è‡´äº†ç¨‹åºå´©æºƒã€‚**


## 6.4 æ€è€ƒï¼šä¸ºä»€ä¹ˆä¹‹å‰ä½¿ç”¨Retrofit+RxJavaçš„æ—¶å€™æ²¡æœ‰é‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Ÿ

æˆ‘ä»¬é€šå¸¸ä½¿ç”¨`addCallAdapterFactory(RxJava2CallAdapterFactory.create())`ä¸ºRetrofitæ·»åŠ RxJavaæ¥å£é€‚é…å™¨ï¼Œåœ¨åˆ›å»ºé€‚é…å™¨å·¥å‚çš„æ—¶å€™æ˜¯é€šå¸¸æ˜¯(é»˜è®¤)è°ƒç”¨`create()`ï¼Œå®ƒåˆ›å»ºçš„å·¥å‚ç”Ÿäº§çš„é€‚é…å™¨çš„`isAsync`ä¸ºfalseï¼Œæ„æ€æ˜¯é€‚é…å™¨ç”Ÿäº§çš„`Observable`å°†ä»¥éå¼‚æ­¥(åŒæ­¥)çš„æ–¹å¼å‘èµ·è¯·æ±‚ã€‚`RxJava2CallAdapter`çš„`adapt()`æ–¹æ³•åˆ¤æ–­isAsyncä¸ºfalseæ˜¯ä¼šå°†callè½¬æ¢ä¸º`CallExecuteObservable`ç±»å‹ï¼Œå‰©ä¸‹çš„æƒ³èƒ½èƒ½æƒ³åˆ°äº†ï¼Œåœ¨`CallExecuteObservable`çš„`subscribeActual()`ä¸­è°ƒç”¨`call.execute()`å‘èµ·åŒæ­¥è¯·æ±‚ï¼Œå¹¶å°†æ‰€æœ‰ç±»å‹å¼‚å¸¸tryä½ã€‚OkHttpçš„åŒæ­¥è¯·æ±‚å¹¶æ²¡æœ‰å¤„ç†å¼‚å¸¸ï¼Œè€Œæ˜¯æŠ›ç»™äº†RxJavaï¼ŒRxJavaåœ¨å­çº¿ç¨‹ä¸­tryä½äº†å¼‚å¸¸å¹¶å°†å¼‚å¸¸ç»Ÿä¸€å‘å°„ç»™ä¸‹æ¸¸`Observer`ï¼Œé€šè¿‡`onErrorResumeNext(new NetErrorFunction())`æ“ä½œç¬¦å°±å¯ä»¥æ‹¦æˆªå¹¶ç»Ÿä¸€å¤„ç†æ‰€æœ‰ç±»å‹çš„å¼‚å¸¸äº†ã€‚

å¦‚æœæˆ‘ä»¬é€šè¿‡`createAsync()`æˆ–è€…`createWithScheduler()`åˆ›å»ºå¼‚æ­¥é€‚é…å™¨å·¥å‚ï¼Œé‚£ä¹Ÿä¼šé‡åˆ°æ‹¦æˆªå™¨æŠ›å‡ºç»™IOå¼‚å¸¸å¯¼è‡´ç¨‹åºå´©æºƒçš„é—®é¢˜

```java
/**1. RxJava2é€‚é…å™¨å·¥å‚*/
public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
  //1.1 åˆ›å»ºè¿”å›åŒæ­¥æ­¥è§‚å¯Ÿçš„æ¥å£é€‚é…å™¨
  public static RxJava2CallAdapterFactory create() {
    return new RxJava2CallAdapterFactory(null, false);
  }

  //1.2 åˆ›å»ºè¿”å›å¼‚æ­¥è§‚å¯Ÿçš„æ¥å£é€‚é…å™¨
  public static RxJava2CallAdapterFactory createAsync() {
    return new RxJava2CallAdapterFactory(null, true);
  }
  //1.3 è‡ªå®šä¹‰è°ƒåº¦å™¨
  public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
    if (scheduler == null) throw new NullPointerException("scheduler == null");
    return new RxJava2CallAdapterFactory(scheduler, false);
  }

  private final @Nullable Scheduler scheduler;
  private final boolean isAsync;   //æ˜¯å¦å¼‚æ­¥æ–¹å¼

  private RxJava2CallAdapterFactory(@Nullable Scheduler scheduler, boolean isAsync) {
    this.scheduler = scheduler;
    this.isAsync = isAsync;
  }

  @Override
  public @Nullable CallAdapter<?, ?> get(
      Type returnType, Annotation[] annotations, Retrofit retrofit) {
    ...
    //åˆ›å»ºæ¥å£é€‚é…å™¨å¯¹è±¡
    return new RxJava2CallAdapter(
        responseType, scheduler, isAsync, isResult, isBody, isFlowable, isSingle, isMaybe, false);
  }
}

/**2. RxJava2é€‚é…å™¨*/
final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
  ...
  private final boolean isAsync;
  ...
  @Override
  public Object adapt(Call<R> call) {
    //â˜…â˜…â˜… æ ¹æ®isAsyncåˆ¤æ–­è¿”å›åŒæ­¥çš„Observableè¿˜æ˜¯å¼‚æ­¥Observable
    Observable<Response<R>> responseObservable =
        isAsync ? new CallEnqueueObservable<>(call) : new CallExecuteObservable<>(call);

    Observable<?> observable;
    if (isResult) {
      observable = new ResultObservable<>(responseObservable);
    } else if (isBody) {
      observable = new BodyObservable<>(responseObservable);
    } else {
      observable = responseObservable;
    }
    ...
    return RxJavaPlugins.onAssembly(observable);
  }
}

/**3. åŒæ­¥æ‰§è¡Œçš„è§‚å¯Ÿè€…*/
final class CallExecuteObservable<T> extends Observable<Response<T>> {
  private final Call<T> originalCall;
  ...
  @Override //è®¢é˜…åæ‰§è¡Œ
  protected void subscribeActual(Observer<? super Response<T>> observer) {
    ...
    //å°†åŒæ­¥è¯·æ±‚ä»£ç tryä½
    try {  
      //å‘èµ·åŒæ­¥è¯·æ±‚
      Response<T> response = call.execute();
      if (!disposable.isDisposed()) {
        observer.onNext(response);
      }
      if (!disposable.isDisposed()) {
        terminated = true;
        observer.onComplete();
      }
    } catch (Throwable t) {
      //tryä½æ‰€æœ‰ç±»å‹çš„å¼‚å¸¸
      Exceptions.throwIfFatal(t);
      if (terminated) {
        RxJavaPlugins.onError(t);
      } else if (!disposable.isDisposed()) {
        try {
          observer.onError(t);  //å‘é€ç»™è§‚å¯Ÿè€…
        } catch (Throwable inner) {
          Exceptions.throwIfFatal(inner);
          RxJavaPlugins.onError(new CompositeException(t, inner));
        }
      }
    }
  }
  ...
}
```


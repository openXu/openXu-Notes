



Java虚拟机又叫JVM（Java Virtual Machine），它与Java语言没有必然的联系，而是与特定的二进制格式class文件关联，它是一个通用的、机器无关的执行平台，所有可以编译成class文件的语言都能在JVM上执行（比如Java、Groovy）。class文件包含了Java虚拟机指令集（字节码）、符号表及其他辅助信息。Java虚拟机是一个字节码文件(Class文件)翻译器，它将字节码文件翻译成各个系统对应的机器码，确保字节码文件能在各个系统正确运行，从而实现跨平台。

Java虚拟机是一种抽象化的概念，它规范了很多细节标准，所有对它的实现都需要参考该标准。它有很多种实现，包括`HotSpot VM`、`J9 VM`、`Zing VM`、`Dalvik / ART`等。虽然Google宣称Dalvik和ART不是“JVM”，但骨子里它就是不折不扣的JVM，它们的设计处处有标注对JVM规范的参考，以保证语义符合JVM规范的要求；那个基于寄存器的字节码设计只是一种实现优化而已。所以该系列文章其实不是讲解某一款虚拟机实现，而是描述JVM虚拟机的抽象化规范。


# 1. 运行时数据区（内存结构）

Java虚拟机定义了若干程序运行期间会使用到的运行时数据区，其中Java堆、方法区、常量池会随着虚拟机启动退出而创建和销毁，另pc寄存器、Java虚拟机栈、本地方法栈则以线程的开始和结束而创建和销毁。

**Java堆**

堆(heap)可供各个线程共享，用于存储所有类实例对象和数组对象，是jvm内存中空间最大的一块内存，也是gc垃圾收集器主要光顾的地方。根据对象存活时间不同，Java堆还被分为年轻代、老年代两个区域，年轻代还被进一步划分为Eden区、From Survivor 0、To Survivor1区（Survivor：幸存者）。可设置新生代和老年代的相对大小，参数 -XX:NewRatio 设置老年代与新生代的比例。例如`-XX:NewRatio=8`指定老年代/新生代为8/1. 老年代占堆大小的7/8 ，新生代占1/8 .(默认即使1/8)。

对象永远优先被分配在年轻代的Eden区，除非对象过大超过阈值`-XX:PretenureSizeThresold`会直接分配在老年代中，等到Eden区域内存不够时，Java虚拟机会启动垃圾回收。此时Eden区中没有被引用的对象的内存就会被回收，没有被回收的对象会移动到Survivor区，当经过一定次数的GC还没有被回收的对象则会进入到老年代。在 JVM 中有一个名为`-XX:MaxTenuringThreshold=15`的参数专门用来设置晋升到老年代所需要经历的GC次数，即在年轻代的对象经过了指定次数的 GC后，将在下次GC时进入老年代。

因为存活时间短的对象有很多，那么势必导致较为频繁的垃圾回收。而垃圾回收时不得不对所有内存都进行扫描，但其实有一部分对象，它们存活时间很长，对他们进行扫描完全是浪费时间。因此为了提高垃圾回收效率，分区就理所当然了。

**方法区**

方法区是可供各个线程共享的内存区域，用于存储每个类的结构信息(Class字节码数据)，比如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集和压缩。

**运行时常量池**

运行时常量池是class文件中每个类或接口的常量池表的运行时表示形式，它包括了若干种不同的常量(final修饰)。常量池在方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。

**pc寄存器**

Java虚拟机支持多条线程同时执行，每一条线程都有自己的pc(program counter)寄存器。在任意时刻线程只会执行一个方法的代码，这个方法称为该线程的当前方法。pc寄存器用来保存当前正在执行的字节码指定的地址，可以理解为当前正在执行的代码的行号。

**Java虚拟机栈**

每个线程都有自己私有的Java虚拟机栈，用于存储栈帧(Frame)。它用于存储方法的局部变量和一些尚未算好的结果。Java虚拟机规范允许栈被是现成固定大小，也可以根据计算动态扩展和收缩。如果采用固定大小，可以在线程创建的时候指定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机会抛出`StockOverflowError`；如果没有足够的内存供栈请求则会抛出`OutOfMemoryError`。

栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁，所以我们常说方法进栈出栈。每个栈帧有自己的局部变量表、操作数栈和指向当前方法所属类的运行时常量池的引用。

线程当前正在执行的那个方法（当前方法）的栈帧是活动的（当前栈帧）。如果当前方法中调用了其他方法，这个方法的栈帧就不再是当前栈帧了，调用新方法会导致新的栈帧创建，程序控制权移交到新方法而成为新的当前栈帧，新方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，然后虚拟机会丢弃当前栈帧（出栈），使得前一个栈帧重新成为当前栈帧。


**本地方法栈**

Java虚拟机实现可能会用到传统的栈（C stack）来支持native方法的执行，这个栈就是本地方法栈，它和Java虚拟机栈是相似的，只是方法对应的语言不同。


# 2. class文件

class文件由字节流组成，每个字节含有8个二进制位，16位、32位、64位长度的数据将通过构造成2、4、8个连续8位字节来表示。还有专用的数据类型用于表示class文件内容，包括u1、u2、u4，分别代表1、2、4个字节的无符号数。需要注意的是class文件是16进制表示的，一个字节8位由0x0000的形式表示。每个class文件对应如下所示的ClassFile结构：

```Java
ClassFile {

	//魔数，确定这个文件是否为一个能被虚拟机接受的class文件
	u4                magic;         
	//class文件的格式版本号，用于验证该class文件版本是否被虚拟机支持
	u2                minor_version;  //副版本号
	u2                major_version;  //主版本号
	//常量池计数器 = 常量表池中成员数+1
	u2                constant_pool_count;
	//常量池，是一种表结构，以1~constant_pool_count-1为索引
	cp_info           constant_pool(constant_pool_count-1)
	//访问标志，用于表示类和接口的访问权限及属性(比如0x0001为public、0x0010为final...)
	u2                access_flags;

	u2                this_class;
	u2                super_class;
	u2                interfaces_count;
	u2                interfaces[interfaces_count];
	u2                fields_count;
	field_info        fields[fields_count];
	u2                methods_count;
	method_info       methods[methods_count];
	u2                attributes_count;
	attribute_info    attributes[attributes_count];

}

```






# 3. 类加载、链接与初始化





































































